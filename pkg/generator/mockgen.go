package generator

import (
	"fmt"
	"go/token"
	"os"
	"path/filepath"
	"strings"

	"github.com/dave/dst"
	"github.com/dave/dst/decorator"
	"github.com/dave/dst/decorator/resolver/goast"

	"github.com/myshkin5/moqueries/pkg/logs"
)

const (
	headerComment = "// Code generated by Moqueries - https://github.com/myshkin5/moqueries - DO NOT EDIT!"
)

//go:generate moqueries --destination moq_converterer_test.go Converterer

// Converterer is the interface used by MockGenerator to invoke a Converter
type Converterer interface {
	BaseStruct(typeSpec *dst.TypeSpec, funcs []Func) (structDecl *dst.GenDecl)
	IsolationStruct(typeName, suffix string) (structDecl *dst.GenDecl)
	MethodStructs(typeName, prefix string, fn Func) (structDecls []dst.Decl)
	NewFunc(typeSpec *dst.TypeSpec, funcs []Func) (funcDecl *dst.FuncDecl)
	IsolationAccessor(typeName, suffix, fnName string) (funcDecl *dst.FuncDecl)
	FuncClosure(typeName, pkgPath string, fn Func) (funcDecl *dst.FuncDecl)
	MockMethod(typeName string, fn Func) (funcDecl *dst.FuncDecl)
	RecorderMethods(typeName string, fn Func) (funcDecls []dst.Decl)
}

// MockGenerator generates mocks
type MockGenerator struct {
	public      bool
	pkg         string
	dest        string
	loadTypesFn LoadTypesFn
	converter   Converterer
}

//go:generate moqueries --destination moq_loadtypesfn_test.go LoadTypesFn

// LoadTypesFn is used to load types from a given package
type LoadTypesFn func(pkg string, loadTestTypes bool) (typeSpecs []*dst.TypeSpec, pkgPath string, err error)

// New returns a new MockGenerator
func New(public bool, pkg, dest string, loadTypesFn LoadTypesFn, converter Converterer) *MockGenerator {
	return &MockGenerator{
		public:      public,
		pkg:         pkg,
		dest:        dest,
		loadTypesFn: loadTypesFn,
		converter:   converter,
	}
}

// Generate generates mocks for the given types in the given destination package
func (g *MockGenerator) Generate(inTypes []string, imp string, testImp bool) (*token.FileSet, *dst.File, error) {
	pkg, err := g.defaultPackage()
	if err != nil {
		return nil, nil, err
	}

	typesByIdent, pkgPath, err := g.findTypes(inTypes, imp, testImp)
	if err != nil {
		return nil, nil, err
	}

	fSet, file, err := initializeFile(pkg)
	if err != nil {
		return nil, nil, err
	}

	var decls []dst.Decl
	for _, inType := range inTypes {
		ident := dst.Ident{
			Name: inType,
			Path: pkgPath,
		}
		typeSpec := typesByIdent[ident.String()]

		funcs, tErr := g.findFuncs(typeSpec, typesByIdent)
		if tErr != nil {
			return nil, nil, tErr
		}

		decls = append(decls, g.structs(typeSpec, funcs)...)

		decls = append(decls, g.converter.NewFunc(typeSpec, funcs))

		decls = append(decls, g.methods(typeSpec, pkgPath, funcs)...)
	}
	file.Decls = decls

	return fSet, file, err
}

func (g *MockGenerator) defaultPackage() (string, error) {
	pkg := g.pkg
	var err error
	if pkg == "" {
		dirPath := filepath.Dir(g.dest)
		if dirPath == "." {
			dirPath, err = os.Getwd()
			if err != nil {
				return "", err
			}
		}
		dirName := filepath.Base(dirPath)
		pkg = dirName + "_test"
	}
	logs.Debugf("Output package: %s", pkg)
	return pkg, nil
}

func initializeFile(pkg string) (*token.FileSet, *dst.File, error) {
	fSet := token.NewFileSet()

	src := fmt.Sprintf("%s\n\npackage %s\n", headerComment, pkg)
	file, err := decorator.NewDecoratorWithImports(fSet, pkg, goast.New()).Parse(src)
	if err != nil {
		return nil, nil, err
	}

	return fSet, file, nil
}

func (g *MockGenerator) findTypes(
	inTypes []string, pkg string, loadTestTypes bool) (map[string]*dst.TypeSpec, string, error) {
	typeSpecs, pkgPath, err := g.loadTypes(pkg, loadTestTypes)
	if err != nil {
		return nil, "", err
	}

	typesByIdent := map[string]*dst.TypeSpec{}
	for _, typeSpec := range typeSpecs {
		// We have to make a new ident as key because loaded types don't have
		// Path set?
		ident := dst.Ident{
			Name: typeSpec.Name.Name,
			Path: pkgPath,
		}
		typesByIdent[ident.String()] = typeSpec
	}

	for _, inType := range inTypes {
		ident := dst.Ident{
			Name: inType,
			Path: pkgPath,
		}
		_, ok := typesByIdent[ident.String()]
		if !ok {
			return nil, "", fmt.Errorf("type was not found: %s", inType)
		}
	}

	return typesByIdent, pkgPath, nil
}

const testPkgSuffix = "_test"

func (g *MockGenerator) loadTypes(pkg string, loadTestTypes bool) ([]*dst.TypeSpec, string, error) {
	if strings.HasSuffix(pkg, testPkgSuffix) {
		pkg = strings.TrimSuffix(pkg, testPkgSuffix)
		loadTestTypes = true
	}
	return g.loadTypesFn(pkg, loadTestTypes)
}

func (g *MockGenerator) findFuncs(
	typeSpec *dst.TypeSpec, typesByIdent map[string]*dst.TypeSpec) ([]Func, error) {
	switch typ := typeSpec.Type.(type) {
	case *dst.InterfaceType:
		return g.loadNestedInterfaces(typ, typesByIdent)
	case *dst.FuncType:
		return []Func{
			{
				Params:  typ.Params,
				Results: typ.Results,
			},
		}, nil
	default:
		logs.Panicf("Unknown type: %v", typeSpec.Type)
		panic("unreachable")
	}
}

func (g *MockGenerator) loadNestedInterfaces(
	iType *dst.InterfaceType,
	typesByIdent map[string]*dst.TypeSpec) ([]Func, error) {
	var funcs []Func

	for _, method := range iType.Methods.List {
		switch typ := method.Type.(type) {
		case *dst.FuncType:
			funcs = append(funcs, Func{
				Name:    method.Names[0].Name,
				Params:  typ.Params,
				Results: typ.Results,
			})
		case *dst.Ident:
			nestedType, ok := typesByIdent[typ.String()]
			if !ok {
				newTypes, _, err := g.findTypes([]string{typ.Name}, typ.Path, false)
				if err != nil {
					return nil, err
				}
				for k, v := range newTypes {
					typesByIdent[k] = v
				}
				nestedType = typesByIdent[typ.String()]
			}

			newFuncs, err := g.findFuncs(nestedType, typesByIdent)
			if err != nil {
				return nil, err
			}
			funcs = append(funcs, newFuncs...)
		default:
			logs.Panicf("Unknown type in interface method list: %v", method.Type)
		}
	}

	return funcs, nil
}

func (g *MockGenerator) structs(typeSpec *dst.TypeSpec, funcs []Func) []dst.Decl {
	decls := []dst.Decl{
		g.converter.BaseStruct(typeSpec, funcs),
	}

	decls = append(decls, g.converter.IsolationStruct(typeSpec.Name.Name, mockIdent))
	decls = append(decls, g.converter.IsolationStruct(typeSpec.Name.Name, recorderIdent))

	for _, fn := range funcs {
		prefix := mockName(typeSpec.Name.Name)
		if _, ok := typeSpec.Type.(*dst.InterfaceType); ok {
			prefix = fmt.Sprintf("%s_%s", prefix, fn.Name)
		}
		decls = append(decls, g.converter.MethodStructs(typeSpec.Name.Name, prefix, fn)...)
	}

	return decls
}

func (g *MockGenerator) methods(typeSpec *dst.TypeSpec, pkgPath string, funcs []Func) []dst.Decl {
	var decls []dst.Decl

	switch typeSpec.Type.(type) {
	case *dst.InterfaceType:
		decls = append(decls, g.converter.IsolationAccessor(typeSpec.Name.Name, mockIdent, mockFnName))

		for _, fn := range funcs {
			decls = append(decls, g.converter.MockMethod(typeSpec.Name.Name, fn))
		}

		decls = append(decls, g.converter.IsolationAccessor(typeSpec.Name.Name, recorderIdent, onCallIdent))

		for _, fn := range funcs {
			decls = append(decls, g.converter.RecorderMethods(typeSpec.Name.Name, fn)...)
		}
	case *dst.FuncType:
		if len(funcs) != 1 {
			logs.Panicf("Function mocks should have just one function, found: %d", len(funcs))
		}

		decls = append(decls, g.converter.FuncClosure(typeSpec.Name.Name, pkgPath, funcs[0]))

		decls = append(decls, g.converter.MockMethod(typeSpec.Name.Name, funcs[0]))

		decls = append(decls, g.converter.RecorderMethods(typeSpec.Name.Name, funcs[0])...)
	default:
		logs.Panicf("Unknown type: %v", typeSpec.Type)
	}

	return decls
}
