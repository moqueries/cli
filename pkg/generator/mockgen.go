package generator

import (
	"fmt"
	"go/token"
	"os"
	"path/filepath"

	"github.com/dave/dst"
	"github.com/dave/dst/decorator"
	"github.com/dave/dst/decorator/resolver/goast"

	"github.com/myshkin5/moqueries/pkg/logs"
)

const (
	headerComment = "// Code generated by Moqueries - https://github.com/myshkin5/moqueries - DO NOT EDIT!"
)

//go:generate moqueries --destination mock_converterer_test.go Converterer

// Converterer is the interface used by MockGenerator to invoke a Converter
type Converterer interface {
	BaseStruct(typeSpec *dst.TypeSpec, funcs []Func) (structDecl *dst.GenDecl)
	ParamResultStruct(
		typeName, prefix, label string, fieldList *dst.FieldList, comparable bool) (structDecl *dst.GenDecl)
	NewMockFn(typeSpec *dst.TypeSpec, funcs []Func) (funcDecl *dst.FuncDecl)
	Method(typeName string, fn Func) (funcDecl *dst.FuncDecl)
	FuncClosure(typeName, pkgPath string, fn Func) (funcDecl *dst.FuncDecl)
}

// MockGenerator generates mocks
type MockGenerator struct {
	public    bool
	pkg       string
	dest      string
	loadTypes LoadTypesFn
	converter Converterer
}

//go:generate moqueries --destination mock_loadtypesfn_test.go LoadTypesFn

// LoadTypesFn is used to load types from a given package
type LoadTypesFn func(pkg string) (typeSpecs []*dst.TypeSpec, pkgPath string, err error)

// New returns a new MockGenerator
func New(public bool, pkg, dest string, loadTypes LoadTypesFn, converter Converterer) *MockGenerator {
	return &MockGenerator{
		public:    public,
		pkg:       pkg,
		dest:      dest,
		loadTypes: loadTypes,
		converter: converter,
	}
}

// Generate generates mocks for the given types in the given destination package
func (g *MockGenerator) Generate(inTypes []string, imp string) (*token.FileSet, *dst.File, error) {
	pkg, err := g.defaultPackage()
	if err != nil {
		return nil, nil, err
	}

	typesByIdent, pkgPath, err := g.findTypes(inTypes, imp)
	if err != nil {
		return nil, nil, err
	}

	fSet, file, err := initializeFile(pkg)
	if err != nil {
		return nil, nil, err
	}

	var decls []dst.Decl
	for _, inType := range inTypes {
		ident := dst.Ident{
			Name: inType,
			Path: pkgPath,
		}
		typeSpec := typesByIdent[ident.String()]

		funcs, tErr := g.findFuncs(typeSpec, typesByIdent)
		if tErr != nil {
			return nil, nil, tErr
		}

		iDecls, tErr := g.mockStructs(typeSpec, funcs)
		if tErr != nil {
			return nil, nil, tErr
		}
		decls = append(decls, iDecls...)

		decls = append(decls, g.converter.NewMockFn(typeSpec, funcs))

		mDecls, tErr := g.methods(typeSpec, pkgPath, funcs)
		if tErr != nil {
			return nil, nil, tErr
		}
		decls = append(decls, mDecls...)
	}
	file.Decls = decls

	return fSet, file, err
}

func (g *MockGenerator) defaultPackage() (string, error) {
	pkg := g.pkg
	var err error
	if pkg == "" {
		dirPath := filepath.Dir(g.dest)
		if dirPath == "." {
			dirPath, err = os.Getwd()
			if err != nil {
				return "", err
			}
		}
		dirName := filepath.Base(dirPath)
		pkg = dirName + "_test"
	}
	logs.Debugf("Output package: %s", pkg)
	return pkg, nil
}

func initializeFile(pkg string) (*token.FileSet, *dst.File, error) {
	fSet := token.NewFileSet()

	src := fmt.Sprintf("%s\n\npackage %s\n", headerComment, pkg)
	file, err := decorator.NewDecoratorWithImports(fSet, pkg, goast.New(), true).Parse(src)
	if err != nil {
		return nil, nil, err
	}

	return fSet, file, nil
}

func (g *MockGenerator) findTypes(inTypes []string, pkg string) (map[string]*dst.TypeSpec, string, error) {
	typeSpecs, pkgPath, err := g.loadTypes(pkg)
	if err != nil {
		return nil, "", err
	}

	typesByIdent := map[string]*dst.TypeSpec{}
	for _, typeSpec := range typeSpecs {
		// We have to make a new ident as key because loaded types don't have
		// Path set?
		ident := dst.Ident{
			Name: typeSpec.Name.Name,
			Path: pkgPath,
		}
		typesByIdent[ident.String()] = typeSpec
	}

	for _, inType := range inTypes {
		ident := dst.Ident{
			Name: inType,
			Path: pkgPath,
		}
		_, ok := typesByIdent[ident.String()]
		if !ok {
			return nil, "", fmt.Errorf("type was not found: %s", inType)
		}
	}

	return typesByIdent, pkgPath, nil
}

func (g *MockGenerator) findFuncs(
	typeSpec *dst.TypeSpec, typesByIdent map[string]*dst.TypeSpec) ([]Func, error) {
	switch typ := typeSpec.Type.(type) {
	case *dst.InterfaceType:
		return g.loadNestedInterfaces(typ, typesByIdent)
	case *dst.FuncType:
		return []Func{
			{
				Name:    typeSpec.Name.Name,
				Params:  typ.Params,
				Results: typ.Results,
			},
		}, nil
	default:
		logs.Panicf("Unknown type: %v", typeSpec.Type)
		panic("unreachable")
	}
}

func (g *MockGenerator) loadNestedInterfaces(
	iType *dst.InterfaceType,
	typesByIdent map[string]*dst.TypeSpec) ([]Func, error) {
	var funcs []Func

	for _, method := range iType.Methods.List {
		switch typ := method.Type.(type) {
		case *dst.FuncType:
			funcs = append(funcs, Func{
				Name:    method.Names[0].Name,
				Params:  typ.Params,
				Results: typ.Results,
			})
		case *dst.Ident:
			nestedType, ok := typesByIdent[typ.String()]
			if !ok {
				newTypes, _, err := g.findTypes([]string{typ.Name}, typ.Path)
				if err != nil {
					return nil, err
				}
				for k, v := range newTypes {
					typesByIdent[k] = v
				}
				nestedType = typesByIdent[typ.String()]
			}

			newFuncs, err := g.findFuncs(nestedType, typesByIdent)
			if err != nil {
				return nil, err
			}
			funcs = append(funcs, newFuncs...)
		default:
			logs.Panicf("Unknown type in interface method list: %v", method.Type)
		}
	}

	return funcs, nil
}

func (g *MockGenerator) mockStructs(typeSpec *dst.TypeSpec, funcs []Func) ([]dst.Decl, error) {
	decls := []dst.Decl{
		g.converter.BaseStruct(typeSpec, funcs),
	}

	for _, fn := range funcs {
		prefix := mockName(typeSpec.Name.Name)
		if _, ok := typeSpec.Type.(*dst.InterfaceType); ok {
			prefix = fmt.Sprintf("%s_%s", prefix, fn.Name)
		}
		decls = append(decls, g.converter.ParamResultStruct(typeSpec.Name.Name, prefix, "params", fn.Params, true))
		decls = append(decls, g.converter.ParamResultStruct(typeSpec.Name.Name, prefix, "results", fn.Results, false))
	}

	return decls, nil
}

func (g *MockGenerator) methods(typeSpec *dst.TypeSpec, pkgPath string, funcs []Func) ([]dst.Decl, error) {
	var decls []dst.Decl

	for _, fn := range funcs {
		switch typeSpec.Type.(type) {
		case *dst.InterfaceType:
			decls = append(decls, g.converter.Method(typeSpec.Name.Name, fn))
		case *dst.FuncType:
			decls = append(decls, g.converter.FuncClosure(typeSpec.Name.Name, pkgPath, fn))
		default:
			logs.Panicf("Unknown type: %v", typeSpec.Type)
		}
	}

	return decls, nil
}
