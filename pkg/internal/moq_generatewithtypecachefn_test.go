// Code generated by Moqueries - https://moqueries.org - DO NOT EDIT.

package internal_test

import (
	"fmt"

	"moqueries.org/cli/generator"
	"moqueries.org/cli/pkg/internal"
	"moqueries.org/runtime/hash"
	"moqueries.org/runtime/impl"
	"moqueries.org/runtime/moq"
)

// moqGenerateWithTypeCacheFn holds the state of a moq of the
// GenerateWithTypeCacheFn type
type moqGenerateWithTypeCacheFn struct {
	moq *impl.Moq[
		*moqGenerateWithTypeCacheFn_adaptor,
		moqGenerateWithTypeCacheFn_params,
		moqGenerateWithTypeCacheFn_paramsKey,
		moqGenerateWithTypeCacheFn_results,
	]

	runtime moqGenerateWithTypeCacheFn_runtime
}

// moqGenerateWithTypeCacheFn_runtime holds runtime configuration for the
// GenerateWithTypeCacheFn type
type moqGenerateWithTypeCacheFn_runtime struct {
	parameterIndexing moqGenerateWithTypeCacheFn_paramIndexing
}

// moqGenerateWithTypeCacheFn_adaptor adapts moqGenerateWithTypeCacheFn as
// needed by the runtime
type moqGenerateWithTypeCacheFn_adaptor struct {
	moq *moqGenerateWithTypeCacheFn
}

// moqGenerateWithTypeCacheFn_params holds the params of the
// GenerateWithTypeCacheFn type
type moqGenerateWithTypeCacheFn_params struct {
	cache generator.TypeCache
	req   generator.GenerateRequest
}

// moqGenerateWithTypeCacheFn_paramsKey holds the map key params of the
// GenerateWithTypeCacheFn type
type moqGenerateWithTypeCacheFn_paramsKey struct {
	params struct{ cache generator.TypeCache }
	hashes struct {
		cache hash.Hash
		req   hash.Hash
	}
}

// moqGenerateWithTypeCacheFn_results holds the results of the
// GenerateWithTypeCacheFn type
type moqGenerateWithTypeCacheFn_results struct {
	result1 error
}

// moqGenerateWithTypeCacheFn_paramIndexing holds the parameter indexing
// runtime configuration for the GenerateWithTypeCacheFn type
type moqGenerateWithTypeCacheFn_paramIndexing struct {
	cache moq.ParamIndexing
	req   moq.ParamIndexing
}

// moqGenerateWithTypeCacheFn_doFn defines the type of function needed when
// calling andDo for the GenerateWithTypeCacheFn type
type moqGenerateWithTypeCacheFn_doFn func(cache generator.TypeCache, req generator.GenerateRequest)

// moqGenerateWithTypeCacheFn_doReturnFn defines the type of function needed
// when calling doReturnResults for the GenerateWithTypeCacheFn type
type moqGenerateWithTypeCacheFn_doReturnFn func(cache generator.TypeCache, req generator.GenerateRequest) error

// moqGenerateWithTypeCacheFn_recorder routes recorded function calls to the
// moqGenerateWithTypeCacheFn moq
type moqGenerateWithTypeCacheFn_recorder struct {
	recorder *impl.Recorder[
		*moqGenerateWithTypeCacheFn_adaptor,
		moqGenerateWithTypeCacheFn_params,
		moqGenerateWithTypeCacheFn_paramsKey,
		moqGenerateWithTypeCacheFn_results,
	]
}

// moqGenerateWithTypeCacheFn_anyParams isolates the any params functions of
// the GenerateWithTypeCacheFn type
type moqGenerateWithTypeCacheFn_anyParams struct {
	recorder *moqGenerateWithTypeCacheFn_recorder
}

// newMoqGenerateWithTypeCacheFn creates a new moq of the
// GenerateWithTypeCacheFn type
func newMoqGenerateWithTypeCacheFn(scene *moq.Scene, config *moq.Config) *moqGenerateWithTypeCacheFn {
	adaptor1 := &moqGenerateWithTypeCacheFn_adaptor{}
	m := &moqGenerateWithTypeCacheFn{
		moq: impl.NewMoq[
			*moqGenerateWithTypeCacheFn_adaptor,
			moqGenerateWithTypeCacheFn_params,
			moqGenerateWithTypeCacheFn_paramsKey,
			moqGenerateWithTypeCacheFn_results,
		](scene, adaptor1, config),

		runtime: moqGenerateWithTypeCacheFn_runtime{parameterIndexing: moqGenerateWithTypeCacheFn_paramIndexing{
			cache: moq.ParamIndexByHash,
			req:   moq.ParamIndexByHash,
		}},
	}
	adaptor1.moq = m

	scene.AddMoq(m)
	return m
}

// mock returns the moq implementation of the GenerateWithTypeCacheFn type
func (m *moqGenerateWithTypeCacheFn) mock() internal.GenerateWithTypeCacheFn {
	return func(cache generator.TypeCache, req generator.GenerateRequest) error {
		m.moq.Scene.T.Helper()
		params := moqGenerateWithTypeCacheFn_params{
			cache: cache,
			req:   req,
		}

		var result1 error
		if result := m.moq.Function(params); result != nil {
			result1 = result.result1
		}
		return result1
	}
}

func (m *moqGenerateWithTypeCacheFn) onCall(cache generator.TypeCache, req generator.GenerateRequest) *moqGenerateWithTypeCacheFn_recorder {
	return &moqGenerateWithTypeCacheFn_recorder{
		recorder: m.moq.OnCall(moqGenerateWithTypeCacheFn_params{
			cache: cache,
			req:   req,
		}),
	}
}

func (r *moqGenerateWithTypeCacheFn_recorder) any() *moqGenerateWithTypeCacheFn_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqGenerateWithTypeCacheFn_anyParams{recorder: r}
}

func (a *moqGenerateWithTypeCacheFn_anyParams) cache() *moqGenerateWithTypeCacheFn_recorder {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (a *moqGenerateWithTypeCacheFn_anyParams) req() *moqGenerateWithTypeCacheFn_recorder {
	a.recorder.recorder.AnyParam(2)
	return a.recorder
}

func (r *moqGenerateWithTypeCacheFn_recorder) seq() *moqGenerateWithTypeCacheFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqGenerateWithTypeCacheFn_recorder) noSeq() *moqGenerateWithTypeCacheFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqGenerateWithTypeCacheFn_recorder) returnResults(result1 error) *moqGenerateWithTypeCacheFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqGenerateWithTypeCacheFn_results{
		result1: result1,
	})
	return r
}

func (r *moqGenerateWithTypeCacheFn_recorder) andDo(fn moqGenerateWithTypeCacheFn_doFn) *moqGenerateWithTypeCacheFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqGenerateWithTypeCacheFn_params) {
		fn(params.cache, params.req)
	}, false) {
		return nil
	}
	return r
}

func (r *moqGenerateWithTypeCacheFn_recorder) doReturnResults(fn moqGenerateWithTypeCacheFn_doReturnFn) *moqGenerateWithTypeCacheFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqGenerateWithTypeCacheFn_params) *moqGenerateWithTypeCacheFn_results {
		result1 := fn(params.cache, params.req)
		return &moqGenerateWithTypeCacheFn_results{
			result1: result1,
		}
	})
	return r
}

func (r *moqGenerateWithTypeCacheFn_recorder) repeat(repeaters ...moq.Repeater) *moqGenerateWithTypeCacheFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqGenerateWithTypeCacheFn_adaptor) PrettyParams(params moqGenerateWithTypeCacheFn_params) string {
	return fmt.Sprintf("GenerateWithTypeCacheFn(%#v, %#v)", params.cache, params.req)
}

func (a *moqGenerateWithTypeCacheFn_adaptor) ParamsKey(params moqGenerateWithTypeCacheFn_params, anyParams uint64) moqGenerateWithTypeCacheFn_paramsKey {
	a.moq.moq.Scene.T.Helper()
	cacheUsed, cacheUsedHash := impl.ParamKey(
		params.cache, 1, a.moq.runtime.parameterIndexing.cache, anyParams)
	reqUsedHash := impl.HashOnlyParamKey(a.moq.moq.Scene.T,
		params.req, "req", 2, a.moq.runtime.parameterIndexing.req, anyParams)
	return moqGenerateWithTypeCacheFn_paramsKey{
		params: struct{ cache generator.TypeCache }{
			cache: cacheUsed,
		},
		hashes: struct {
			cache hash.Hash
			req   hash.Hash
		}{
			cache: cacheUsedHash,
			req:   reqUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *moqGenerateWithTypeCacheFn) Reset() {
	m.moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *moqGenerateWithTypeCacheFn) AssertExpectationsMet() {
	m.moq.Scene.T.Helper()
	m.moq.AssertExpectationsMet()
}
