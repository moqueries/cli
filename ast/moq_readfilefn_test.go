// Code generated by Moqueries - https://moqueries.org - DO NOT EDIT.

package ast_test

import (
	"fmt"

	"moqueries.org/cli/ast"
	"moqueries.org/runtime/hash"
	"moqueries.org/runtime/impl"
	"moqueries.org/runtime/moq"
)

// moqReadFileFn holds the state of a moq of the ReadFileFn type
type moqReadFileFn struct {
	moq *impl.Moq[
		*moqReadFileFn_adaptor,
		moqReadFileFn_params,
		moqReadFileFn_paramsKey,
		moqReadFileFn_results,
	]

	runtime moqReadFileFn_runtime
}

// moqReadFileFn_runtime holds runtime configuration for the ReadFileFn type
type moqReadFileFn_runtime struct {
	parameterIndexing moqReadFileFn_paramIndexing
}

// moqReadFileFn_adaptor adapts moqReadFileFn as needed by the runtime
type moqReadFileFn_adaptor struct {
	moq *moqReadFileFn
}

// moqReadFileFn_params holds the params of the ReadFileFn type
type moqReadFileFn_params struct{ name string }

// moqReadFileFn_paramsKey holds the map key params of the ReadFileFn type
type moqReadFileFn_paramsKey struct {
	params struct{ name string }
	hashes struct{ name hash.Hash }
}

// moqReadFileFn_results holds the results of the ReadFileFn type
type moqReadFileFn_results struct {
	result1 []byte
	result2 error
}

// moqReadFileFn_paramIndexing holds the parameter indexing runtime
// configuration for the ReadFileFn type
type moqReadFileFn_paramIndexing struct {
	name moq.ParamIndexing
}

// moqReadFileFn_doFn defines the type of function needed when calling andDo
// for the ReadFileFn type
type moqReadFileFn_doFn func(name string)

// moqReadFileFn_doReturnFn defines the type of function needed when calling
// doReturnResults for the ReadFileFn type
type moqReadFileFn_doReturnFn func(name string) ([]byte, error)

// moqReadFileFn_recorder routes recorded function calls to the moqReadFileFn
// moq
type moqReadFileFn_recorder struct {
	recorder *impl.Recorder[
		*moqReadFileFn_adaptor,
		moqReadFileFn_params,
		moqReadFileFn_paramsKey,
		moqReadFileFn_results,
	]
}

// moqReadFileFn_anyParams isolates the any params functions of the ReadFileFn
// type
type moqReadFileFn_anyParams struct {
	recorder *moqReadFileFn_recorder
}

// newMoqReadFileFn creates a new moq of the ReadFileFn type
func newMoqReadFileFn(scene *moq.Scene, config *moq.Config) *moqReadFileFn {
	adaptor1 := &moqReadFileFn_adaptor{}
	m := &moqReadFileFn{
		moq: impl.NewMoq[
			*moqReadFileFn_adaptor,
			moqReadFileFn_params,
			moqReadFileFn_paramsKey,
			moqReadFileFn_results,
		](scene, adaptor1, config),

		runtime: moqReadFileFn_runtime{parameterIndexing: moqReadFileFn_paramIndexing{
			name: moq.ParamIndexByValue,
		}},
	}
	adaptor1.moq = m

	scene.AddMoq(m)
	return m
}

// mock returns the moq implementation of the ReadFileFn type
func (m *moqReadFileFn) mock() ast.ReadFileFn {
	return func(name string) ([]byte, error) {
		m.moq.Scene.T.Helper()
		params := moqReadFileFn_params{
			name: name,
		}

		var result1 []byte
		var result2 error
		if result := m.moq.Function(params); result != nil {
			result1 = result.result1
			result2 = result.result2
		}
		return result1, result2
	}
}

func (m *moqReadFileFn) onCall(name string) *moqReadFileFn_recorder {
	return &moqReadFileFn_recorder{
		recorder: m.moq.OnCall(moqReadFileFn_params{
			name: name,
		}),
	}
}

func (r *moqReadFileFn_recorder) any() *moqReadFileFn_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqReadFileFn_anyParams{recorder: r}
}

func (a *moqReadFileFn_anyParams) name() *moqReadFileFn_recorder {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (r *moqReadFileFn_recorder) seq() *moqReadFileFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqReadFileFn_recorder) noSeq() *moqReadFileFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqReadFileFn_recorder) returnResults(result1 []byte, result2 error) *moqReadFileFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqReadFileFn_results{
		result1: result1,
		result2: result2,
	})
	return r
}

func (r *moqReadFileFn_recorder) andDo(fn moqReadFileFn_doFn) *moqReadFileFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqReadFileFn_params) {
		fn(params.name)
	}, false) {
		return nil
	}
	return r
}

func (r *moqReadFileFn_recorder) doReturnResults(fn moqReadFileFn_doReturnFn) *moqReadFileFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqReadFileFn_params) *moqReadFileFn_results {
		result1, result2 := fn(params.name)
		return &moqReadFileFn_results{
			result1: result1,
			result2: result2,
		}
	})
	return r
}

func (r *moqReadFileFn_recorder) repeat(repeaters ...moq.Repeater) *moqReadFileFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqReadFileFn_adaptor) PrettyParams(params moqReadFileFn_params) string {
	return fmt.Sprintf("ReadFileFn(%#v)", params.name)
}

func (a *moqReadFileFn_adaptor) ParamsKey(params moqReadFileFn_params, anyParams uint64) moqReadFileFn_paramsKey {
	a.moq.moq.Scene.T.Helper()
	nameUsed, nameUsedHash := impl.ParamKey(
		params.name, 1, a.moq.runtime.parameterIndexing.name, anyParams)
	return moqReadFileFn_paramsKey{
		params: struct{ name string }{
			name: nameUsed,
		},
		hashes: struct{ name hash.Hash }{
			name: nameUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *moqReadFileFn) Reset() {
	m.moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *moqReadFileFn) AssertExpectationsMet() {
	m.moq.Scene.T.Helper()
	m.moq.AssertExpectationsMet()
}
