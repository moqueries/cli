// Code generated by Moqueries - https://moqueries.org - DO NOT EDIT.

package ast_test

import (
	"fmt"

	"golang.org/x/tools/go/packages"
	"moqueries.org/cli/ast"
	"moqueries.org/runtime/hash"
	"moqueries.org/runtime/impl"
	"moqueries.org/runtime/moq"
)

// moqLoadFn holds the state of a moq of the LoadFn type
type moqLoadFn struct {
	moq *impl.Moq[
		*moqLoadFn_adaptor,
		moqLoadFn_params,
		moqLoadFn_paramsKey,
		moqLoadFn_results,
	]

	runtime moqLoadFn_runtime
}

// moqLoadFn_runtime holds runtime configuration for the LoadFn type
type moqLoadFn_runtime struct {
	parameterIndexing moqLoadFn_paramIndexing
}

// moqLoadFn_adaptor adapts moqLoadFn as needed by the runtime
type moqLoadFn_adaptor struct {
	moq *moqLoadFn
}

// moqLoadFn_params holds the params of the LoadFn type
type moqLoadFn_params struct {
	cfg      *packages.Config
	patterns []string
}

// moqLoadFn_paramsKey holds the map key params of the LoadFn type
type moqLoadFn_paramsKey struct {
	params struct{ cfg *packages.Config }
	hashes struct {
		cfg      hash.Hash
		patterns hash.Hash
	}
}

// moqLoadFn_results holds the results of the LoadFn type
type moqLoadFn_results struct {
	result1 []*packages.Package
	result2 error
}

// moqLoadFn_paramIndexing holds the parameter indexing runtime configuration
// for the LoadFn type
type moqLoadFn_paramIndexing struct {
	cfg      moq.ParamIndexing
	patterns moq.ParamIndexing
}

// moqLoadFn_doFn defines the type of function needed when calling andDo for
// the LoadFn type
type moqLoadFn_doFn func(cfg *packages.Config, patterns ...string)

// moqLoadFn_doReturnFn defines the type of function needed when calling
// doReturnResults for the LoadFn type
type moqLoadFn_doReturnFn func(cfg *packages.Config, patterns ...string) ([]*packages.Package, error)

// moqLoadFn_recorder routes recorded function calls to the moqLoadFn moq
type moqLoadFn_recorder struct {
	recorder *impl.Recorder[
		*moqLoadFn_adaptor,
		moqLoadFn_params,
		moqLoadFn_paramsKey,
		moqLoadFn_results,
	]
}

// moqLoadFn_anyParams isolates the any params functions of the LoadFn type
type moqLoadFn_anyParams struct {
	recorder *moqLoadFn_recorder
}

// newMoqLoadFn creates a new moq of the LoadFn type
func newMoqLoadFn(scene *moq.Scene, config *moq.Config) *moqLoadFn {
	adaptor1 := &moqLoadFn_adaptor{}
	m := &moqLoadFn{
		moq: impl.NewMoq[
			*moqLoadFn_adaptor,
			moqLoadFn_params,
			moqLoadFn_paramsKey,
			moqLoadFn_results,
		](scene, adaptor1, config),

		runtime: moqLoadFn_runtime{parameterIndexing: moqLoadFn_paramIndexing{
			cfg:      moq.ParamIndexByHash,
			patterns: moq.ParamIndexByHash,
		}},
	}
	adaptor1.moq = m

	scene.AddMoq(m)
	return m
}

// mock returns the moq implementation of the LoadFn type
func (m *moqLoadFn) mock() ast.LoadFn {
	return func(cfg *packages.Config, patterns ...string) ([]*packages.Package, error) {
		m.moq.Scene.T.Helper()
		params := moqLoadFn_params{
			cfg:      cfg,
			patterns: patterns,
		}

		var result1 []*packages.Package
		var result2 error
		if result := m.moq.Function(params); result != nil {
			result1 = result.result1
			result2 = result.result2
		}
		return result1, result2
	}
}

func (m *moqLoadFn) onCall(cfg *packages.Config, patterns ...string) *moqLoadFn_recorder {
	return &moqLoadFn_recorder{
		recorder: m.moq.OnCall(moqLoadFn_params{
			cfg:      cfg,
			patterns: patterns,
		}),
	}
}

func (r *moqLoadFn_recorder) any() *moqLoadFn_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqLoadFn_anyParams{recorder: r}
}

func (a *moqLoadFn_anyParams) cfg() *moqLoadFn_recorder {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (a *moqLoadFn_anyParams) patterns() *moqLoadFn_recorder {
	a.recorder.recorder.AnyParam(2)
	return a.recorder
}

func (r *moqLoadFn_recorder) seq() *moqLoadFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqLoadFn_recorder) noSeq() *moqLoadFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqLoadFn_recorder) returnResults(result1 []*packages.Package, result2 error) *moqLoadFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqLoadFn_results{
		result1: result1,
		result2: result2,
	})
	return r
}

func (r *moqLoadFn_recorder) andDo(fn moqLoadFn_doFn) *moqLoadFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqLoadFn_params) {
		fn(params.cfg, params.patterns...)
	}, false) {
		return nil
	}
	return r
}

func (r *moqLoadFn_recorder) doReturnResults(fn moqLoadFn_doReturnFn) *moqLoadFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqLoadFn_params) *moqLoadFn_results {
		result1, result2 := fn(params.cfg, params.patterns...)
		return &moqLoadFn_results{
			result1: result1,
			result2: result2,
		}
	})
	return r
}

func (r *moqLoadFn_recorder) repeat(repeaters ...moq.Repeater) *moqLoadFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqLoadFn_adaptor) PrettyParams(params moqLoadFn_params) string {
	return fmt.Sprintf("LoadFn(%#v, %#v)", params.cfg, params.patterns)
}

func (a *moqLoadFn_adaptor) ParamsKey(params moqLoadFn_params, anyParams uint64) moqLoadFn_paramsKey {
	a.moq.moq.Scene.T.Helper()
	cfgUsed, cfgUsedHash := impl.ParamKey(
		params.cfg, 1, a.moq.runtime.parameterIndexing.cfg, anyParams)
	patternsUsedHash := impl.HashOnlyParamKey(a.moq.moq.Scene.T,
		params.patterns, "patterns", 2, a.moq.runtime.parameterIndexing.patterns, anyParams)
	return moqLoadFn_paramsKey{
		params: struct{ cfg *packages.Config }{
			cfg: cfgUsed,
		},
		hashes: struct {
			cfg      hash.Hash
			patterns hash.Hash
		}{
			cfg:      cfgUsedHash,
			patterns: patternsUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *moqLoadFn) Reset() {
	m.moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *moqLoadFn) AssertExpectationsMet() {
	m.moq.Scene.T.Helper()
	m.moq.AssertExpectationsMet()
}
