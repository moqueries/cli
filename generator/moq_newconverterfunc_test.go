// Code generated by Moqueries - https://moqueries.org - DO NOT EDIT.

package generator_test

import (
	"fmt"

	"moqueries.org/cli/generator"
	"moqueries.org/runtime/hash"
	"moqueries.org/runtime/impl"
	"moqueries.org/runtime/moq"
)

// moqNewConverterFunc holds the state of a moq of the NewConverterFunc type
type moqNewConverterFunc struct {
	moq *impl.Moq[
		*moqNewConverterFunc_adaptor,
		moqNewConverterFunc_params,
		moqNewConverterFunc_paramsKey,
		moqNewConverterFunc_results,
	]

	runtime moqNewConverterFunc_runtime
}

// moqNewConverterFunc_runtime holds runtime configuration for the
// NewConverterFunc type
type moqNewConverterFunc_runtime struct {
	parameterIndexing moqNewConverterFunc_paramIndexing
}

// moqNewConverterFunc_adaptor adapts moqNewConverterFunc as needed by the
// runtime
type moqNewConverterFunc_adaptor struct {
	moq *moqNewConverterFunc
}

// moqNewConverterFunc_params holds the params of the NewConverterFunc type
type moqNewConverterFunc_params struct {
	typ    generator.Type
	export bool
}

// moqNewConverterFunc_paramsKey holds the map key params of the
// NewConverterFunc type
type moqNewConverterFunc_paramsKey struct {
	params struct{ export bool }
	hashes struct {
		typ    hash.Hash
		export hash.Hash
	}
}

// moqNewConverterFunc_results holds the results of the NewConverterFunc type
type moqNewConverterFunc_results struct {
	result1 generator.Converterer
}

// moqNewConverterFunc_paramIndexing holds the parameter indexing runtime
// configuration for the NewConverterFunc type
type moqNewConverterFunc_paramIndexing struct {
	typ    moq.ParamIndexing
	export moq.ParamIndexing
}

// moqNewConverterFunc_doFn defines the type of function needed when calling
// andDo for the NewConverterFunc type
type moqNewConverterFunc_doFn func(typ generator.Type, export bool)

// moqNewConverterFunc_doReturnFn defines the type of function needed when
// calling doReturnResults for the NewConverterFunc type
type moqNewConverterFunc_doReturnFn func(typ generator.Type, export bool) generator.Converterer

// moqNewConverterFunc_recorder routes recorded function calls to the
// moqNewConverterFunc moq
type moqNewConverterFunc_recorder struct {
	recorder *impl.Recorder[
		*moqNewConverterFunc_adaptor,
		moqNewConverterFunc_params,
		moqNewConverterFunc_paramsKey,
		moqNewConverterFunc_results,
	]
}

// moqNewConverterFunc_anyParams isolates the any params functions of the
// NewConverterFunc type
type moqNewConverterFunc_anyParams struct {
	recorder *moqNewConverterFunc_recorder
}

// newMoqNewConverterFunc creates a new moq of the NewConverterFunc type
func newMoqNewConverterFunc(scene *moq.Scene, config *moq.Config) *moqNewConverterFunc {
	adaptor1 := &moqNewConverterFunc_adaptor{}
	m := &moqNewConverterFunc{
		moq: impl.NewMoq[
			*moqNewConverterFunc_adaptor,
			moqNewConverterFunc_params,
			moqNewConverterFunc_paramsKey,
			moqNewConverterFunc_results,
		](scene, adaptor1, config),

		runtime: moqNewConverterFunc_runtime{parameterIndexing: moqNewConverterFunc_paramIndexing{
			typ:    moq.ParamIndexByHash,
			export: moq.ParamIndexByValue,
		}},
	}
	adaptor1.moq = m

	scene.AddMoq(m)
	return m
}

// mock returns the moq implementation of the NewConverterFunc type
func (m *moqNewConverterFunc) mock() generator.NewConverterFunc {
	return func(typ generator.Type, export bool) generator.Converterer {
		m.moq.Scene.T.Helper()
		params := moqNewConverterFunc_params{
			typ:    typ,
			export: export,
		}

		var result1 generator.Converterer
		if result := m.moq.Function(params); result != nil {
			result1 = result.result1
		}
		return result1
	}
}

func (m *moqNewConverterFunc) onCall(typ generator.Type, export bool) *moqNewConverterFunc_recorder {
	return &moqNewConverterFunc_recorder{
		recorder: m.moq.OnCall(moqNewConverterFunc_params{
			typ:    typ,
			export: export,
		}),
	}
}

func (r *moqNewConverterFunc_recorder) any() *moqNewConverterFunc_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqNewConverterFunc_anyParams{recorder: r}
}

func (a *moqNewConverterFunc_anyParams) typ() *moqNewConverterFunc_recorder {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (a *moqNewConverterFunc_anyParams) export() *moqNewConverterFunc_recorder {
	a.recorder.recorder.AnyParam(2)
	return a.recorder
}

func (r *moqNewConverterFunc_recorder) seq() *moqNewConverterFunc_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqNewConverterFunc_recorder) noSeq() *moqNewConverterFunc_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqNewConverterFunc_recorder) returnResults(result1 generator.Converterer) *moqNewConverterFunc_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqNewConverterFunc_results{
		result1: result1,
	})
	return r
}

func (r *moqNewConverterFunc_recorder) andDo(fn moqNewConverterFunc_doFn) *moqNewConverterFunc_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqNewConverterFunc_params) {
		fn(params.typ, params.export)
	}, false) {
		return nil
	}
	return r
}

func (r *moqNewConverterFunc_recorder) doReturnResults(fn moqNewConverterFunc_doReturnFn) *moqNewConverterFunc_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqNewConverterFunc_params) *moqNewConverterFunc_results {
		result1 := fn(params.typ, params.export)
		return &moqNewConverterFunc_results{
			result1: result1,
		}
	})
	return r
}

func (r *moqNewConverterFunc_recorder) repeat(repeaters ...moq.Repeater) *moqNewConverterFunc_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqNewConverterFunc_adaptor) PrettyParams(params moqNewConverterFunc_params) string {
	return fmt.Sprintf("NewConverterFunc(%#v, %#v)", params.typ, params.export)
}

func (a *moqNewConverterFunc_adaptor) ParamsKey(params moqNewConverterFunc_params, anyParams uint64) moqNewConverterFunc_paramsKey {
	a.moq.moq.Scene.T.Helper()
	typUsedHash := impl.HashOnlyParamKey(a.moq.moq.Scene.T,
		params.typ, "typ", 1, a.moq.runtime.parameterIndexing.typ, anyParams)
	exportUsed, exportUsedHash := impl.ParamKey(
		params.export, 2, a.moq.runtime.parameterIndexing.export, anyParams)
	return moqNewConverterFunc_paramsKey{
		params: struct{ export bool }{
			export: exportUsed,
		},
		hashes: struct {
			typ    hash.Hash
			export hash.Hash
		}{
			typ:    typUsedHash,
			export: exportUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *moqNewConverterFunc) Reset() {
	m.moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *moqNewConverterFunc) AssertExpectationsMet() {
	m.moq.Scene.T.Helper()
	m.moq.AssertExpectationsMet()
}
