package generator_test

import (
	"errors"
	"fmt"
	"testing"

	"github.com/dave/dst"
	"moqueries.org/runtime/moq"

	"moqueries.org/cli/ast"
	"moqueries.org/cli/generator"
)

func TestMoqGenerator(t *testing.T) {
	const genPkg = "moqueries.org/cli/generator"
	var (
		scene             *moq.Scene
		typeCacheMoq      *moqTypeCache
		getwdFnMoq        *moqGetwdFunc
		newConverterFnMoq *moqNewConverterFunc
		converter1Moq     *moqConverterer
		converter2Moq     *moqConverterer

		gen *generator.MoqGenerator

		ifaceInfo1    ast.TypeInfo
		ifaceInfo2    ast.TypeInfo
		ifaceMethods1 *dst.FieldList
		ifaceMethods2 *dst.FieldList
		func1         *dst.Field
		func1Params   *dst.FieldList
		func1Results  *dst.FieldList

		readFnType *dst.FuncType
		readerInfo ast.TypeInfo

		fnInfo ast.TypeInfo
	)

	beforeEach := func(t *testing.T) {
		t.Helper()

		if scene != nil {
			t.Fatal("afterEach not called")
		}
		scene = moq.NewScene(t)
		typeCacheMoq = newMoqTypeCache(scene, nil)
		getwdFnMoq = newMoqGetwdFunc(scene, nil)
		newConverterFnMoq = newMoqNewConverterFunc(scene, nil)
		converter1Moq = newMoqConverterer(scene, nil)
		converter2Moq = newMoqConverterer(scene, nil)

		gen = generator.New(
			typeCacheMoq.mock(),
			getwdFnMoq.mock(),
			newConverterFnMoq.mock())

		func1Params = &dst.FieldList{List: []*dst.Field{
			{
				Names: []*dst.Ident{dst.NewIdent("firstParm")},
				Type:  &dst.Ident{Name: "Command", Path: "cobra"},
			},
			{Type: dst.NewIdent("string")},
			{
				Type: &dst.Ident{Name: "InterfaceType", Path: "dst"},
			},
		}}
		func1Results = &dst.FieldList{List: []*dst.Field{
			{Type: dst.NewIdent("error")},
		}}
		func1 = &dst.Field{
			Names: []*dst.Ident{dst.NewIdent("Func1")},
			Type:  &dst.FuncType{Params: func1Params, Results: nil},
		}
		ifaceMethods1 = &dst.FieldList{List: []*dst.Field{func1}}
		ifaceInfo1 = ast.TypeInfo{
			Type: &dst.TypeSpec{
				Name: ast.IdPath("PublicInterface", genPkg),
				Type: &dst.InterfaceType{Methods: ifaceMethods1},
			},
			PkgPath:  genPkg,
			Exported: true,
		}
		ifaceMethods2 = &dst.FieldList{}
		ifaceInfo2 = ast.TypeInfo{
			Type: &dst.TypeSpec{
				Name: dst.NewIdent("privateInterface"),
				Type: &dst.InterfaceType{Methods: ifaceMethods2},
			},
			PkgPath:  genPkg,
			Exported: false,
		}

		readFnType = &dst.FuncType{
			Params: &dst.FieldList{List: []*dst.Field{{
				Names: []*dst.Ident{dst.NewIdent("p")},
				Type:  &dst.ArrayType{Elt: dst.NewIdent("byte")},
			}}},
			Results: &dst.FieldList{List: []*dst.Field{
				{
					Names: []*dst.Ident{dst.NewIdent("n")},
					Type:  dst.NewIdent("int"),
				},
				{
					Names: []*dst.Ident{dst.NewIdent("err")},
					Type:  dst.NewIdent("error"),
				},
			}},
		}
		readerInfo = ast.TypeInfo{
			Type: &dst.TypeSpec{
				Name: &dst.Ident{Name: "Reader", Path: "io"},
				Type: &dst.InterfaceType{Methods: &dst.FieldList{
					List: []*dst.Field{{
						Names: []*dst.Ident{dst.NewIdent("Read")},
						Type:  readFnType,
					}},
				}},
			},
			PkgPath:  "io",
			Exported: true,
		}

		fnInfo = ast.TypeInfo{
			Type: &dst.TypeSpec{
				Name: dst.NewIdent("PublicFn"),
				Type: &dst.FuncType{Params: func1Params, Results: nil},
			},
			PkgPath:  genPkg,
			Exported: true,
		}
	}

	afterEach := func(t *testing.T) {
		t.Helper()
		scene.AssertExpectationsMet()
		scene = nil
	}

	t.Run("always returns a header comment", func(t *testing.T) {
		// ASSEMBLE
		beforeEach(t)
		defer afterEach(t)
		req := generator.GenerateRequest{
			Types:       nil,
			Export:      false,
			Destination: "dir/file_test.go",
			Package:     "",
			Import:      ".",
			TestImport:  false,
			WorkingDir:  "/some-nice-path",
		}

		typeCacheMoq.onCall().FindPackage("dir").returnResults("myrepo.com/dir", nil)
		getwdFnMoq.onCall().returnResults("/some-nice-path", nil)

		// ACT
		resp, err := gen.Generate(req)
		// ASSERT
		if err != nil {
			t.Errorf("got %#v, wanted nil err", err)
		}
		if resp.File == nil {
			t.Fatalf("got nil file, wanted not nil")
		}
		if len(resp.File.Decs.Start) < 1 {
			t.Errorf("got %d, wanted > 0 len start", len(resp.File.Decs.Start))
		}
		expectedStart := "// Code generated by Moqueries - https://moqueries.org - DO NOT EDIT!"
		if resp.File.Decs.Start[0] != expectedStart {
			t.Errorf("got %s, wanted %s", resp.File.Decs.Start[0], expectedStart)
		}
		if resp.DestPath != "dir/file_test.go" {
			t.Errorf("got %s, wanted dir/file_test.go", resp.DestPath)
		}
		if resp.OutPkgPath != "myrepo.com/dir_test" {
			t.Errorf("got %s, wanted myrepo.com/dir_test", resp.OutPkgPath)
		}
	})

	t.Run("can put mocks in parent packages when given a relative destination", func(t *testing.T) {
		// ASSEMBLE
		beforeEach(t)
		defer afterEach(t)
		req := generator.GenerateRequest{
			Types:       nil,
			Export:      true,
			Destination: "../file_test.go",
			Package:     "",
			Import:      ".",
			TestImport:  false,
			WorkingDir:  "/some-nice-path",
		}

		typeCacheMoq.onCall().FindPackage("..").returnResults("myrepo.com/otherpkg", nil)
		getwdFnMoq.onCall().returnResults("/some-nice-path", nil)

		// ACT
		resp, err := gen.Generate(req)
		// ASSERT
		if err != nil {
			t.Errorf("got %#v, wanted nil err", err)
		}
		if resp.File.Name.Name != "otherpkg" {
			t.Errorf("got %s, wanted otherpkg", resp.File.Name.Name)
		}
		if resp.DestPath != "../file_test.go" {
			t.Errorf("got %s, wanted ../file_test.go", resp.DestPath)
		}
		if resp.OutPkgPath != "myrepo.com/otherpkg" {
			t.Errorf("got %s, wanted myrepo.com/otherpkg", resp.OutPkgPath)
		}
	})

	t.Run("package naming based on current directory and export flag", func(t *testing.T) {
		for name, tc := range map[string]struct {
			export bool
			pkg    string
		}{
			"test package when not exported": {export: false, pkg: "thispkg_test"},
			"non-test package when exported": {export: true, pkg: "thispkg"},
		} {
			t.Run(name, func(t *testing.T) {
				// ASSEMBLE
				beforeEach(t)
				defer afterEach(t)
				req := generator.GenerateRequest{
					Types:       nil,
					Export:      tc.export,
					Destination: "file_test.go",
					Package:     "",
					Import:      ".",
					TestImport:  false,
					WorkingDir:  "/some-nice-path",
				}

				typeCacheMoq.onCall().FindPackage(".").returnResults("myrepo.com/thispkg", nil)
				getwdFnMoq.onCall().returnResults("/some-nice-path", nil)

				// ACT
				resp, err := gen.Generate(req)
				// ASSERT
				if err != nil {
					t.Errorf("got %#v, wanted nil err", err)
				}
				if resp.File.Name.Name != tc.pkg {
					t.Errorf("got %s, wanted %s", resp.File.Name.Name, tc.pkg)
				}
				if resp.DestPath != "file_test.go" {
					t.Errorf("got %s, wanted file_test.go", resp.DestPath)
				}
				outPkgPath := "myrepo.com/" + tc.pkg
				if resp.OutPkgPath != outPkgPath {
					t.Errorf("got %s, wanted %s", resp.OutPkgPath, outPkgPath)
				}
			})
		}
	})

	t.Run("recursively looks up nested interfaces", func(t *testing.T) {
		types := []string{"PublicInterface", "privateInterface"}
		for name, tc := range map[string]struct {
			request    generator.GenerateRequest
			findPkgDir string
			findPkgOut string
			outPkgPath string
			getwdDir   string
			typePath   string
			destPath   string
		}{
			"current working dir same as req working dir": {
				request: generator.GenerateRequest{
					Types:       types,
					Export:      false,
					Destination: "file_test.go",
					Package:     "",
					Import:      ".",
					TestImport:  false,
					WorkingDir:  "/some-nice-path",
				},
				findPkgDir: ".",
				findPkgOut: "thispkg",
				outPkgPath: "thispkg_test",
				getwdDir:   "/some-nice-path",
				typePath:   ".",
				destPath:   "file_test.go",
			},
			"gives a sane path when destination is an absolute path": {
				request: generator.GenerateRequest{
					Types:       types,
					Export:      false,
					Destination: "/exactly-here/file_test.go",
					Package:     "",
					Import:      ".",
					TestImport:  false,
					WorkingDir:  "/some-nice-path",
				},
				findPkgDir: "/exactly-here",
				findPkgOut: "thispkg",
				outPkgPath: "thispkg_test",
				getwdDir:   "/some-nice-path",
				typePath:   ".",
				destPath:   "/exactly-here/file_test.go",
			},
			"gives a sane path when destination dir is an absolute path": {
				request: generator.GenerateRequest{
					Types:          types,
					Export:         false,
					DestinationDir: "/exactly-here",
					Package:        "",
					Import:         ".",
					TestImport:     false,
					WorkingDir:     "/some-nice-path",
				},
				findPkgDir: "/exactly-here",
				findPkgOut: "thispkg",
				outPkgPath: "thispkg_test",
				getwdDir:   "/some-nice-path",
				typePath:   ".",
				destPath:   "/exactly-here/moq_publicinterface_privateinterface_test.go",
			},
			"req working dir not set": {
				request: generator.GenerateRequest{
					Types:       types,
					Export:      false,
					Destination: "file_test.go",
					Package:     "",
					Import:      ".",
					TestImport:  false,
				},
				findPkgDir: ".",
				findPkgOut: "thispkg",
				outPkgPath: "thispkg_test",
				getwdDir:   "/some-nice-path",
				typePath:   ".",
				destPath:   "file_test.go",
			},
			"current working dir parent of req working dir": {
				request: generator.GenerateRequest{
					Types:       types,
					Export:      false,
					Destination: "file_test.go",
					Package:     "",
					Import:      ".",
					TestImport:  false,
					WorkingDir:  "/some-nice-path/some-child-dir",
				},
				findPkgDir: "some-child-dir",
				findPkgOut: "thispkg",
				outPkgPath: "thispkg_test",
				getwdDir:   "/some-nice-path",
				typePath:   "./some-child-dir",
				destPath:   "some-child-dir/file_test.go",
			},
			"specific absolute import": {
				request: generator.GenerateRequest{
					Types:       types,
					Export:      false,
					Destination: "file_test.go",
					Package:     "",
					Import:      "io",
					TestImport:  false,
					WorkingDir:  "/some-nice-path",
				},
				findPkgDir: ".",
				findPkgOut: "thispkg",
				outPkgPath: "thispkg_test",
				getwdDir:   "/some-nice-path",
				typePath:   "io",
				destPath:   "file_test.go",
			},
			"specific relative import": {
				request: generator.GenerateRequest{
					Types:       types,
					Export:      false,
					Destination: "file_test.go",
					Package:     "",
					Import:      "./somechilddir",
					TestImport:  false,
					WorkingDir:  "/some-nice-path",
				},
				findPkgDir: ".",
				findPkgOut: "thispkg",
				outPkgPath: "thispkg_test",
				getwdDir:   "/some-nice-path",
				typePath:   "./somechilddir",
				destPath:   "file_test.go",
			},
			"current working dir parent of req working dir w/ relative import": {
				request: generator.GenerateRequest{
					Types:       types,
					Export:      false,
					Destination: "file_test.go",
					Package:     "",
					Import:      "./secondchilddir",
					TestImport:  false,
					WorkingDir:  "/some-nice-path/firstchilddir",
				},
				findPkgDir: "firstchilddir",
				findPkgOut: "thispkg",
				outPkgPath: "thispkg_test",
				getwdDir:   "/some-nice-path",
				typePath:   "./firstchilddir/secondchilddir",
				destPath:   "firstchilddir/file_test.go",
			},
			"warns (?!) when trying to export a test file": {
				request: generator.GenerateRequest{
					Types:       types,
					Export:      true,
					Destination: "file_test.go",
					Package:     "",
					Import:      ".",
					TestImport:  false,
					WorkingDir:  "/some-nice-path",
				},
				findPkgDir: ".",
				findPkgOut: "thispkg",
				outPkgPath: "thispkg",
				getwdDir:   "/some-nice-path",
				typePath:   ".",
				destPath:   "file_test.go",
			},
			"generated filename for a test package": {
				request: generator.GenerateRequest{
					Types:          types,
					Export:         false,
					DestinationDir: "subpkg",
					Package:        "",
					Import:         ".",
					TestImport:     false,
					WorkingDir:     "/some-nice-path",
				},
				findPkgDir: "subpkg",
				findPkgOut: "thispkg",
				outPkgPath: "thispkg_test",
				getwdDir:   "/some-nice-path",
				typePath:   ".",
				destPath:   "subpkg/moq_publicinterface_privateinterface_test.go",
			},
			"generated filename for an exported package": {
				request: generator.GenerateRequest{
					Types:          types,
					Export:         true,
					DestinationDir: "subpkg",
					Package:        "",
					Import:         ".",
					TestImport:     false,
					WorkingDir:     "/some-nice-path",
				},
				findPkgDir: "subpkg",
				findPkgOut: "thispkg",
				outPkgPath: "thispkg",
				getwdDir:   "/some-nice-path",
				typePath:   ".",
				destPath:   "subpkg/moq_publicinterface_privateinterface.go",
			},
			"generated filename w/ a relative path": {
				request: generator.GenerateRequest{
					Types:          types,
					Export:         true,
					DestinationDir: "destpkg3",
					Package:        "subpkg2",
					Import:         ".",
					TestImport:     false,
					WorkingDir:     "/some-nice-path/subdir1",
				},
				findPkgDir: "subdir1/destpkg3",
				findPkgOut: "thispkg",
				outPkgPath: "subpkg2",
				getwdDir:   "/some-nice-path",
				typePath:   "./subdir1",
				destPath:   "subdir1/destpkg3/moq_publicinterface_privateinterface.go",
			},
		} {
			t.Run(name, func(t *testing.T) {
				// ASSEMBLE
				beforeEach(t)
				defer afterEach(t)

				typeCacheMoq.onCall().FindPackage(tc.findPkgDir).
					returnResults(tc.findPkgOut, nil)
				getwdFnMoq.onCall().returnResults(tc.getwdDir, nil)

				// PublicInterface embeds privateInterface which embeds io.Reader
				ifaceMethods1.List = append(ifaceMethods1.List, &dst.Field{
					Type: &dst.Ident{
						Name: "privateInterface",
						Path: genPkg,
					},
				})
				ifaceMethods2.List = append(ifaceMethods2.List, &dst.Field{
					Type: &dst.Ident{
						Name: "Reader",
						Path: "io",
					},
				})
				typeCacheMoq.onCall().Type(*ast.IdPath("PublicInterface", tc.typePath), tc.typePath, false).
					returnResults(ifaceInfo1, nil)
				typeCacheMoq.onCall().Type(
					*ast.IdPath("privateInterface", genPkg), genPkg, false).
					returnResults(ifaceInfo2, nil)
				typeCacheMoq.onCall().Type(*ast.IdPath("Reader", "io"), "", false).
					returnResults(readerInfo, nil)
				typeCacheMoq.onCall().Type(*ast.IdPath("privateInterface", tc.typePath), tc.typePath, false).
					returnResults(ifaceInfo2, nil)
				typeCacheMoq.onCall().Type(*ast.IdPath("Reader", "io"), "", false).
					returnResults(readerInfo, nil)
				ifaceFuncs := []generator.Func{
					{Name: "Func1", FuncType: &dst.FuncType{Params: func1Params}},
					{
						Name: "Read",
						FuncType: &dst.FuncType{
							Params:  readFnType.Params,
							Results: readFnType.Results,
						},
					},
				}
				newConverterFnMoq.onCall(generator.Type{
					TypeInfo: ast.TypeInfo{
						Type:     ifaceInfo1.Type,
						PkgPath:  genPkg,
						Exported: true,
					},
					Funcs:      ifaceFuncs,
					OutPkgPath: tc.outPkgPath,
				}, tc.request.Export).returnResults(converter1Moq.mock())
				converter1Moq.onCall().BaseDecls().returnResults([]dst.Decl{&dst.GenDecl{
					Specs: []dst.Spec{&dst.TypeSpec{Name: dst.NewIdent("pub-decl")}},
				}}, nil)
				converter1Moq.onCall().IsolationStruct("mock").
					returnResults(nil, nil)
				converter1Moq.onCall().IsolationStruct("recorder").
					returnResults(nil, nil)
				converter1Moq.onCall().MethodStructs(ifaceFuncs[0]).
					returnResults(nil, nil)
				converter1Moq.onCall().MethodStructs(ifaceFuncs[1]).
					returnResults(nil, nil)
				converter1Moq.onCall().NewFunc().
					returnResults(nil, nil)
				converter1Moq.onCall().IsolationAccessor("mock", "mock").
					returnResults(nil, nil)
				converter1Moq.onCall().MockMethod(ifaceFuncs[0]).
					returnResults(nil, nil)
				converter1Moq.onCall().MockMethod(ifaceFuncs[1]).
					returnResults(nil, nil)
				converter1Moq.onCall().IsolationAccessor("recorder", "onCall").
					returnResults(nil, nil)
				converter1Moq.onCall().RecorderMethods(ifaceFuncs[0]).
					returnResults(nil, nil)
				converter1Moq.onCall().RecorderMethods(ifaceFuncs[1]).
					returnResults(nil, nil)
				converter1Moq.onCall().ResetMethod().
					returnResults(nil, nil)
				converter1Moq.onCall().AssertMethod().
					returnResults(nil, nil)
				iface2Funcs := []generator.Func{{
					Name: "Read",
					FuncType: &dst.FuncType{
						Params:  readFnType.Params,
						Results: readFnType.Results,
					},
				}}
				newConverterFnMoq.onCall(generator.Type{
					TypeInfo: ast.TypeInfo{
						Type:    ifaceInfo2.Type,
						PkgPath: genPkg,
					},
					Funcs:      iface2Funcs,
					OutPkgPath: tc.outPkgPath,
				}, tc.request.Export).returnResults(converter2Moq.mock())
				converter2Moq.onCall().BaseDecls().returnResults(nil, nil)
				converter2Moq.onCall().IsolationStruct("mock").
					returnResults(nil, nil)
				converter2Moq.onCall().IsolationStruct("recorder").
					returnResults(nil, nil)
				converter2Moq.onCall().MethodStructs(iface2Funcs[0]).
					returnResults(nil, nil)
				converter2Moq.onCall().NewFunc().
					returnResults(nil, nil)
				converter2Moq.onCall().IsolationAccessor("mock", "mock").
					returnResults(nil, nil)
				converter2Moq.onCall().MockMethod(iface2Funcs[0]).
					returnResults(nil, nil)
				converter2Moq.onCall().IsolationAccessor("recorder", "onCall").
					returnResults(nil, nil)
				converter2Moq.onCall().RecorderMethods(iface2Funcs[0]).
					returnResults(nil, nil)
				converter2Moq.onCall().ResetMethod().
					returnResults(nil, nil)
				converter2Moq.onCall().AssertMethod().
					returnResults(nil, nil)

				// ACT
				resp, err := gen.Generate(tc.request)
				// ASSERT
				if err != nil {
					t.Errorf("got %#v, wanted nil err", err)
				}
				if resp.DestPath != tc.destPath {
					t.Errorf("got %s, wanted %s", resp.DestPath, tc.destPath)
				}
				if resp.OutPkgPath != tc.outPkgPath {
					t.Errorf("got %s, wanted %s", resp.OutPkgPath, tc.outPkgPath)
				}
			})
		}
	})

	t.Run("non-exported processing", func(t *testing.T) {
		t.Run("unexported top-level type", func(t *testing.T) {
			// ASSEMBLE
			beforeEach(t)
			defer afterEach(t)

			getwdFnMoq.onCall().returnResults("/some-nice-path", nil)
			typeCacheMoq.onCall().FindPackage(".").
				returnResults("destdir", nil)
			typeCacheMoq.onCall().Type(*ast.IdPath("privateInterface", "."), ".", false).
				returnResults(ast.TypeInfo{Exported: false}, nil)

			req := generator.GenerateRequest{
				Types:              []string{"privateInterface"},
				Export:             true,
				Destination:        "file_test.go",
				Package:            "",
				Import:             ".",
				TestImport:         false,
				WorkingDir:         "/some-nice-path",
				ExcludeNonExported: true,
			}

			// ACT
			resp, err := gen.Generate(req)

			// ASSERT
			if err == nil {
				t.Fatal("got no error, wanted error")
			}
			expectedMsg := "non-exported types: ..privateInterface mocked type is not exported"
			if err.Error() != expectedMsg {
				t.Errorf("got %s, wanted %s", err.Error(), expectedMsg)
			}
			if !errors.Is(err, generator.ErrNonExported) {
				t.Errorf("got %#v, want %#v", err, generator.ErrNonExported)
			}
			if resp.File != nil {
				t.Errorf("got %#v, wanted nil", resp.File)
			}
			if resp.DestPath != "" {
				t.Errorf("got %s, wanted nothing", resp.DestPath)
			}
			if resp.OutPkgPath != "" {
				t.Errorf("got %s, wanted nothing", resp.OutPkgPath)
			}
		})

		t.Run("some unexported methods returns partial implementation", func(t *testing.T) {
			// ASSEMBLE
			beforeEach(t)
			defer afterEach(t)

			getwdFnMoq.onCall().returnResults("/some-nice-path", nil)
			typeCacheMoq.onCall().FindPackage(".").
				returnResults("destdir", nil)

			// Creates two methods but one isn't exported so will be reduced
			twoMethods := &dst.FieldList{List: []*dst.Field{func1, dst.Clone(func1).(*dst.Field)}}
			twoMethods.List[1].Names[0].Name = "func1"
			fullInfo := ast.TypeInfo{
				Type: &dst.TypeSpec{
					Name: ast.IdPath("PublicInterface", genPkg),
					Type: &dst.InterfaceType{Methods: twoMethods},
				},
				PkgPath:  genPkg,
				Exported: true,
			}

			typeCacheMoq.onCall().Type(*ast.IdPath("MyInterface", "."), ".", false).
				returnResults(fullInfo, nil)
			typeCacheMoq.onCall().Type(*ast.IdPath("string", ""), genPkg, false).
				returnResults(ast.TypeInfo{Exported: true}, nil)
			ifaceFuncs := []generator.Func{
				{Name: "Func1", FuncType: &dst.FuncType{Params: func1Params}},
			}
			// The method list is reduced back to normal by the time we create
			// the converter
			newConverterFnMoq.onCall(generator.Type{
				TypeInfo: ast.TypeInfo{
					Type:     ifaceInfo1.Type,
					PkgPath:  genPkg,
					Exported: true,
				},
				Funcs:      ifaceFuncs,
				OutPkgPath: "destdir",
				Reduced:    true,
			}, true).returnResults(converter1Moq.mock())
			converter1Moq.onCall().BaseDecls().returnResults([]dst.Decl{&dst.GenDecl{
				Specs: []dst.Spec{&dst.TypeSpec{Name: dst.NewIdent("pub-decl")}},
			}}, nil)
			converter1Moq.onCall().IsolationStruct("mock").
				returnResults(nil, nil)
			converter1Moq.onCall().IsolationStruct("recorder").
				returnResults(nil, nil)
			converter1Moq.onCall().MethodStructs(ifaceFuncs[0]).
				returnResults(nil, nil)
			converter1Moq.onCall().NewFunc().
				returnResults(nil, nil)
			converter1Moq.onCall().IsolationAccessor("mock", "mock").
				returnResults(nil, nil)
			converter1Moq.onCall().MockMethod(ifaceFuncs[0]).
				returnResults(nil, nil)
			converter1Moq.onCall().IsolationAccessor("recorder", "onCall").
				returnResults(nil, nil)
			converter1Moq.onCall().RecorderMethods(ifaceFuncs[0]).
				returnResults(nil, nil)
			converter1Moq.onCall().ResetMethod().
				returnResults(nil, nil)
			converter1Moq.onCall().AssertMethod().
				returnResults(nil, nil)
			req := generator.GenerateRequest{
				Types:              []string{"MyInterface"},
				Export:             true,
				Destination:        "file_test.go",
				Package:            "",
				Import:             ".",
				TestImport:         false,
				WorkingDir:         "/some-nice-path",
				ExcludeNonExported: true,
			}

			// ACT
			resp, err := gen.Generate(req)
			// ASSERT
			if err != nil {
				t.Fatalf("got %#v, want no error", err)
			}
			if resp.DestPath != "file_test.go" {
				t.Errorf("got %s, wanted file_test.go", resp.DestPath)
			}
			if resp.OutPkgPath != "destdir" {
				t.Errorf("got %s, wanted destdir", resp.OutPkgPath)
			}
		})

		t.Run("only unexported methods, error", func(t *testing.T) {
			// ASSEMBLE
			beforeEach(t)
			defer afterEach(t)

			typeCacheMoq.onCall().FindPackage(".").
				returnResults("destdir", nil)
			getwdFnMoq.onCall().returnResults("/some-nice-path", nil)

			func1.Names[0].Name = "func1"
			typeCacheMoq.onCall().Type(*ast.IdPath("MyInterface", "."), ".", false).
				returnResults(ifaceInfo1, nil)
			req := generator.GenerateRequest{
				Types:              []string{"MyInterface"},
				Export:             true,
				Destination:        "file_test.go",
				Package:            "",
				Import:             ".",
				TestImport:         false,
				WorkingDir:         "/some-nice-path",
				ExcludeNonExported: true,
			}

			// ACT
			resp, err := gen.Generate(req)

			// ASSERT
			if err == nil {
				t.Fatal("got no error, wanted error")
			}
			expectedMsg := "non-exported types: type ..MyInterface only contains non-exported types"
			if err.Error() != expectedMsg {
				t.Errorf("got %s, wanted %s", err.Error(), expectedMsg)
			}
			if !errors.Is(err, generator.ErrNonExported) {
				t.Errorf("got %#v, want %#v", err, generator.ErrNonExported)
			}
			if resp.File != nil {
				t.Errorf("got %#v, wanted nil", resp.File)
			}
			if resp.DestPath != "" {
				t.Errorf("got %s, wanted nothing", resp.DestPath)
			}
			if resp.OutPkgPath != "" {
				t.Errorf("got %s, wanted nothing", resp.OutPkgPath)
			}
		})

		t.Run("one method with unexported param, error", func(t *testing.T) {
			// ASSEMBLE
			beforeEach(t)
			defer afterEach(t)

			typeCacheMoq.onCall().FindPackage(".").
				returnResults("destdir", nil)
			getwdFnMoq.onCall().returnResults("/some-nice-path", nil)

			typeCacheMoq.onCall().Type(*ast.IdPath("MyInterface", "."), ".", false).
				returnResults(ifaceInfo1, nil)
			typeCacheMoq.onCall().Type(*ast.IdPath("string", ""), genPkg, false).
				returnResults(ast.TypeInfo{Exported: false}, nil)
			req := generator.GenerateRequest{
				Types:              []string{"MyInterface"},
				Export:             true,
				Destination:        "file_test.go",
				Package:            "",
				Import:             ".",
				TestImport:         false,
				WorkingDir:         "/some-nice-path",
				ExcludeNonExported: true,
			}

			// ACT
			resp, err := gen.Generate(req)

			// ASSERT
			if err == nil {
				t.Fatal("got no error, wanted error")
			}
			expectedMsg := "non-exported types: type ..MyInterface only contains non-exported types"
			if err.Error() != expectedMsg {
				t.Errorf("got %s, wanted %s", err.Error(), expectedMsg)
			}
			if !errors.Is(err, generator.ErrNonExported) {
				t.Errorf("got %#v, want %#v", err, generator.ErrNonExported)
			}
			if resp.File != nil {
				t.Errorf("got %#v, wanted nil", resp.File)
			}
			if resp.DestPath != "" {
				t.Errorf("got %s, wanted nothing", resp.DestPath)
			}
			if resp.OutPkgPath != "" {
				t.Errorf("got %s, wanted nothing", resp.OutPkgPath)
			}
		})

		t.Run("one method with unexported param passed by reference, error", func(t *testing.T) {
			fl := ast.FieldList(ast.Field(ast.Id("string")).Obj)
			testCases := map[string]dst.Expr{
				"array type":        &dst.ArrayType{Elt: ast.Id("string")},
				"chan type":         &dst.ChanType{Value: ast.Id("string")},
				"ellipsis":          ast.Ellipsis(ast.Id("string")),
				"func type params":  ast.FnType(fl).Obj,
				"func type results": ast.FnType(nil).Results(fl).Obj,
				"interface type":    &dst.InterfaceType{Methods: fl},
				"star expr":         ast.Star(ast.Id("string")),
				"struct type":       ast.Struct(ast.Field(ast.Id("string")).Obj),
				"map key":           ast.MapType(ast.Id("string")).Value(ast.Id("int")).Obj,
				"map value":         ast.MapType(ast.Id("int")).Value(ast.Id("string")).Obj,
			}

			for name, tc := range testCases {
				t.Run(name, func(t *testing.T) {
					// ASSEMBLE
					beforeEach(t)
					defer afterEach(t)

					typeCacheMoq.onCall().FindPackage(".").
						returnResults("destdir", nil)
					getwdFnMoq.onCall().returnResults("/some-nice-path", nil)

					func1Params.List[1].Type = tc
					typeCacheMoq.onCall().Type(*ast.IdPath("MyInterface", "."), ".", false).
						returnResults(ifaceInfo1, nil)
					typeCacheMoq.onCall().Type(*ast.IdPath("string", ""), genPkg, false).
						returnResults(ast.TypeInfo{Exported: false}, nil)
					typeCacheMoq.onCall().Type(*ast.IdPath("int", ""), genPkg, false).
						returnResults(ast.TypeInfo{Exported: true}, nil).
						// Not used by all test cases
						repeat(moq.Optional())
					req := generator.GenerateRequest{
						Types:              []string{"MyInterface"},
						Export:             true,
						Destination:        "file_test.go",
						Package:            "",
						Import:             ".",
						TestImport:         false,
						WorkingDir:         "/some-nice-path",
						ExcludeNonExported: true,
					}

					// ACT
					resp, err := gen.Generate(req)

					// ASSERT
					if err == nil {
						t.Fatal("got no error, wanted error")
					}
					expectedMsg := "non-exported types: type ..MyInterface only contains non-exported types"
					if err.Error() != expectedMsg {
						t.Errorf("got %s, wanted %s", err.Error(), expectedMsg)
					}
					if !errors.Is(err, generator.ErrNonExported) {
						t.Errorf("got %#v, want %#v", err, generator.ErrNonExported)
					}
					if resp.File != nil {
						t.Errorf("got %#v, wanted nil", resp.File)
					}
					if resp.DestPath != "" {
						t.Errorf("got %s, wanted nothing", resp.DestPath)
					}
					if resp.OutPkgPath != "" {
						t.Errorf("got %s, wanted nothing", resp.OutPkgPath)
					}
				})
			}
		})

		t.Run("unknown fields", func(t *testing.T) {
			weirdFL := ast.FieldList(ast.Field(ast.LitInt(28)).Obj)
			testCases := map[string]dst.Expr{
				"literal": ast.LitInt(45),

				"array type w/ literal":     &dst.ArrayType{Elt: ast.LitInt(19)},
				"chan type w/ literal":      &dst.ChanType{Value: ast.LitInt(28)},
				"ellipsis w/ literal":       ast.Ellipsis(ast.LitInt(48)),
				"func type w/ literal":      ast.FnType(weirdFL).Obj,
				"interface type w/ literal": &dst.InterfaceType{Methods: weirdFL},
				"star expr w/ literal":      ast.Star(ast.LitInt(91)),
				"struct type w/ literal":    ast.Struct(ast.Field(ast.LitInt(65)).Obj),
				"map type w/ literal":       ast.MapType(ast.LitInt(38)).Value(ast.Id("string")).Obj,
			}

			for name, tc := range testCases {
				t.Run(name, func(t *testing.T) {
					// ASSEMBLE
					beforeEach(t)
					defer afterEach(t)

					typeCacheMoq.onCall().FindPackage(".").
						returnResults("destdir", nil)
					getwdFnMoq.onCall().returnResults("/some-nice-path", nil)

					func1Params.List[1].Type = tc
					typeCacheMoq.onCall().Type(*ast.IdPath("MyInterface", "."), ".", false).
						returnResults(ifaceInfo1, nil)
					req := generator.GenerateRequest{
						Types:              []string{"MyInterface"},
						Export:             true,
						Destination:        "file_test.go",
						Package:            "",
						Import:             ".",
						TestImport:         false,
						WorkingDir:         "/some-nice-path",
						ExcludeNonExported: true,
					}

					// ACT
					resp, err := gen.Generate(req)

					// ASSERT
					if err == nil {
						t.Fatal("got no error, wanted error")
					}
					if !errors.Is(err, generator.ErrUnknownFieldType) {
						t.Errorf("got %#v, want %#v", err, generator.ErrNonExported)
					}
					if resp.File != nil {
						t.Errorf("got %#v, wanted nil", resp.File)
					}
					if resp.DestPath != "" {
						t.Errorf("got %s, wanted nothing", resp.DestPath)
					}
					if resp.OutPkgPath != "" {
						t.Errorf("got %s, wanted nothing", resp.OutPkgPath)
					}
				})
			}
		})

		t.Run("one method with unexported result, error", func(t *testing.T) {
			// ASSEMBLE
			beforeEach(t)
			defer afterEach(t)

			typeCacheMoq.onCall().FindPackage(".").
				returnResults("destdir", nil)
			getwdFnMoq.onCall().returnResults("/some-nice-path", nil)

			func1.Type.(*dst.FuncType).Results = func1Results
			typeCacheMoq.onCall().Type(*ast.IdPath("MyInterface", "."), ".", false).
				returnResults(ifaceInfo1, nil)
			typeCacheMoq.onCall().Type(*ast.IdPath("string", ""), genPkg, false).
				returnResults(ast.TypeInfo{Exported: true}, nil)
			typeCacheMoq.onCall().Type(*ast.IdPath("error", ""), genPkg, false).
				returnResults(ast.TypeInfo{Exported: false}, nil)
			req := generator.GenerateRequest{
				Types:              []string{"MyInterface"},
				Export:             true,
				Destination:        "file_test.go",
				Package:            "",
				Import:             ".",
				TestImport:         false,
				WorkingDir:         "/some-nice-path",
				ExcludeNonExported: true,
			}

			// ACT
			resp, err := gen.Generate(req)

			// ASSERT
			if err == nil {
				t.Fatal("got no error, wanted error")
			}
			expectedMsg := "non-exported types: type ..MyInterface only contains non-exported types"
			if err.Error() != expectedMsg {
				t.Errorf("got %s, wanted %s", err.Error(), expectedMsg)
			}
			if !errors.Is(err, generator.ErrNonExported) {
				t.Errorf("got %#v, want %#v", err, generator.ErrNonExported)
			}
			if resp.File != nil {
				t.Errorf("got %#v, wanted nil", resp.File)
			}
			if resp.DestPath != "" {
				t.Errorf("got %s, wanted nothing", resp.DestPath)
			}
			if resp.OutPkgPath != "" {
				t.Errorf("got %s, wanted nothing", resp.OutPkgPath)
			}
		})

		t.Run("only unexported with embedded interface, error", func(t *testing.T) {
			// ASSEMBLE
			beforeEach(t)
			defer afterEach(t)

			func1.Names[0].Name = "func1"
			getwdFnMoq.onCall().returnResults("/some-nice-path", nil)
			typeCacheMoq.onCall().FindPackage(".").
				returnResults("destdir", nil)

			// PublicInterface embeds privateInterface
			ifaceMethods1.List = append(ifaceMethods1.List, &dst.Field{
				Type: &dst.Ident{
					Name: "privateInterface",
					Path: genPkg,
				},
			})
			typeCacheMoq.onCall().Type(*ast.IdPath("PublicInterface", "."), ".", false).
				returnResults(ifaceInfo1, nil)
			privateId := ast.IdPath("privateInterface", genPkg)
			typeCacheMoq.onCall().Type(*privateId, genPkg, false).
				returnResults(ifaceInfo2, nil)
			req := generator.GenerateRequest{
				Types:              []string{"PublicInterface"},
				Export:             true,
				Destination:        "file_test.go",
				Package:            "",
				Import:             ".",
				TestImport:         false,
				WorkingDir:         "/some-nice-path",
				ExcludeNonExported: true,
			}

			// ACT
			resp, err := gen.Generate(req)

			// ASSERT
			if err == nil {
				t.Fatal("got no error, wanted error")
			}
			expectedMsg := "non-exported types: type ..PublicInterface only contains non-exported types"
			if err.Error() != expectedMsg {
				t.Errorf("got %s, wanted %s", err.Error(), expectedMsg)
			}
			if !errors.Is(err, generator.ErrNonExported) {
				t.Errorf("got %#v, want %#v", err, generator.ErrNonExported)
			}
			if resp.File != nil {
				t.Errorf("got %#v, wanted nil", resp.File)
			}
			if resp.DestPath != "" {
				t.Errorf("got %s, wanted nothing", resp.DestPath)
			}
			if resp.OutPkgPath != "" {
				t.Errorf("got %s, wanted nothing", resp.OutPkgPath)
			}
		})

		t.Run("mocking a function", func(t *testing.T) {
			// ASSEMBLE
			beforeEach(t)
			defer afterEach(t)

			typeCacheMoq.onCall().FindPackage(".").
				returnResults("destdir", nil)
			getwdFnMoq.onCall().returnResults("/some-nice-path", nil)

			typeCacheMoq.onCall().Type(*ast.IdPath("MyFunc", "."), ".", false).
				returnResults(fnInfo, nil)
			typeCacheMoq.onCall().Type(*ast.IdPath("string", ""), "", false).
				returnResults(ast.TypeInfo{Exported: false}, nil)
			req := generator.GenerateRequest{
				Types:              []string{"MyFunc"},
				Export:             true,
				Destination:        "file_test.go",
				Package:            "",
				Import:             ".",
				TestImport:         false,
				WorkingDir:         "/some-nice-path",
				ExcludeNonExported: true,
			}

			// ACT
			resp, err := gen.Generate(req)

			// ASSERT
			if err == nil {
				t.Fatal("got no error, wanted error")
			}
			expectedMsg := "non-exported types: PublicFn mocked type is not exported"
			if err.Error() != expectedMsg {
				t.Errorf("got %s, want %s", err.Error(), expectedMsg)
			}
			if !errors.Is(err, generator.ErrNonExported) {
				t.Errorf("got %#v, want %#v", err, generator.ErrNonExported)
			}
			if resp.File != nil {
				t.Errorf("got %#v, wanted nil", resp.File)
			}
			if resp.DestPath != "" {
				t.Errorf("got %s, wanted nothing", resp.DestPath)
			}
			if resp.OutPkgPath != "" {
				t.Errorf("got %s, wanted nothing", resp.OutPkgPath)
			}
		})
	})

	t.Run("successfully navigates type aliases", func(t *testing.T) {
		// ASSEMBLE
		beforeEach(t)
		defer afterEach(t)

		typeCacheMoq.onCall().FindPackage(".").returnResults("thispkg", nil)
		getwdFnMoq.onCall().returnResults("/some-nice-path", nil)

		ifaceInfo := ast.TypeInfo{
			Type: &dst.TypeSpec{
				Name: ast.IdPath("AliasType", "thatpkg"),
				Type: ast.IdPath("Reader", "io"),
			},
			PkgPath: genPkg,
		}

		typeCacheMoq.onCall().Type(*ast.IdPath("AliasType", "."), ".", false).
			returnResults(ifaceInfo, nil)
		typeCacheMoq.onCall().Type(*ast.IdPath("Reader", "io"), "thatpkg", false).
			returnResults(readerInfo, nil)

		ifaceFuncs := []generator.Func{
			{
				Name: "Read",
				FuncType: &dst.FuncType{
					Params:  readFnType.Params,
					Results: readFnType.Results,
				},
			},
		}
		newConverterFnMoq.onCall(generator.Type{
			TypeInfo: ast.TypeInfo{
				Type:    ifaceInfo.Type,
				PkgPath: genPkg,
			},
			Funcs:      ifaceFuncs,
			OutPkgPath: "thispkg_test",
		}, false).returnResults(converter1Moq.mock())
		converter1Moq.onCall().BaseDecls().returnResults(nil, nil)
		converter1Moq.onCall().IsolationStruct("mock").
			returnResults(nil, nil)
		converter1Moq.onCall().IsolationStruct("recorder").
			returnResults(nil, nil)
		converter1Moq.onCall().MethodStructs(ifaceFuncs[0]).
			returnResults(nil, nil)
		converter1Moq.onCall().NewFunc().
			returnResults(nil, nil)
		converter1Moq.onCall().IsolationAccessor("mock", "mock").
			returnResults(nil, nil)
		converter1Moq.onCall().MockMethod(ifaceFuncs[0]).
			returnResults(nil, nil)
		converter1Moq.onCall().IsolationAccessor("recorder", "onCall").
			returnResults(nil, nil)
		converter1Moq.onCall().RecorderMethods(ifaceFuncs[0]).
			returnResults(nil, nil)
		converter1Moq.onCall().ResetMethod().
			returnResults(nil, nil)
		converter1Moq.onCall().AssertMethod().
			returnResults(nil, nil)

		req := generator.GenerateRequest{
			Types:       []string{"AliasType"},
			Export:      false,
			Destination: "file_test.go",
			Package:     "",
			Import:      ".",
			TestImport:  false,
			WorkingDir:  "/some-nice-path",
		}

		// ACT
		_, err := gen.Generate(req)
		// ASSERT
		if err != nil {
			t.Errorf("got %#v, wanted nil err", err)
		}
	})

	t.Run("returns an os.Getwd error", func(t *testing.T) {
		// ASSEMBLE
		beforeEach(t)
		defer afterEach(t)

		getwdFnMoq.onCall().returnResults("/some-nice-path", errors.New("os.Getwd-error"))

		req := generator.GenerateRequest{
			Types:       []string{"PublicInterface"},
			Export:      false,
			Destination: "file_test.go",
			Package:     "",
			Import:      ".",
			TestImport:  false,
			WorkingDir:  "/some-nice-path",
		}

		// ACT
		resp, err := gen.Generate(req)

		// ASSERT
		if err == nil {
			t.Fatal("got no error, wanted error")
		}
		expectedMsg := "error getting current working directory: os.Getwd-error"
		if err.Error() != expectedMsg {
			t.Errorf("got %s, wanted %s", err.Error(), expectedMsg)
		}
		if resp.File != nil {
			t.Errorf("got %#v, wanted nil", resp.File)
		}
		if resp.DestPath != "" {
			t.Errorf("got %s, wanted nothing", resp.DestPath)
		}
		if resp.OutPkgPath != "" {
			t.Errorf("got %s, wanted nothing", resp.OutPkgPath)
		}
	})

	t.Run("returns an ErrInvalidConfig when defining both destination"+
		" and destination directory", func(t *testing.T) {
		// ASSEMBLE
		beforeEach(t)
		defer afterEach(t)

		typeCacheMoq.onCall().FindPackage("moqdir").returnResults("thispkg", nil)
		getwdFnMoq.onCall().returnResults("/some-nice-path", nil)

		req := generator.GenerateRequest{
			Types:          []string{"PublicInterface"},
			Export:         false,
			Destination:    "file_test.go",
			DestinationDir: "./moqdir",
			Package:        "",
			Import:         ".",
			TestImport:     false,
			WorkingDir:     "/some-nice-path",
		}

		// ACT
		resp, err := gen.Generate(req)

		// ASSERT
		if err == nil {
			t.Fatal("got no error, wanted error")
		}
		if !errors.Is(err, generator.ErrInvalidConfig) {
			t.Errorf("got %#v, wanted %#v", err, generator.ErrInvalidConfig)
		}
		expectedMsg := "invalid configuration: both --destination and" +
			" --destination-dir flags must not be present together"
		if err.Error() != expectedMsg {
			t.Errorf("got %s, wanted %s", err.Error(), expectedMsg)
		}
		if resp.File != nil {
			t.Errorf("got %#v, wanted nil", resp.File)
		}
		if resp.DestPath != "" {
			t.Errorf("got %s, wanted nothing", resp.DestPath)
		}
		if resp.OutPkgPath != "" {
			t.Errorf("got %s, wanted nothing", resp.OutPkgPath)
		}
	})

	t.Run("returns a converter error", func(t *testing.T) {
		for n := 1; n < 20; n++ {
			t.Run(fmt.Sprintf("%d calls", n), func(t *testing.T) {
				// ASSEMBLE
				beforeEach(t)
				defer afterEach(t)

				typeCacheMoq.onCall().FindPackage(".").returnResults("thispkg", nil)
				getwdFnMoq.onCall().returnResults("/some-nice-path", nil)
				typeCacheMoq.onCall().Type(*ast.IdPath("PublicInterface", "."), ".", false).
					returnResults(ifaceInfo1, nil)
				ifaceFuncs := []generator.Func{{
					Name: "Func1", FuncType: &dst.FuncType{Params: func1Params},
				}}
				newConverterFnMoq.onCall(generator.Type{
					TypeInfo: ast.TypeInfo{
						Type:     ifaceInfo1.Type,
						PkgPath:  genPkg,
						Exported: true,
					},
					Funcs:      ifaceFuncs,
					OutPkgPath: "thispkg_test",
				}, false).returnResults(converter1Moq.mock())

				expectedErr := errors.New("bad convertor")
				count := n
				done := func() bool {
					count--
					if count < 0 {
						return true
					}

					return false
				}
				retError := func() error {
					if count <= 0 {
						return expectedErr
					}

					return nil
				}

				if !done() {
					converter1Moq.onCall().BaseDecls().returnResults([]dst.Decl{&dst.GenDecl{
						Specs: []dst.Spec{&dst.TypeSpec{Name: dst.NewIdent("pub-decl")}},
					}}, retError())
				}
				if !done() {
					converter1Moq.onCall().IsolationStruct("mock").
						returnResults(nil, retError())
				}
				if !done() {
					converter1Moq.onCall().IsolationStruct("recorder").
						returnResults(nil, retError())
				}
				if !done() {
					converter1Moq.onCall().MethodStructs(ifaceFuncs[0]).
						returnResults(nil, retError())
				}
				if !done() {
					converter1Moq.onCall().NewFunc().
						returnResults(nil, retError())
				}
				if !done() {
					converter1Moq.onCall().IsolationAccessor("mock", "mock").
						returnResults(nil, retError())
				}
				if !done() {
					converter1Moq.onCall().MockMethod(ifaceFuncs[0]).
						returnResults(nil, retError())
				}
				if !done() {
					converter1Moq.onCall().IsolationAccessor("recorder", "onCall").
						returnResults(nil, retError())
				}
				if !done() {
					converter1Moq.onCall().RecorderMethods(ifaceFuncs[0]).
						returnResults(nil, retError())
				}
				if !done() {
					converter1Moq.onCall().ResetMethod().
						returnResults(nil, retError())
				}
				if !done() {
					converter1Moq.onCall().AssertMethod().
						returnResults(nil, retError())
				}
				fnFuncs := []generator.Func{{FuncType: &dst.FuncType{Params: func1Params}}}
				if !done() {
					typeCacheMoq.onCall().Type(*ast.IdPath("PublicFn", "."), ".", false).
						returnResults(fnInfo, nil)
					typeCacheMoq.onCall().Type(*ast.IdPath("string", ""), "", false).
						returnResults(ast.TypeInfo{Exported: true}, nil)
					newConverterFnMoq.onCall(generator.Type{
						TypeInfo: ast.TypeInfo{
							Type:     fnInfo.Type,
							PkgPath:  genPkg,
							Exported: true,
						},
						Funcs:      fnFuncs,
						OutPkgPath: "thispkg_test",
					}, false).returnResults(converter2Moq.mock())

					converter2Moq.onCall().BaseDecls().returnResults([]dst.Decl{&dst.GenDecl{
						Specs: []dst.Spec{&dst.TypeSpec{Name: dst.NewIdent("pub-decl")}},
					}}, retError())
				}
				if !done() {
					converter2Moq.onCall().IsolationStruct("mock").
						returnResults(nil, retError())
				}
				if !done() {
					converter2Moq.onCall().MethodStructs(fnFuncs[0]).
						returnResults(nil, retError())
				}
				if !done() {
					converter2Moq.onCall().NewFunc().
						returnResults(nil, retError())
				}
				if !done() {
					converter2Moq.onCall().FuncClosure(fnFuncs[0]).
						returnResults(nil, retError())
				}
				if !done() {
					converter2Moq.onCall().MockMethod(fnFuncs[0]).
						returnResults(nil, retError())
				}
				if !done() {
					converter2Moq.onCall().RecorderMethods(fnFuncs[0]).
						returnResults(nil, retError())
				}
				if !done() {
					converter2Moq.onCall().ResetMethod().
						returnResults(nil, retError())
				}
				if !done() {
					converter2Moq.onCall().AssertMethod().
						returnResults(nil, retError())
				}

				req := generator.GenerateRequest{
					Types:       []string{"PublicInterface", "PublicFn"},
					Export:      false,
					Destination: "file_test.go",
					Package:     "",
					Import:      ".",
					TestImport:  false,
					WorkingDir:  "/some-nice-path",
				}

				// ACT
				resp, err := gen.Generate(req)

				// ASSERT
				if err != expectedErr {
					t.Errorf("got %#v, wanted %#v", err, expectedErr)
				}
				if resp.File != nil {
					t.Errorf("got %#v, wanted nil", resp.File)
				}
				if resp.DestPath != "" {
					t.Errorf("got %s, wanted nothing", resp.DestPath)
				}
				if resp.OutPkgPath != "" {
					t.Errorf("got %s, wanted nothing", resp.OutPkgPath)
				}
			})
		}
	})

	t.Run("loads tests types when requested", func(t *testing.T) {
		// ASSEMBLE
		beforeEach(t)
		defer afterEach(t)

		typeCacheMoq.onCall().FindPackage(".").returnResults("thispkg", nil)
		getwdFnMoq.onCall().returnResults("/some-nice-path", nil)
		typeCacheMoq.onCall().Type(*ast.IdPath("PublicInterface", "."), ".", true).
			returnResults(ifaceInfo1, nil)
		typeCacheMoq.onCall().Type(*ast.IdPath("privateInterface", "."), ".", true).
			returnResults(ifaceInfo2, nil)

		iface1Funcs := []generator.Func{{
			Name: "Func1", FuncType: &dst.FuncType{Params: func1Params},
		}}
		newConverterFnMoq.onCall(generator.Type{
			TypeInfo: ast.TypeInfo{
				Type:     ifaceInfo1.Type,
				PkgPath:  genPkg,
				Exported: true,
			},
			Funcs:      iface1Funcs,
			OutPkgPath: "thispkg_test",
		}, false).returnResults(converter1Moq.mock())
		converter1Moq.onCall().BaseDecls().returnResults(nil, nil)
		converter1Moq.onCall().IsolationStruct("mock").
			returnResults(nil, nil)
		converter1Moq.onCall().IsolationStruct("recorder").
			returnResults(nil, nil)
		converter1Moq.onCall().MethodStructs(iface1Funcs[0]).
			returnResults(nil, nil)
		converter1Moq.onCall().NewFunc().
			returnResults(nil, nil)
		converter1Moq.onCall().IsolationAccessor("mock", "mock").
			returnResults(nil, nil)
		converter1Moq.onCall().MockMethod(iface1Funcs[0]).
			returnResults(nil, nil)
		converter1Moq.onCall().IsolationAccessor("recorder", "onCall").
			returnResults(nil, nil)
		converter1Moq.onCall().RecorderMethods(iface1Funcs[0]).
			returnResults(nil, nil)
		converter1Moq.onCall().ResetMethod().
			returnResults(nil, nil)
		converter1Moq.onCall().AssertMethod().
			returnResults(nil, nil)

		var iface2Funcs []generator.Func
		newConverterFnMoq.onCall(generator.Type{
			TypeInfo: ast.TypeInfo{
				Type:    ifaceInfo2.Type,
				PkgPath: genPkg,
			},
			Funcs:      iface2Funcs,
			OutPkgPath: "thispkg_test",
		}, false).returnResults(converter2Moq.mock())
		converter2Moq.onCall().BaseDecls().returnResults(nil, nil)
		converter2Moq.onCall().IsolationStruct("mock").
			returnResults(nil, nil)
		converter2Moq.onCall().IsolationStruct("recorder").
			returnResults(nil, nil)
		converter2Moq.onCall().NewFunc().
			returnResults(nil, nil)
		converter2Moq.onCall().IsolationAccessor("mock", "mock").
			returnResults(nil, nil)
		converter2Moq.onCall().IsolationAccessor("recorder", "onCall").
			returnResults(nil, nil)
		converter2Moq.onCall().ResetMethod().
			returnResults(nil, nil)
		converter2Moq.onCall().AssertMethod().
			returnResults(nil, nil)

		req := generator.GenerateRequest{
			Types:       []string{"PublicInterface", "privateInterface"},
			Export:      false,
			Destination: "file_test.go",
			Package:     "",
			Import:      ".",
			TestImport:  true,
			WorkingDir:  "/some-nice-path",
		}

		// ACT
		_, err := gen.Generate(req)
		// ASSERT
		if err != nil {
			t.Errorf("got %#v, wanted nil err", err)
		}
	})

	t.Run("returns an error when the type cache returns an error", func(t *testing.T) {
		// ASSEMBLE
		beforeEach(t)
		defer afterEach(t)

		typeCacheMoq.onCall().FindPackage(".").returnResults("thispkg", nil)
		getwdFnMoq.onCall().returnResults("/some-nice-path", nil)
		expectedErr := errors.New("bad cache")
		typeCacheMoq.onCall().Type(*ast.IdPath("BadInterface", "."), ".", false).
			returnResults(ast.TypeInfo{}, expectedErr)

		req := generator.GenerateRequest{
			Types:       []string{"BadInterface"},
			Export:      false,
			Destination: "file_test.go",
			Package:     "",
			Import:      ".",
			TestImport:  false,
			WorkingDir:  "/some-nice-path",
		}

		// ACT
		resp, err := gen.Generate(req)

		// ASSERT
		if err != expectedErr {
			t.Errorf("got %#v, wanted %#v", err, expectedErr)
		}
		if resp.File != nil {
			t.Errorf("got %#v, wanted nil", resp.File)
		}
		if resp.DestPath != "" {
			t.Errorf("got %s, wanted nothing", resp.DestPath)
		}
		if resp.OutPkgPath != "" {
			t.Errorf("got %s, wanted nothing", resp.OutPkgPath)
		}
	})

	t.Run("returns an error when recursive lookups return an error", func(t *testing.T) {
		// ASSEMBLE
		beforeEach(t)
		defer afterEach(t)

		typeCacheMoq.onCall().FindPackage(".").returnResults("thispkg", nil)
		getwdFnMoq.onCall().returnResults("/some-nice-path", nil)
		// PublicInterface embeds privateInterface
		ifaceMethods1.List = append(ifaceMethods1.List, &dst.Field{
			Type: &dst.Ident{
				Name: "privateInterface",
				Path: genPkg,
			},
		})
		typeCacheMoq.onCall().Type(*ast.IdPath("PublicInterface", "."), ".", false).
			returnResults(ifaceInfo1, nil)
		expectedErr := errors.New("bad cache")
		typeCacheMoq.onCall().Type(*ast.IdPath("privateInterface", genPkg), genPkg, false).
			returnResults(ast.TypeInfo{}, expectedErr)

		req := generator.GenerateRequest{
			Types:       []string{"PublicInterface"},
			Export:      false,
			Destination: "file_test.go",
			Package:     "",
			Import:      ".",
			TestImport:  false,
			WorkingDir:  "/some-nice-path",
		}

		// ACT
		resp, err := gen.Generate(req)

		// ASSERT
		if err != expectedErr {
			t.Errorf("got %#v, wanted %#v", err, expectedErr)
		}
		if resp.File != nil {
			t.Errorf("got %#v, wanted nil", resp.File)
		}
		if resp.DestPath != "" {
			t.Errorf("got %s, wanted nothing", resp.DestPath)
		}
		if resp.OutPkgPath != "" {
			t.Errorf("got %s, wanted nothing", resp.OutPkgPath)
		}
	})

	t.Run("returns an error when recursive function lookups return an error", func(t *testing.T) {
		// ASSEMBLE
		beforeEach(t)
		defer afterEach(t)

		typeCacheMoq.onCall().FindPackage(".").returnResults("thispkg", nil)
		getwdFnMoq.onCall().returnResults("/some-nice-path", nil)

		// PublicInterface embeds privateInterface which embeds io.Reader
		ifaceMethods1.List = append(ifaceMethods1.List, &dst.Field{
			Type: &dst.Ident{
				Name: "privateInterface",
				Path: genPkg,
			},
		})
		ifaceMethods2.List = append(ifaceMethods2.List, &dst.Field{
			Type: &dst.Ident{
				Name: "Reader",
				Path: "io",
			},
		})
		typeCacheMoq.onCall().Type(*ast.IdPath("PublicInterface", "."), ".", false).
			returnResults(ifaceInfo1, nil)
		typeCacheMoq.onCall().Type(*ast.IdPath("privateInterface", genPkg), genPkg, false).
			returnResults(ifaceInfo2, nil)
		expectedErr := errors.New("bad cache")
		typeCacheMoq.onCall().Type(*ast.IdPath("Reader", "io"), "", false).
			returnResults(ast.TypeInfo{}, expectedErr)

		req := generator.GenerateRequest{
			Types:       []string{"PublicInterface"},
			Export:      false,
			Destination: "file_test.go",
			Package:     "",
			Import:      ".",
			TestImport:  false,
			WorkingDir:  "/some-nice-path",
		}

		// ACT
		resp, err := gen.Generate(req)

		// ASSERT
		if err != expectedErr {
			t.Errorf("got %#v, wanted %#v", err, expectedErr)
		}
		if resp.File != nil {
			t.Errorf("got %#v, wanted nil", resp.File)
		}
		if resp.DestPath != "" {
			t.Errorf("got %s, wanted nothing", resp.DestPath)
		}
		if resp.OutPkgPath != "" {
			t.Errorf("got %s, wanted nothing", resp.OutPkgPath)
		}
	})

	t.Run("handles function types", func(t *testing.T) {
		// ASSEMBLE
		beforeEach(t)
		defer afterEach(t)

		typeCacheMoq.onCall().FindPackage(".").returnResults("thispkg", nil)
		getwdFnMoq.onCall().returnResults("/some-nice-path", nil)
		fnInfo.Type.Name.Path = "where-the-fn-lives"
		typeCacheMoq.onCall().Type(*ast.IdPath("PublicFn", "."), ".", false).
			returnResults(fnInfo, nil)
		typeCacheMoq.onCall().Type(*ast.IdPath("string", ""), "where-the-fn-lives", false).
			returnResults(ast.TypeInfo{Exported: true}, nil)
		fnFuncs := []generator.Func{{FuncType: &dst.FuncType{Params: func1Params}}}
		newConverterFnMoq.onCall(generator.Type{
			TypeInfo: ast.TypeInfo{
				Type:     fnInfo.Type,
				PkgPath:  genPkg,
				Exported: true,
			},
			Funcs:      fnFuncs,
			OutPkgPath: "thispkg_test",
		}, false).returnResults(converter1Moq.mock())
		converter1Moq.onCall().BaseDecls().returnResults([]dst.Decl{&dst.GenDecl{
			Specs: []dst.Spec{&dst.TypeSpec{Name: dst.NewIdent("pub-decl")}},
		}}, nil)
		converter1Moq.onCall().IsolationStruct("mock").
			returnResults(nil, nil)
		converter1Moq.onCall().MethodStructs(fnFuncs[0]).
			returnResults(nil, nil)
		converter1Moq.onCall().NewFunc().
			returnResults(nil, nil)
		converter1Moq.onCall().FuncClosure(fnFuncs[0]).
			returnResults(nil, nil)
		converter1Moq.onCall().MockMethod(fnFuncs[0]).
			returnResults(nil, nil)
		converter1Moq.onCall().RecorderMethods(fnFuncs[0]).
			returnResults(nil, nil)
		converter1Moq.onCall().ResetMethod().
			returnResults(nil, nil)
		converter1Moq.onCall().AssertMethod().
			returnResults(nil, nil)

		req := generator.GenerateRequest{
			Types:       []string{"PublicFn"},
			Export:      false,
			Destination: "file_test.go",
			Package:     "",
			Import:      ".",
			TestImport:  false,
			WorkingDir:  "/some-nice-path",
		}

		// ACT
		_, err := gen.Generate(req)
		// ASSERT
		if err != nil {
			t.Errorf("got %#v, wanted nil err", err)
		}
	})
}
