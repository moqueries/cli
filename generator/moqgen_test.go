package generator_test

import (
	"errors"
	"testing"

	"github.com/dave/dst"

	"github.com/myshkin5/moqueries/ast"
	"github.com/myshkin5/moqueries/generator"
	"github.com/myshkin5/moqueries/logs"
	"github.com/myshkin5/moqueries/moq"
)

func TestMoqGenerator(t *testing.T) {
	var (
		scene             *moq.Scene
		typeCacheMoq      *moqTypeCache
		newConverterFnMoq *moqNewConverterFunc
		converter1Moq     *moqConverterer
		converter2Moq     *moqConverterer

		gen *generator.MoqGenerator

		ifaceSpec1    *dst.TypeSpec
		ifaceSpec2    *dst.TypeSpec
		ifaceMethods1 *dst.FieldList
		ifaceMethods2 *dst.FieldList
		func1         *dst.Field
		func1Params   *dst.FieldList

		readFnType *dst.FuncType
		readerSpec *dst.TypeSpec

		fnSpec *dst.TypeSpec
	)

	beforeEach := func(t *testing.T) {
		t.Helper()
		logs.Init(false)

		if scene != nil {
			t.Fatal("afterEach not called")
		}
		scene = moq.NewScene(t)
		typeCacheMoq = newMoqTypeCache(scene, nil)
		newConverterFnMoq = newMoqNewConverterFunc(scene, nil)
		converter1Moq = newMoqConverterer(scene, nil)
		converter2Moq = newMoqConverterer(scene, nil)

		gen = generator.New(
			typeCacheMoq.mock(),
			newConverterFnMoq.mock())

		func1Params = &dst.FieldList{List: []*dst.Field{
			{
				Names: []*dst.Ident{dst.NewIdent("firstParm")},
				Type: &dst.StarExpr{X: &dst.SelectorExpr{
					X:   dst.NewIdent("cobra"),
					Sel: dst.NewIdent("Command"),
				}},
			},
			{Type: dst.NewIdent("string")},
			{
				Type: &dst.StarExpr{X: &dst.SelectorExpr{
					X:   dst.NewIdent("dst"),
					Sel: dst.NewIdent("InterfaceType"),
				}},
			},
		}}
		func1 = &dst.Field{
			Names: []*dst.Ident{dst.NewIdent("Func1")},
			Type:  &dst.FuncType{Params: func1Params, Results: nil},
		}
		ifaceMethods1 = &dst.FieldList{List: []*dst.Field{func1}}
		ifaceSpec1 = &dst.TypeSpec{
			Name: dst.NewIdent("PublicInterface"),
			Type: &dst.InterfaceType{Methods: ifaceMethods1},
		}
		ifaceMethods2 = &dst.FieldList{}
		ifaceSpec2 = &dst.TypeSpec{
			Name: dst.NewIdent("privateInterface"),
			Type: &dst.InterfaceType{Methods: ifaceMethods2},
		}

		readFnType = &dst.FuncType{
			Params: &dst.FieldList{List: []*dst.Field{{
				Names: []*dst.Ident{dst.NewIdent("p")},
				Type:  &dst.ArrayType{Elt: dst.NewIdent("byte")},
			}}},
			Results: &dst.FieldList{List: []*dst.Field{
				{
					Names: []*dst.Ident{dst.NewIdent("n")},
					Type:  dst.NewIdent("int"),
				},
				{
					Names: []*dst.Ident{dst.NewIdent("err")},
					Type:  dst.NewIdent("error"),
				},
			}},
		}
		readerSpec = &dst.TypeSpec{
			Name: &dst.Ident{Name: "Reader", Path: "io"},
			Type: &dst.InterfaceType{Methods: &dst.FieldList{
				List: []*dst.Field{{
					Names: []*dst.Ident{dst.NewIdent("Read")},
					Type:  readFnType,
				}},
			}},
		}

		fnSpec = &dst.TypeSpec{
			Name: dst.NewIdent("PublicFn"),
			Type: &dst.FuncType{Params: func1Params, Results: nil},
		}
	}

	afterEach := func() {
		scene.AssertExpectationsMet()
		scene = nil
	}

	t.Run("always returns a header comment", func(t *testing.T) {
		// ASSEMBLE
		beforeEach(t)
		defer afterEach()
		req := generator.GenerateRequest{
			Types:       nil,
			Export:      false,
			Destination: "dir/file_test.go",
			Package:     "",
			Import:      ".",
			TestImport:  false,
		}

		typeCacheMoq.onCall().FindPackage("dir").returnResults("dir", nil)

		// ACT
		_, file, err := gen.Generate(req)
		// ASSERT
		if err != nil {
			t.Errorf("got %#v, wanted nil err", err)
		}
		if file == nil {
			t.Fatalf("got nil file, wanted not nil")
		}
		if len(file.Decs.Start) < 1 {
			t.Errorf("got %d, wanted > 0 len start", len(file.Decs.Start))
		}
		expectedStart := "// Code generated by Moqueries - https://github.com/myshkin5/moqueries - DO NOT EDIT!"
		if file.Decs.Start[0] != expectedStart {
			t.Errorf("got %s, wanted %s", file.Decs.Start[0], expectedStart)
		}
	})

	t.Run("defaults a test package when not exported and the package isn't specified", func(t *testing.T) {
		// ASSEMBLE
		beforeEach(t)
		defer afterEach()
		req := generator.GenerateRequest{
			Types:       nil,
			Export:      false,
			Destination: "dir/file_test.go",
			Package:     "",
			Import:      ".",
			TestImport:  false,
		}

		typeCacheMoq.onCall().FindPackage("dir").returnResults("dir", nil)

		// ACT
		_, file, err := gen.Generate(req)
		// ASSERT
		if err != nil {
			t.Errorf("got %#v, wanted nil err", err)
		}
		if file.Name.Name != "dir_test" {
			t.Errorf("got %s, wanted dir_test", file.Name.Name)
		}
	})

	t.Run("defaults a non-test package when exported and the package isn't specified", func(t *testing.T) {
		// ASSEMBLE
		beforeEach(t)
		defer afterEach()
		req := generator.GenerateRequest{
			Types:       nil,
			Export:      true,
			Destination: "dir/file_test.go",
			Package:     "",
			Import:      ".",
			TestImport:  false,
		}

		typeCacheMoq.onCall().FindPackage("dir").returnResults("dir", nil)

		// ACT
		_, file, err := gen.Generate(req)
		// ASSERT
		if err != nil {
			t.Errorf("got %#v, wanted nil err", err)
		}
		if file.Name.Name != "dir" {
			t.Errorf("got %s, wanted dir", file.Name.Name)
		}
	})

	t.Run("can put mocks in parent packages when given a relative destination", func(t *testing.T) {
		// ASSEMBLE
		beforeEach(t)
		defer afterEach()
		req := generator.GenerateRequest{
			Types:       nil,
			Export:      true,
			Destination: "../file_test.go",
			Package:     "",
			Import:      ".",
			TestImport:  false,
		}

		typeCacheMoq.onCall().FindPackage("..").returnResults("otherpkg", nil)

		// ACT
		_, file, err := gen.Generate(req)
		// ASSERT
		if err != nil {
			t.Errorf("got %#v, wanted nil err", err)
		}
		if file.Name.Name != "otherpkg" {
			t.Errorf("got %s, wanted otherpkg", file.Name.Name)
		}
	})

	t.Run("defaults the package to a test name based on the current"+
		" directory when it isn't specified and not exported", func(t *testing.T) {
		// ASSEMBLE
		beforeEach(t)
		defer afterEach()
		req := generator.GenerateRequest{
			Types:       nil,
			Export:      false,
			Destination: "file_test.go",
			Package:     "",
			Import:      ".",
			TestImport:  false,
		}

		typeCacheMoq.onCall().FindPackage(".").returnResults("thispkg", nil)

		// ACT
		_, file, err := gen.Generate(req)
		// ASSERT
		if err != nil {
			t.Errorf("got %#v, wanted nil err", err)
		}
		if file.Name.Name != "thispkg_test" {
			t.Errorf("got %s, wanted generator_test", file.Name.Name)
		}
	})

	t.Run("defaults the package to a non-test name based on the current"+
		" directory when it isn't specified and exported", func(t *testing.T) {
		// ASSEMBLE
		beforeEach(t)
		defer afterEach()
		req := generator.GenerateRequest{
			Types:       nil,
			Export:      true,
			Destination: "file_test.go",
			Package:     "",
			Import:      ".",
			TestImport:  false,
		}

		typeCacheMoq.onCall().FindPackage(".").returnResults("thispkg", nil)

		// ACT
		_, file, err := gen.Generate(req)
		// ASSERT
		if err != nil {
			t.Errorf("got %#v, wanted nil err", err)
		}
		if file.Name.Name != "thispkg" {
			t.Errorf("got %s, wanted generator", file.Name.Name)
		}
	})

	t.Run("recursively looks up nested interfaces", func(t *testing.T) {
		// ASSEMBLE
		beforeEach(t)
		defer afterEach()
		typeCacheMoq.onCall().FindPackage(".").returnResults("thispkg", nil)
		// PublicInterface embeds privateInterface which embeds io.Reader
		ifaceMethods1.List = append(ifaceMethods1.List, &dst.Field{
			Type: &dst.Ident{
				Name: "privateInterface",
				Path: "github.com/myshkin5/moqueries/generator",
			},
		})
		ifaceMethods2.List = append(ifaceMethods2.List, &dst.Field{
			Type: &dst.Ident{
				Name: "Reader",
				Path: "io",
			},
		})
		typeCacheMoq.onCall().Type(*ast.IdPath("PublicInterface", "."), false).
			returnResults(ifaceSpec1, "github.com/myshkin5/moqueries/generator", nil)
		typeCacheMoq.onCall().Type(*ast.IdPath("privateInterface", "github.com/myshkin5/moqueries/generator"), false).
			returnResults(ifaceSpec2, "github.com/myshkin5/moqueries/generator", nil)
		typeCacheMoq.onCall().Type(*ast.IdPath("Reader", "io"), false).
			returnResults(readerSpec, "", nil)
		typeCacheMoq.onCall().Type(*ast.IdPath("privateInterface", "."), false).
			returnResults(ifaceSpec2, "github.com/myshkin5/moqueries/generator", nil)
		typeCacheMoq.onCall().Type(*ast.IdPath("Reader", "io"), false).
			returnResults(readerSpec, "", nil)
		ifaceFuncs := []generator.Func{
			{Name: "Func1", Params: func1Params},
			{
				Name:    "Read",
				Params:  readFnType.Params,
				Results: readFnType.Results,
			},
		}
		newConverterFnMoq.onCall(generator.Type{
			TypeSpec:   ifaceSpec1,
			Funcs:      ifaceFuncs,
			InPkgPath:  "github.com/myshkin5/moqueries/generator",
			OutPkgPath: "thispkg_test",
		}, false).returnResults(converter1Moq.mock())
		converter1Moq.onCall().BaseStruct().returnResults(&dst.GenDecl{Specs: []dst.Spec{&dst.TypeSpec{
			Name: dst.NewIdent("pub-decl"),
		}}})
		converter1Moq.onCall().IsolationStruct("mock").
			returnResults(nil)
		converter1Moq.onCall().IsolationStruct("recorder").
			returnResults(nil)
		converter1Moq.onCall().MethodStructs(ifaceFuncs[0]).
			returnResults(nil, nil)
		converter1Moq.onCall().MethodStructs(ifaceFuncs[1]).
			returnResults(nil, nil)
		converter1Moq.onCall().NewFunc().
			returnResults(nil)
		converter1Moq.onCall().IsolationAccessor("mock", "mock").
			returnResults(nil)
		converter1Moq.onCall().MockMethod(ifaceFuncs[0]).
			returnResults(nil)
		converter1Moq.onCall().MockMethod(ifaceFuncs[1]).
			returnResults(nil)
		converter1Moq.onCall().IsolationAccessor("recorder", "onCall").
			returnResults(nil)
		converter1Moq.onCall().RecorderMethods(ifaceFuncs[0]).
			returnResults(nil)
		converter1Moq.onCall().RecorderMethods(ifaceFuncs[1]).
			returnResults(nil)
		converter1Moq.onCall().ResetMethod().
			returnResults(nil)
		converter1Moq.onCall().AssertMethod().
			returnResults(nil)
		iface2Funcs := []generator.Func{{
			Name:    "Read",
			Params:  readFnType.Params,
			Results: readFnType.Results,
		}}
		newConverterFnMoq.onCall(generator.Type{
			TypeSpec:   ifaceSpec2,
			Funcs:      iface2Funcs,
			InPkgPath:  "github.com/myshkin5/moqueries/generator",
			OutPkgPath: "thispkg_test",
		}, false).returnResults(converter2Moq.mock())
		converter2Moq.onCall().BaseStruct().returnResults(nil)
		converter2Moq.onCall().IsolationStruct("mock").
			returnResults(nil)
		converter2Moq.onCall().IsolationStruct("recorder").
			returnResults(nil)
		converter2Moq.onCall().MethodStructs(iface2Funcs[0]).
			returnResults(nil, nil)
		converter2Moq.onCall().NewFunc().
			returnResults(nil)
		converter2Moq.onCall().IsolationAccessor("mock", "mock").
			returnResults(nil)
		converter2Moq.onCall().MockMethod(iface2Funcs[0]).
			returnResults(nil)
		converter2Moq.onCall().IsolationAccessor("recorder", "onCall").
			returnResults(nil)
		converter2Moq.onCall().RecorderMethods(iface2Funcs[0]).
			returnResults(nil)
		converter2Moq.onCall().ResetMethod().
			returnResults(nil)
		converter2Moq.onCall().AssertMethod().
			returnResults(nil)

		req := generator.GenerateRequest{
			Types:       []string{"PublicInterface", "privateInterface"},
			Export:      false,
			Destination: "file_test.go",
			Package:     "",
			Import:      ".",
			TestImport:  false,
		}

		// ACT
		_, _, err := gen.Generate(req)
		// ASSERT
		if err != nil {
			t.Errorf("got %#v, wanted nil err", err)
		}
	})

	t.Run("successfully navigates type aliases", func(t *testing.T) {
		// ASSEMBLE
		beforeEach(t)
		defer afterEach()

		typeCacheMoq.onCall().FindPackage(".").returnResults("thispkg", nil)

		ifaceSpec := &dst.TypeSpec{
			Name: dst.NewIdent("AliasType"),
			Type: ast.IdPath("Reader", "io"),
		}

		typeCacheMoq.onCall().Type(*ast.IdPath("AliasType", "."), false).
			returnResults(ifaceSpec, "github.com/myshkin5/moqueries/generator", nil)
		typeCacheMoq.onCall().Type(*ast.IdPath("Reader", "io"), false).
			returnResults(readerSpec, "", nil)

		ifaceFuncs := []generator.Func{
			{
				Name:    "Read",
				Params:  readFnType.Params,
				Results: readFnType.Results,
			},
		}
		newConverterFnMoq.onCall(generator.Type{
			TypeSpec:   ifaceSpec,
			Funcs:      ifaceFuncs,
			InPkgPath:  "github.com/myshkin5/moqueries/generator",
			OutPkgPath: "thispkg_test",
		}, false).returnResults(converter1Moq.mock())
		converter1Moq.onCall().BaseStruct().returnResults(nil)
		converter1Moq.onCall().IsolationStruct("mock").
			returnResults(nil)
		converter1Moq.onCall().IsolationStruct("recorder").
			returnResults(nil)
		converter1Moq.onCall().MethodStructs(ifaceFuncs[0]).
			returnResults(nil, nil)
		converter1Moq.onCall().NewFunc().
			returnResults(nil)
		converter1Moq.onCall().IsolationAccessor("mock", "mock").
			returnResults(nil)
		converter1Moq.onCall().MockMethod(ifaceFuncs[0]).
			returnResults(nil)
		converter1Moq.onCall().IsolationAccessor("recorder", "onCall").
			returnResults(nil)
		converter1Moq.onCall().RecorderMethods(ifaceFuncs[0]).
			returnResults(nil)
		converter1Moq.onCall().ResetMethod().
			returnResults(nil)
		converter1Moq.onCall().AssertMethod().
			returnResults(nil)

		req := generator.GenerateRequest{
			Types:       []string{"AliasType"},
			Export:      false,
			Destination: "file_test.go",
			Package:     "",
			Import:      ".",
			TestImport:  false,
		}

		// ACT
		_, _, err := gen.Generate(req)
		// ASSERT
		if err != nil {
			t.Errorf("got %#v, wanted nil err", err)
		}
	})

	t.Run("returns a convertor error", func(t *testing.T) {
		// ASSEMBLE
		beforeEach(t)
		defer afterEach()
		typeCacheMoq.onCall().FindPackage(".").returnResults("thispkg", nil)
		typeCacheMoq.onCall().Type(*ast.IdPath("PublicInterface", "."), false).
			returnResults(ifaceSpec1, "github.com/myshkin5/moqueries/generator", nil)
		ifaceFuncs := []generator.Func{{Name: "Func1", Params: func1Params}}
		newConverterFnMoq.onCall(generator.Type{
			TypeSpec:   ifaceSpec1,
			Funcs:      ifaceFuncs,
			InPkgPath:  "github.com/myshkin5/moqueries/generator",
			OutPkgPath: "thispkg_test",
		}, false).returnResults(converter1Moq.mock())
		converter1Moq.onCall().BaseStruct().returnResults(&dst.GenDecl{Specs: []dst.Spec{&dst.TypeSpec{
			Name: dst.NewIdent("pub-decl"),
		}}})
		converter1Moq.onCall().IsolationStruct("mock").
			returnResults(nil)
		converter1Moq.onCall().IsolationStruct("recorder").
			returnResults(nil)
		expectedErr := errors.New("bad convertor")
		converter1Moq.onCall().MethodStructs(ifaceFuncs[0]).
			returnResults(nil, expectedErr)

		req := generator.GenerateRequest{
			Types:       []string{"PublicInterface"},
			Export:      false,
			Destination: "file_test.go",
			Package:     "",
			Import:      ".",
			TestImport:  false,
		}

		// ACT
		fSet, file, err := gen.Generate(req)

		// ASSERT
		if err != expectedErr {
			t.Errorf("got %#v, wanted %#v", err, expectedErr)
		}
		if fSet != nil {
			t.Errorf("got %#v, wanted nil", fSet)
		}
		if file != nil {
			t.Errorf("got %#v, wanted nil", file)
		}
	})

	t.Run("loads tests types when requested", func(t *testing.T) {
		// ASSEMBLE
		beforeEach(t)
		defer afterEach()
		typeCacheMoq.onCall().FindPackage(".").returnResults("thispkg", nil)
		typeCacheMoq.onCall().Type(*ast.IdPath("PublicInterface", "."), true).
			returnResults(ifaceSpec1, "github.com/myshkin5/moqueries/generator", nil)
		typeCacheMoq.onCall().Type(*ast.IdPath("privateInterface", "."), true).
			returnResults(ifaceSpec2, "github.com/myshkin5/moqueries/generator", nil)

		iface1Funcs := []generator.Func{{Name: "Func1", Params: func1Params}}
		newConverterFnMoq.onCall(generator.Type{
			TypeSpec:   ifaceSpec1,
			Funcs:      iface1Funcs,
			InPkgPath:  "github.com/myshkin5/moqueries/generator",
			OutPkgPath: "thispkg_test",
		}, false).returnResults(converter1Moq.mock())
		converter1Moq.onCall().BaseStruct().returnResults(nil)
		converter1Moq.onCall().IsolationStruct("mock").
			returnResults(nil)
		converter1Moq.onCall().IsolationStruct("recorder").
			returnResults(nil)
		converter1Moq.onCall().MethodStructs(iface1Funcs[0]).
			returnResults(nil, nil)
		converter1Moq.onCall().NewFunc().
			returnResults(nil)
		converter1Moq.onCall().IsolationAccessor("mock", "mock").
			returnResults(nil)
		converter1Moq.onCall().MockMethod(iface1Funcs[0]).
			returnResults(nil)
		converter1Moq.onCall().IsolationAccessor("recorder", "onCall").
			returnResults(nil)
		converter1Moq.onCall().RecorderMethods(iface1Funcs[0]).
			returnResults(nil)
		converter1Moq.onCall().ResetMethod().
			returnResults(nil)
		converter1Moq.onCall().AssertMethod().
			returnResults(nil)

		var iface2Funcs []generator.Func
		newConverterFnMoq.onCall(generator.Type{
			TypeSpec:   ifaceSpec2,
			Funcs:      iface2Funcs,
			InPkgPath:  "github.com/myshkin5/moqueries/generator",
			OutPkgPath: "thispkg_test",
		}, false).returnResults(converter2Moq.mock())
		converter2Moq.onCall().BaseStruct().returnResults(nil)
		converter2Moq.onCall().IsolationStruct("mock").
			returnResults(nil)
		converter2Moq.onCall().IsolationStruct("recorder").
			returnResults(nil)
		converter2Moq.onCall().NewFunc().
			returnResults(nil)
		converter2Moq.onCall().IsolationAccessor("mock", "mock").
			returnResults(nil)
		converter2Moq.onCall().IsolationAccessor("recorder", "onCall").
			returnResults(nil)
		converter2Moq.onCall().ResetMethod().
			returnResults(nil)
		converter2Moq.onCall().AssertMethod().
			returnResults(nil)

		req := generator.GenerateRequest{
			Types:       []string{"PublicInterface", "privateInterface"},
			Export:      false,
			Destination: "file_test.go",
			Package:     "",
			Import:      ".",
			TestImport:  true,
		}

		// ACT
		_, _, err := gen.Generate(req)
		// ASSERT
		if err != nil {
			t.Errorf("got %#v, wanted nil err", err)
		}
	})

	t.Run("returns an error when the type cache returns an error", func(t *testing.T) {
		// ASSEMBLE
		beforeEach(t)
		defer afterEach()
		typeCacheMoq.onCall().FindPackage(".").returnResults("thispkg", nil)
		expectedErr := errors.New("bad cache")
		typeCacheMoq.onCall().Type(*ast.IdPath("BadInterface", "."), false).
			returnResults(nil, "", expectedErr)

		req := generator.GenerateRequest{
			Types:       []string{"BadInterface"},
			Export:      false,
			Destination: "file_test.go",
			Package:     "",
			Import:      ".",
			TestImport:  false,
		}

		// ACT
		fSet, file, err := gen.Generate(req)

		// ASSERT
		if err != expectedErr {
			t.Errorf("got %#v, wanted %#v", err, expectedErr)
		}
		if fSet != nil {
			t.Errorf("got %#v, wanted nil", fSet)
		}
		if file != nil {
			t.Errorf("got %#v, wanted nil", file)
		}
	})

	t.Run("returns an error when recursive lookups return an error", func(t *testing.T) {
		// ASSEMBLE
		beforeEach(t)
		defer afterEach()
		typeCacheMoq.onCall().FindPackage(".").returnResults("thispkg", nil)
		// PublicInterface embeds privateInterface
		ifaceMethods1.List = append(ifaceMethods1.List, &dst.Field{
			Type: &dst.Ident{
				Name: "privateInterface",
				Path: "github.com/myshkin5/moqueries/generator",
			},
		})
		typeCacheMoq.onCall().Type(*ast.IdPath("PublicInterface", "."), false).
			returnResults(ifaceSpec1, "github.com/myshkin5/moqueries/generator", nil)
		expectedErr := errors.New("bad cache")
		typeCacheMoq.onCall().Type(*ast.IdPath("privateInterface", "github.com/myshkin5/moqueries/generator"), false).
			returnResults(nil, "", expectedErr)

		req := generator.GenerateRequest{
			Types:       []string{"PublicInterface"},
			Export:      false,
			Destination: "file_test.go",
			Package:     "",
			Import:      ".",
			TestImport:  false,
		}

		// ACT
		fSet, file, err := gen.Generate(req)

		// ASSERT
		if err != expectedErr {
			t.Errorf("got %#v, wanted %#v", err, expectedErr)
		}
		if fSet != nil {
			t.Errorf("got %#v, wanted nil", fSet)
		}
		if file != nil {
			t.Errorf("got %#v, wanted nil", file)
		}
	})

	t.Run("returns an error when recursive function lookups return an error", func(t *testing.T) {
		// ASSEMBLE
		beforeEach(t)
		defer afterEach()
		typeCacheMoq.onCall().FindPackage(".").returnResults("thispkg", nil)
		// PublicInterface embeds privateInterface which embeds io.Reader
		ifaceMethods1.List = append(ifaceMethods1.List, &dst.Field{
			Type: &dst.Ident{
				Name: "privateInterface",
				Path: "github.com/myshkin5/moqueries/generator",
			},
		})
		ifaceMethods2.List = append(ifaceMethods2.List, &dst.Field{
			Type: &dst.Ident{
				Name: "Reader",
				Path: "io",
			},
		})
		typeCacheMoq.onCall().Type(*ast.IdPath("PublicInterface", "."), false).
			returnResults(ifaceSpec1, "github.com/myshkin5/moqueries/generator", nil)
		typeCacheMoq.onCall().Type(*ast.IdPath("privateInterface", "github.com/myshkin5/moqueries/generator"), false).
			returnResults(ifaceSpec2, "github.com/myshkin5/moqueries/generator", nil)
		expectedErr := errors.New("bad cache")
		typeCacheMoq.onCall().Type(*ast.IdPath("Reader", "io"), false).
			returnResults(nil, "", expectedErr)

		req := generator.GenerateRequest{
			Types:       []string{"PublicInterface"},
			Export:      false,
			Destination: "file_test.go",
			Package:     "",
			Import:      ".",
			TestImport:  false,
		}

		// ACT
		fSet, file, err := gen.Generate(req)

		// ASSERT
		if err != expectedErr {
			t.Errorf("got %#v, wanted %#v", err, expectedErr)
		}
		if fSet != nil {
			t.Errorf("got %#v, wanted nil", fSet)
		}
		if file != nil {
			t.Errorf("got %#v, wanted nil", file)
		}
	})

	t.Run("handles function types", func(t *testing.T) {
		// ASSEMBLE
		beforeEach(t)
		defer afterEach()
		typeCacheMoq.onCall().FindPackage(".").returnResults("thispkg", nil)
		typeCacheMoq.onCall().Type(*ast.IdPath("PublicFn", "."), false).
			returnResults(fnSpec, "github.com/myshkin5/moqueries/generator", nil)
		fnFuncs := []generator.Func{{Params: func1Params}}
		newConverterFnMoq.onCall(generator.Type{
			TypeSpec:   fnSpec,
			Funcs:      fnFuncs,
			InPkgPath:  "github.com/myshkin5/moqueries/generator",
			OutPkgPath: "thispkg_test",
		}, false).returnResults(converter1Moq.mock())
		converter1Moq.onCall().BaseStruct().returnResults(&dst.GenDecl{Specs: []dst.Spec{&dst.TypeSpec{
			Name: dst.NewIdent("pub-decl"),
		}}})
		converter1Moq.onCall().IsolationStruct("mock").
			returnResults(nil)
		converter1Moq.onCall().MethodStructs(fnFuncs[0]).
			returnResults(nil, nil)
		converter1Moq.onCall().NewFunc().
			returnResults(nil)
		converter1Moq.onCall().FuncClosure(fnFuncs[0]).
			returnResults(nil)
		converter1Moq.onCall().MockMethod(fnFuncs[0]).
			returnResults(nil)
		converter1Moq.onCall().RecorderMethods(fnFuncs[0]).
			returnResults(nil)
		converter1Moq.onCall().ResetMethod().
			returnResults(nil)
		converter1Moq.onCall().AssertMethod().
			returnResults(nil)

		req := generator.GenerateRequest{
			Types:       []string{"PublicFn"},
			Export:      false,
			Destination: "file_test.go",
			Package:     "",
			Import:      ".",
			TestImport:  false,
		}

		// ACT
		_, _, err := gen.Generate(req)
		// ASSERT
		if err != nil {
			t.Errorf("got %#v, wanted nil err", err)
		}
	})
}
