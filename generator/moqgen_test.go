package generator_test

import (
	"errors"
	"testing"

	"github.com/dave/dst"

	"github.com/myshkin5/moqueries/ast"
	"github.com/myshkin5/moqueries/generator"
	"github.com/myshkin5/moqueries/logs"
	"github.com/myshkin5/moqueries/moq"
)

func TestMoqGenerator(t *testing.T) {
	var (
		scene        *moq.Scene
		typeCacheMoq *moqTypeCache
		converterMoq *moqConverterer

		ifaceSpec1    *dst.TypeSpec
		ifaceSpec2    *dst.TypeSpec
		ifaceMethods1 *dst.FieldList
		ifaceMethods2 *dst.FieldList
		func1         *dst.Field
		func1Params   *dst.FieldList

		readFnType *dst.FuncType
		readerSpec *dst.TypeSpec

		fnSpec *dst.TypeSpec
	)

	beforeEach := func(t *testing.T) {
		logs.Init(false)

		if scene != nil {
			t.Fatal("afterEach not called")
		}
		scene = moq.NewScene(t)
		typeCacheMoq = newMoqTypeCache(scene, nil)
		converterMoq = newMoqConverterer(scene, nil)

		func1Params = &dst.FieldList{List: []*dst.Field{
			{
				Names: []*dst.Ident{dst.NewIdent("firstParm")},
				Type: &dst.StarExpr{X: &dst.SelectorExpr{
					X:   dst.NewIdent("cobra"),
					Sel: dst.NewIdent("Command"),
				}},
			},
			{Type: dst.NewIdent("string")},
			{
				Type: &dst.StarExpr{X: &dst.SelectorExpr{
					X:   dst.NewIdent("dst"),
					Sel: dst.NewIdent("InterfaceType"),
				}},
			},
		}}
		func1 = &dst.Field{
			Names: []*dst.Ident{dst.NewIdent("Func1")},
			Type:  &dst.FuncType{Params: func1Params, Results: nil},
		}
		ifaceMethods1 = &dst.FieldList{List: []*dst.Field{func1}}
		ifaceSpec1 = &dst.TypeSpec{
			Name: dst.NewIdent("PublicInterface"),
			Type: &dst.InterfaceType{Methods: ifaceMethods1},
		}
		ifaceMethods2 = &dst.FieldList{}
		ifaceSpec2 = &dst.TypeSpec{
			Name: dst.NewIdent("privateInterface"),
			Type: &dst.InterfaceType{Methods: ifaceMethods2},
		}

		readFnType = &dst.FuncType{
			Params: &dst.FieldList{List: []*dst.Field{{
				Names: []*dst.Ident{dst.NewIdent("p")},
				Type:  &dst.ArrayType{Elt: dst.NewIdent("byte")},
			}}},
			Results: &dst.FieldList{List: []*dst.Field{
				{
					Names: []*dst.Ident{dst.NewIdent("n")},
					Type:  dst.NewIdent("int"),
				},
				{
					Names: []*dst.Ident{dst.NewIdent("err")},
					Type:  dst.NewIdent("error"),
				},
			}},
		}
		readerSpec = &dst.TypeSpec{
			Name: &dst.Ident{Name: "Reader", Path: "io"},
			Type: &dst.InterfaceType{Methods: &dst.FieldList{
				List: []*dst.Field{{
					Names: []*dst.Ident{dst.NewIdent("Read")},
					Type:  readFnType,
				}},
			}},
		}

		fnSpec = &dst.TypeSpec{
			Name: dst.NewIdent("PublicFn"),
			Type: &dst.FuncType{Params: func1Params, Results: nil},
		}
	}

	afterEach := func() {
		scene.AssertExpectationsMet()
		scene = nil
	}

	t.Run("always returns a header comment", func(t *testing.T) {
		// ASSEMBLE
		beforeEach(t)
		gen := generator.New(false, "", "dir/file_test.go", typeCacheMoq.mock(), converterMoq.mock())

		// ACT
		_, file, err := gen.Generate(nil, ".", false)
		// ASSERT
		if err != nil {
			t.Errorf("got %#v, wanted nil err", err)
		}
		if file == nil {
			t.Errorf("got nil file, wanted not nil")
		}
		if len(file.Decs.Start) < 1 {
			t.Errorf("got %d, wanted > 0 len start", len(file.Decs.Start))
		}
		expectedStart := "// Code generated by Moqueries - https://github.com/myshkin5/moqueries - DO NOT EDIT!"
		if file.Decs.Start[0] != expectedStart {
			t.Errorf("got %s, wanted %s", file.Decs.Start[0], expectedStart)
		}
		afterEach()
	})

	t.Run("defaults a test package when not exported and the package isn't specified", func(t *testing.T) {
		// ASSEMBLE
		beforeEach(t)
		gen := generator.New(false, "", "dir/file_test.go", typeCacheMoq.mock(), converterMoq.mock())

		// ACT
		_, file, err := gen.Generate(nil, ".", false)
		// ASSERT
		if err != nil {
			t.Errorf("got %#v, wanted nil err", err)
		}
		if file.Name.Name != "dir_test" {
			t.Errorf("got %s, wanted dir_test", file.Name.Name)
		}
		afterEach()
	})

	t.Run("defaults a non-test package when exported and the package isn't specified", func(t *testing.T) {
		// ASSEMBLE
		beforeEach(t)
		gen := generator.New(true, "", "dir/file_test.go", typeCacheMoq.mock(), converterMoq.mock())

		// ACT
		_, file, err := gen.Generate(nil, ".", false)
		// ASSERT
		if err != nil {
			t.Errorf("got %#v, wanted nil err", err)
		}
		if file.Name.Name != "dir" {
			t.Errorf("got %s, wanted dir", file.Name.Name)
		}
		afterEach()
	})

	t.Run("can put mocks in parent packages when given a relative destination", func(t *testing.T) {
		// ASSEMBLE
		beforeEach(t)
		gen := generator.New(true, "", "../file_test.go", typeCacheMoq.mock(), converterMoq.mock())

		// ACT
		_, file, err := gen.Generate(nil, ".", false)
		// ASSERT
		if err != nil {
			t.Errorf("got %#v, wanted nil err", err)
		}
		if file.Name.Name != "moqueries" {
			t.Errorf("got %s, wanted moqueries", file.Name.Name)
		}
		afterEach()
	})

	t.Run("defaults the package to a test name based on the current"+
		" directory when it isn't specified and not exported", func(t *testing.T) {
		// ASSEMBLE
		beforeEach(t)
		gen := generator.New(false, "", "file_test.go", typeCacheMoq.mock(), converterMoq.mock())

		// ACT
		_, file, err := gen.Generate(nil, ".", false)
		// ASSERT
		if err != nil {
			t.Errorf("got %#v, wanted nil err", err)
		}
		if file.Name.Name != "generator_test" {
			t.Errorf("got %s, wanted generator_test", file.Name.Name)
		}
		afterEach()
	})

	t.Run("defaults the package to a non-test name based on the current"+
		" directory when it isn't specified and exported", func(t *testing.T) {
		// ASSEMBLE
		beforeEach(t)
		gen := generator.New(true, "", "file_test.go", typeCacheMoq.mock(), converterMoq.mock())

		// ACT
		_, file, err := gen.Generate(nil, ".", false)
		// ASSERT
		if err != nil {
			t.Errorf("got %#v, wanted nil err", err)
		}
		if file.Name.Name != "generator" {
			t.Errorf("got %s, wanted generator", file.Name.Name)
		}
		afterEach()
	})

	t.Run("recursively looks up nested interfaces", func(t *testing.T) {
		// ASSEMBLE
		beforeEach(t)
		// PublicInterface embeds privateInterface which embeds io.Reader
		ifaceMethods1.List = append(ifaceMethods1.List, &dst.Field{
			Type: &dst.Ident{
				Name: "privateInterface",
				Path: "github.com/myshkin5/moqueries/generator",
			},
		})
		ifaceMethods2.List = append(ifaceMethods2.List, &dst.Field{
			Type: &dst.Ident{
				Name: "Reader",
				Path: "io",
			},
		})
		typeCacheMoq.onCall().Type(*ast.IdPath("PublicInterface", "."), false).
			returnResults(ifaceSpec1, "github.com/myshkin5/moqueries/generator", nil)
		typeCacheMoq.onCall().Type(*ast.IdPath("privateInterface", "github.com/myshkin5/moqueries/generator"), false).
			returnResults(ifaceSpec2, "github.com/myshkin5/moqueries/generator", nil)
		typeCacheMoq.onCall().Type(*ast.IdPath("Reader", "io"), false).
			returnResults(readerSpec, "", nil)
		typeCacheMoq.onCall().Type(*ast.IdPath("privateInterface", "."), false).
			returnResults(ifaceSpec2, "github.com/myshkin5/moqueries/generator", nil)
		typeCacheMoq.onCall().Type(*ast.IdPath("Reader", "io"), false).
			returnResults(readerSpec, "", nil)
		ifaceFuncs := []generator.Func{
			{Name: "Func1", Params: func1Params},
			{
				Name:    "Read",
				Params:  readFnType.Params,
				Results: readFnType.Results,
			},
		}
		converterMoq.onCall().BaseStruct(ifaceSpec1, ifaceFuncs).
			returnResults(&dst.GenDecl{Specs: []dst.Spec{&dst.TypeSpec{
				Name: dst.NewIdent("pub-decl"),
			}}})
		converterMoq.onCall().IsolationStruct("PublicInterface", "mock").
			returnResults(nil)
		converterMoq.onCall().IsolationStruct("PublicInterface", "recorder").
			returnResults(nil)
		converterMoq.onCall().MethodStructs(ifaceSpec1, ifaceFuncs[0]).
			returnResults(nil, nil)
		converterMoq.onCall().MethodStructs(ifaceSpec1, ifaceFuncs[1]).
			returnResults(nil, nil)
		converterMoq.onCall().NewFunc(ifaceSpec1).
			returnResults(nil)
		converterMoq.onCall().IsolationAccessor(
			"PublicInterface", "mock", "mock").
			returnResults(nil)
		converterMoq.onCall().MockMethod("PublicInterface", ifaceFuncs[0]).
			returnResults(nil)
		converterMoq.onCall().MockMethod("PublicInterface", ifaceFuncs[1]).
			returnResults(nil)
		converterMoq.onCall().IsolationAccessor(
			"PublicInterface", "recorder", "onCall").
			returnResults(nil)
		converterMoq.onCall().RecorderMethods(
			"PublicInterface", ifaceFuncs[0]).
			returnResults(nil)
		converterMoq.onCall().RecorderMethods(
			"PublicInterface", ifaceFuncs[1]).
			returnResults(nil)
		converterMoq.onCall().ResetMethod(ifaceSpec1, ifaceFuncs).
			returnResults(nil)
		converterMoq.onCall().AssertMethod(ifaceSpec1, ifaceFuncs).
			returnResults(nil)
		iface2Funcs := []generator.Func{{
			Name:    "Read",
			Params:  readFnType.Params,
			Results: readFnType.Results,
		}}
		converterMoq.onCall().BaseStruct(ifaceSpec2, iface2Funcs).
			returnResults(nil)
		converterMoq.onCall().IsolationStruct("privateInterface", "mock").
			returnResults(nil)
		converterMoq.onCall().IsolationStruct("privateInterface", "recorder").
			returnResults(nil)
		converterMoq.onCall().MethodStructs(ifaceSpec2, iface2Funcs[0]).
			returnResults(nil, nil)
		converterMoq.onCall().NewFunc(ifaceSpec2).
			returnResults(nil)
		converterMoq.onCall().IsolationAccessor(
			"privateInterface", "mock", "mock").
			returnResults(nil)
		converterMoq.onCall().MockMethod("privateInterface", iface2Funcs[0]).
			returnResults(nil)
		converterMoq.onCall().IsolationAccessor(
			"privateInterface", "recorder", "onCall").
			returnResults(nil)
		converterMoq.onCall().RecorderMethods(
			"privateInterface", iface2Funcs[0]).
			returnResults(nil)
		converterMoq.onCall().ResetMethod(ifaceSpec2, iface2Funcs).
			returnResults(nil)
		converterMoq.onCall().AssertMethod(ifaceSpec2, iface2Funcs).
			returnResults(nil)

		gen := generator.New(false, "", "file_test.go", typeCacheMoq.mock(), converterMoq.mock())

		// ACT
		_, _, err := gen.Generate([]string{"PublicInterface", "privateInterface"}, ".", false)
		// ASSERT
		if err != nil {
			t.Errorf("got %#v, wanted nil err", err)
		}
		afterEach()
	})

	t.Run("successfully navigates type aliases", func(t *testing.T) {
		// ASSEMBLE
		beforeEach(t)

		ifaceSpec := &dst.TypeSpec{
			Name: dst.NewIdent("AliasType"),
			Type: ast.IdPath("Reader", "io"),
		}

		typeCacheMoq.onCall().Type(*ast.IdPath("AliasType", "."), false).
			returnResults(ifaceSpec, "github.com/myshkin5/moqueries/generator", nil)
		typeCacheMoq.onCall().Type(*ast.IdPath("Reader", "io"), false).
			returnResults(readerSpec, "", nil)

		ifaceFuncs := []generator.Func{
			{
				Name:    "Read",
				Params:  readFnType.Params,
				Results: readFnType.Results,
			},
		}
		converterMoq.onCall().BaseStruct(ifaceSpec, ifaceFuncs).
			returnResults(nil)
		converterMoq.onCall().IsolationStruct("AliasType", "mock").
			returnResults(nil)
		converterMoq.onCall().IsolationStruct("AliasType", "recorder").
			returnResults(nil)
		converterMoq.onCall().MethodStructs(ifaceSpec, ifaceFuncs[0]).
			returnResults(nil, nil)
		converterMoq.onCall().NewFunc(ifaceSpec).
			returnResults(nil)
		converterMoq.onCall().IsolationAccessor(
			"AliasType", "mock", "mock").
			returnResults(nil)
		converterMoq.onCall().MockMethod("AliasType", ifaceFuncs[0]).
			returnResults(nil)
		converterMoq.onCall().IsolationAccessor(
			"AliasType", "recorder", "onCall").
			returnResults(nil)
		converterMoq.onCall().RecorderMethods(
			"AliasType", ifaceFuncs[0]).
			returnResults(nil)
		converterMoq.onCall().ResetMethod(ifaceSpec, ifaceFuncs).
			returnResults(nil)
		converterMoq.onCall().AssertMethod(ifaceSpec, ifaceFuncs).
			returnResults(nil)

		gen := generator.New(false, "", "file_test.go", typeCacheMoq.mock(), converterMoq.mock())

		// ACT
		_, _, err := gen.Generate([]string{"AliasType"}, ".", false)
		// ASSERT
		if err != nil {
			t.Errorf("got %#v, wanted nil err", err)
		}
		afterEach()
	})

	t.Run("returns a convertor error", func(t *testing.T) {
		// ASSEMBLE
		beforeEach(t)
		typeCacheMoq.onCall().Type(*ast.IdPath("PublicInterface", "."), false).
			returnResults(ifaceSpec1, "github.com/myshkin5/moqueries/generator", nil)
		ifaceFuncs := []generator.Func{{Name: "Func1", Params: func1Params}}
		converterMoq.onCall().BaseStruct(ifaceSpec1, ifaceFuncs).
			returnResults(&dst.GenDecl{Specs: []dst.Spec{&dst.TypeSpec{
				Name: dst.NewIdent("pub-decl"),
			}}})
		converterMoq.onCall().IsolationStruct("PublicInterface", "mock").
			returnResults(nil)
		converterMoq.onCall().IsolationStruct("PublicInterface", "recorder").
			returnResults(nil)
		expectedErr := errors.New("bad convertor")
		converterMoq.onCall().MethodStructs(ifaceSpec1, ifaceFuncs[0]).
			returnResults(nil, expectedErr)

		gen := generator.New(false, "", "file_test.go", typeCacheMoq.mock(), converterMoq.mock())

		// ACT
		fSet, file, err := gen.Generate([]string{"PublicInterface"}, ".", false)

		// ASSERT
		if err != expectedErr {
			t.Errorf("got %#v, wanted %#v", err, expectedErr)
		}
		if fSet != nil {
			t.Errorf("got %#v, wanted nil", fSet)
		}
		if file != nil {
			t.Errorf("got %#v, wanted nil", file)
		}
		afterEach()
	})

	t.Run("loads tests types when requested", func(t *testing.T) {
		// ASSEMBLE
		beforeEach(t)
		typeCacheMoq.onCall().Type(*ast.IdPath("PublicInterface", "."), true).
			returnResults(ifaceSpec1, "github.com/myshkin5/moqueries/generator", nil)
		typeCacheMoq.onCall().Type(*ast.IdPath("privateInterface", "."), true).
			returnResults(ifaceSpec2, "github.com/myshkin5/moqueries/generator", nil)

		ifaceFuncs := []generator.Func{{Name: "Func1", Params: func1Params}}
		converterMoq.onCall().BaseStruct(ifaceSpec1, ifaceFuncs).
			returnResults(nil)
		converterMoq.onCall().IsolationStruct("PublicInterface", "mock").
			returnResults(nil)
		converterMoq.onCall().IsolationStruct("PublicInterface", "recorder").
			returnResults(nil)
		converterMoq.onCall().MethodStructs(ifaceSpec1, ifaceFuncs[0]).
			returnResults(nil, nil)
		converterMoq.onCall().NewFunc(ifaceSpec1).
			returnResults(nil)
		converterMoq.onCall().IsolationAccessor(
			"PublicInterface", "mock", "mock").
			returnResults(nil)
		converterMoq.onCall().MockMethod("PublicInterface", ifaceFuncs[0]).
			returnResults(nil)
		converterMoq.onCall().IsolationAccessor(
			"PublicInterface", "recorder", "onCall").
			returnResults(nil)
		converterMoq.onCall().RecorderMethods(
			"PublicInterface", ifaceFuncs[0]).
			returnResults(nil)
		converterMoq.onCall().ResetMethod(ifaceSpec1, ifaceFuncs).
			returnResults(nil)
		converterMoq.onCall().AssertMethod(ifaceSpec1, ifaceFuncs).
			returnResults(nil)

		converterMoq.onCall().BaseStruct(ifaceSpec2, []generator.Func{}).
			returnResults(nil)
		converterMoq.onCall().IsolationStruct("privateInterface", "mock").
			returnResults(nil)
		converterMoq.onCall().IsolationStruct("privateInterface", "recorder").
			returnResults(nil)
		converterMoq.onCall().NewFunc(ifaceSpec2).
			returnResults(nil)
		converterMoq.onCall().IsolationAccessor(
			"privateInterface", "mock", "mock").
			returnResults(nil)
		converterMoq.onCall().IsolationAccessor(
			"privateInterface", "recorder", "onCall").
			returnResults(nil)
		converterMoq.onCall().ResetMethod(ifaceSpec2, []generator.Func{}).
			returnResults(nil)
		converterMoq.onCall().AssertMethod(ifaceSpec2, []generator.Func{}).
			returnResults(nil)

		gen := generator.New(false, "", "file_test.go", typeCacheMoq.mock(), converterMoq.mock())

		// ACT
		_, _, err := gen.Generate([]string{"PublicInterface", "privateInterface"}, ".", true)
		// ASSERT
		if err != nil {
			t.Errorf("got %#v, wanted nil err", err)
		}
		afterEach()
	})

	t.Run("loads tests types when importing a test package", func(t *testing.T) {
		// ASSEMBLE
		beforeEach(t)
		pubId := ast.IdPath("PublicInterface", "github.com/myshkin5/moqueries/generator")
		typeCacheMoq.onCall().Type(*pubId, true).
			returnResults(ifaceSpec1, "github.com/myshkin5/moqueries/generator", nil)
		priId := ast.IdPath("privateInterface", "github.com/myshkin5/moqueries/generator")
		typeCacheMoq.onCall().Type(*priId, true).
			returnResults(ifaceSpec2, "github.com/myshkin5/moqueries/generator", nil)

		ifaceFuncs := []generator.Func{{Name: "Func1", Params: func1Params}}
		converterMoq.onCall().BaseStruct(ifaceSpec1, ifaceFuncs).
			returnResults(nil)
		converterMoq.onCall().IsolationStruct("PublicInterface", "mock").
			returnResults(nil)
		converterMoq.onCall().IsolationStruct("PublicInterface", "recorder").
			returnResults(nil)
		converterMoq.onCall().MethodStructs(ifaceSpec1, ifaceFuncs[0]).
			returnResults(nil, nil)
		converterMoq.onCall().NewFunc(ifaceSpec1).
			returnResults(nil)
		converterMoq.onCall().IsolationAccessor(
			"PublicInterface", "mock", "mock").
			returnResults(nil)
		converterMoq.onCall().MockMethod("PublicInterface", ifaceFuncs[0]).
			returnResults(nil)
		converterMoq.onCall().IsolationAccessor(
			"PublicInterface", "recorder", "onCall").
			returnResults(nil)
		converterMoq.onCall().RecorderMethods(
			"PublicInterface", ifaceFuncs[0]).
			returnResults(nil)
		converterMoq.onCall().ResetMethod(ifaceSpec1, ifaceFuncs).
			returnResults(nil)
		converterMoq.onCall().AssertMethod(ifaceSpec1, ifaceFuncs).
			returnResults(nil)

		converterMoq.onCall().BaseStruct(ifaceSpec2, []generator.Func{}).
			returnResults(nil)
		converterMoq.onCall().IsolationStruct("privateInterface", "mock").
			returnResults(nil)
		converterMoq.onCall().IsolationStruct("privateInterface", "recorder").
			returnResults(nil)
		converterMoq.onCall().NewFunc(ifaceSpec2).
			returnResults(nil)
		converterMoq.onCall().IsolationAccessor(
			"privateInterface", "mock", "mock").
			returnResults(nil)
		converterMoq.onCall().IsolationAccessor(
			"privateInterface", "recorder", "onCall").
			returnResults(nil)
		converterMoq.onCall().ResetMethod(ifaceSpec2, []generator.Func{}).
			returnResults(nil)
		converterMoq.onCall().AssertMethod(ifaceSpec2, []generator.Func{}).
			returnResults(nil)

		gen := generator.New(false, "", "file_test.go", typeCacheMoq.mock(), converterMoq.mock())

		// ACT
		_, _, err := gen.Generate(
			[]string{"PublicInterface", "privateInterface"},
			"github.com/myshkin5/moqueries/generator_test",
			false)
		// ASSERT
		if err != nil {
			t.Errorf("got %#v, wanted nil err", err)
		}
		afterEach()
	})

	t.Run("returns an error when the type cache returns an error", func(t *testing.T) {
		// ASSEMBLE
		beforeEach(t)
		expectedErr := errors.New("bad cache")
		typeCacheMoq.onCall().Type(*ast.IdPath("BadInterface", "."), false).
			returnResults(nil, "", expectedErr)

		gen := generator.New(false, "", "file_test.go", typeCacheMoq.mock(), converterMoq.mock())

		// ACT
		fSet, file, err := gen.Generate([]string{"BadInterface"}, ".", false)

		// ASSERT
		if err != expectedErr {
			t.Errorf("got %#v, wanted %#v", err, expectedErr)
		}
		if fSet != nil {
			t.Errorf("got %#v, wanted nil", fSet)
		}
		if file != nil {
			t.Errorf("got %#v, wanted nil", file)
		}
		afterEach()
	})

	t.Run("returns an error when recursive lookups return an error", func(t *testing.T) {
		// ASSEMBLE
		beforeEach(t)
		// PublicInterface embeds privateInterface
		ifaceMethods1.List = append(ifaceMethods1.List, &dst.Field{
			Type: &dst.Ident{
				Name: "privateInterface",
				Path: "github.com/myshkin5/moqueries/generator",
			},
		})
		typeCacheMoq.onCall().Type(*ast.IdPath("PublicInterface", "."), false).
			returnResults(ifaceSpec1, "github.com/myshkin5/moqueries/generator", nil)
		expectedErr := errors.New("bad cache")
		typeCacheMoq.onCall().Type(*ast.IdPath("privateInterface", "github.com/myshkin5/moqueries/generator"), false).
			returnResults(nil, "", expectedErr)

		gen := generator.New(false, "", "file_test.go", typeCacheMoq.mock(), converterMoq.mock())

		// ACT
		fSet, file, err := gen.Generate([]string{"PublicInterface"}, ".", false)

		// ASSERT
		if err != expectedErr {
			t.Errorf("got %#v, wanted %#v", err, expectedErr)
		}
		if fSet != nil {
			t.Errorf("got %#v, wanted nil", fSet)
		}
		if file != nil {
			t.Errorf("got %#v, wanted nil", file)
		}
		afterEach()
	})

	t.Run("returns an error when recursive function lookups return an error", func(t *testing.T) {
		// ASSEMBLE
		beforeEach(t)
		// PublicInterface embeds privateInterface which embeds io.Reader
		ifaceMethods1.List = append(ifaceMethods1.List, &dst.Field{
			Type: &dst.Ident{
				Name: "privateInterface",
				Path: "github.com/myshkin5/moqueries/generator",
			},
		})
		ifaceMethods2.List = append(ifaceMethods2.List, &dst.Field{
			Type: &dst.Ident{
				Name: "Reader",
				Path: "io",
			},
		})
		typeCacheMoq.onCall().Type(*ast.IdPath("PublicInterface", "."), false).
			returnResults(ifaceSpec1, "github.com/myshkin5/moqueries/generator", nil)
		typeCacheMoq.onCall().Type(*ast.IdPath("privateInterface", "github.com/myshkin5/moqueries/generator"), false).
			returnResults(ifaceSpec2, "github.com/myshkin5/moqueries/generator", nil)
		expectedErr := errors.New("bad cache")
		typeCacheMoq.onCall().Type(*ast.IdPath("Reader", "io"), false).
			returnResults(nil, "", expectedErr)

		gen := generator.New(false, "", "file_test.go", typeCacheMoq.mock(), converterMoq.mock())

		// ACT
		fSet, file, err := gen.Generate([]string{"PublicInterface"}, ".", false)

		// ASSERT
		if err != expectedErr {
			t.Errorf("got %#v, wanted %#v", err, expectedErr)
		}
		if fSet != nil {
			t.Errorf("got %#v, wanted nil", fSet)
		}
		if file != nil {
			t.Errorf("got %#v, wanted nil", file)
		}
		afterEach()
	})

	t.Run("handles function types", func(t *testing.T) {
		// ASSEMBLE
		beforeEach(t)
		typeCacheMoq.onCall().Type(*ast.IdPath("PublicFn", "."), false).
			returnResults(fnSpec, "github.com/myshkin5/moqueries/generator", nil)
		fnFuncs := []generator.Func{{Params: func1Params}}
		converterMoq.onCall().BaseStruct(fnSpec, fnFuncs).
			returnResults(&dst.GenDecl{Specs: []dst.Spec{&dst.TypeSpec{
				Name: dst.NewIdent("pub-decl"),
			}}})
		converterMoq.onCall().IsolationStruct("PublicFn", "mock").
			returnResults(nil)
		converterMoq.onCall().MethodStructs(fnSpec, fnFuncs[0]).
			returnResults(nil, nil)
		converterMoq.onCall().NewFunc(fnSpec).
			returnResults(nil)
		converterMoq.onCall().FuncClosure("PublicFn", "github.com/myshkin5/moqueries/generator", fnFuncs[0]).
			returnResults(nil)
		converterMoq.onCall().MockMethod("PublicFn", fnFuncs[0]).
			returnResults(nil)
		converterMoq.onCall().RecorderMethods("PublicFn", fnFuncs[0]).
			returnResults(nil)
		converterMoq.onCall().ResetMethod(fnSpec, fnFuncs).
			returnResults(nil)
		converterMoq.onCall().AssertMethod(fnSpec, fnFuncs).
			returnResults(nil)

		gen := generator.New(false, "", "file_test.go", typeCacheMoq.mock(), converterMoq.mock())

		// ACT
		_, _, err := gen.Generate([]string{"PublicFn"}, ".", false)
		// ASSERT
		if err != nil {
			t.Errorf("got %#v, wanted nil err", err)
		}
		afterEach()
	})
}
