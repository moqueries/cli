package generator_test

import (
	"errors"

	"github.com/dave/dst"
	. "github.com/onsi/ginkgo"
	. "github.com/onsi/gomega"

	"github.com/myshkin5/moqueries/ast"
	"github.com/myshkin5/moqueries/generator"
	"github.com/myshkin5/moqueries/logs"
	"github.com/myshkin5/moqueries/moq"
)

var _ = Describe("MoqGenerator", func() {
	var (
		scene        *moq.Scene
		typeCacheMoq *moqTypeCache
		converterMoq *moqConverterer

		ifaceSpec1    *dst.TypeSpec
		ifaceSpec2    *dst.TypeSpec
		ifaceMethods1 *dst.FieldList
		ifaceMethods2 *dst.FieldList
		func1         *dst.Field
		func1Params   *dst.FieldList

		readFnType *dst.FuncType
		readerSpec *dst.TypeSpec

		fnSpec *dst.TypeSpec
	)

	BeforeEach(func() {
		logs.Init(false)

		scene = moq.NewScene(GinkgoT())
		typeCacheMoq = newMoqTypeCache(scene, nil)
		converterMoq = newMoqConverterer(scene, nil)

		func1Params = &dst.FieldList{List: []*dst.Field{
			{
				Names: []*dst.Ident{dst.NewIdent("firstParm")},
				Type: &dst.StarExpr{X: &dst.SelectorExpr{
					X:   dst.NewIdent("cobra"),
					Sel: dst.NewIdent("Command"),
				}},
			},
			{Type: dst.NewIdent("string")},
			{
				Type: &dst.StarExpr{X: &dst.SelectorExpr{
					X:   dst.NewIdent("dst"),
					Sel: dst.NewIdent("InterfaceType"),
				}},
			},
		}}
		func1 = &dst.Field{
			Names: []*dst.Ident{dst.NewIdent("Func1")},
			Type:  &dst.FuncType{Params: func1Params, Results: nil},
		}
		ifaceMethods1 = &dst.FieldList{List: []*dst.Field{func1}}
		ifaceSpec1 = &dst.TypeSpec{
			Name: dst.NewIdent("PublicInterface"),
			Type: &dst.InterfaceType{Methods: ifaceMethods1},
		}
		ifaceMethods2 = &dst.FieldList{}
		ifaceSpec2 = &dst.TypeSpec{
			Name: dst.NewIdent("privateInterface"),
			Type: &dst.InterfaceType{Methods: ifaceMethods2},
		}

		readFnType = &dst.FuncType{
			Params: &dst.FieldList{List: []*dst.Field{{
				Names: []*dst.Ident{dst.NewIdent("p")},
				Type:  &dst.ArrayType{Elt: dst.NewIdent("byte")},
			}}},
			Results: &dst.FieldList{List: []*dst.Field{
				{
					Names: []*dst.Ident{dst.NewIdent("n")},
					Type:  dst.NewIdent("int"),
				},
				{
					Names: []*dst.Ident{dst.NewIdent("err")},
					Type:  dst.NewIdent("error"),
				},
			}},
		}
		readerSpec = &dst.TypeSpec{
			Name: &dst.Ident{Name: "Reader", Path: "io"},
			Type: &dst.InterfaceType{Methods: &dst.FieldList{
				List: []*dst.Field{{
					Names: []*dst.Ident{dst.NewIdent("Read")},
					Type:  readFnType,
				}},
			}},
		}

		fnSpec = &dst.TypeSpec{
			Name: dst.NewIdent("PublicFn"),
			Type: &dst.FuncType{Params: func1Params, Results: nil},
		}
	})

	AfterEach(func() {
		scene.AssertExpectationsMet()
	})

	It("always returns a header comment", func() {
		// ASSEMBLE
		gen := generator.New(false, "", "dir/file_test.go", typeCacheMoq.mock(), converterMoq.mock())

		// ACT
		_, file, err := gen.Generate(nil, ".", false)

		// ASSERT
		Expect(err).NotTo(HaveOccurred())
		Expect(file).NotTo(BeNil())
		Expect(len(file.Decs.Start)).To(BeNumerically(">", 0))
		Expect(file.Decs.Start[0]).To(Equal(
			"// Code generated by Moqueries - https://github.com/myshkin5/moqueries - DO NOT EDIT!",
		))
	})

	It("defaults a test package when not exported and the package isn't specified", func() {
		// ASSEMBLE
		gen := generator.New(false, "", "dir/file_test.go", typeCacheMoq.mock(), converterMoq.mock())

		// ACT
		_, file, err := gen.Generate(nil, ".", false)

		// ASSERT
		Expect(err).NotTo(HaveOccurred())
		Expect(file.Name.Name).To(Equal("dir_test"))
	})

	It("defaults a non-test package when exported and the package isn't specified", func() {
		// ASSEMBLE
		gen := generator.New(true, "", "dir/file_test.go", typeCacheMoq.mock(), converterMoq.mock())

		// ACT
		_, file, err := gen.Generate(nil, ".", false)

		// ASSERT
		Expect(err).NotTo(HaveOccurred())
		Expect(file.Name.Name).To(Equal("dir"))
	})

	It("can put mocks in parent packages when given a relative destination", func() {
		// ASSEMBLE
		gen := generator.New(true, "", "../file_test.go", typeCacheMoq.mock(), converterMoq.mock())

		// ACT
		_, file, err := gen.Generate(nil, ".", false)

		// ASSERT
		Expect(err).NotTo(HaveOccurred())
		Expect(file.Name.Name).To(Equal("moqueries"))
	})

	It("defaults the package to a test name based on the current"+
		" directory when it isn't specified and not exported", func() {
		// ASSEMBLE
		gen := generator.New(false, "", "file_test.go", typeCacheMoq.mock(), converterMoq.mock())

		// ACT
		_, file, err := gen.Generate(nil, ".", false)

		// ASSERT
		Expect(err).NotTo(HaveOccurred())
		Expect(file.Name.Name).To(Equal("generator_test"))
	})

	It("defaults the package to a non-test name based on the current"+
		" directory when it isn't specified and exported", func() {
		// ASSEMBLE
		gen := generator.New(true, "", "file_test.go", typeCacheMoq.mock(), converterMoq.mock())

		// ACT
		_, file, err := gen.Generate(nil, ".", false)

		// ASSERT
		Expect(err).NotTo(HaveOccurred())
		Expect(file.Name.Name).To(Equal("generator"))
	})

	It("recursively looks up nested interfaces", func() {
		// ASSEMBLE
		// PublicInterface embeds privateInterface which embeds io.Reader
		ifaceMethods1.List = append(ifaceMethods1.List, &dst.Field{
			Type: &dst.Ident{
				Name: "privateInterface",
				Path: "github.com/myshkin5/moqueries/generator",
			},
		})
		ifaceMethods2.List = append(ifaceMethods2.List, &dst.Field{
			Type: &dst.Ident{
				Name: "Reader",
				Path: "io",
			},
		})
		typeCacheMoq.onCall().Type(*ast.IdPath("PublicInterface", "."), false).
			returnResults(ifaceSpec1, "github.com/myshkin5/moqueries/generator", nil)
		typeCacheMoq.onCall().Type(*ast.IdPath("privateInterface", "github.com/myshkin5/moqueries/generator"), false).
			returnResults(ifaceSpec2, "github.com/myshkin5/moqueries/generator", nil)
		typeCacheMoq.onCall().Type(*ast.IdPath("Reader", "io"), false).
			returnResults(readerSpec, "", nil)
		typeCacheMoq.onCall().Type(*ast.IdPath("privateInterface", "."), false).
			returnResults(ifaceSpec2, "github.com/myshkin5/moqueries/generator", nil)
		typeCacheMoq.onCall().Type(*ast.IdPath("Reader", "io"), false).
			returnResults(readerSpec, "", nil)
		ifaceFuncs := []generator.Func{
			{Name: "Func1", Params: func1Params},
			{
				Name:    "Read",
				Params:  readFnType.Params,
				Results: readFnType.Results,
			},
		}
		converterMoq.onCall().BaseStruct(ifaceSpec1, ifaceFuncs).
			returnResults(&dst.GenDecl{Specs: []dst.Spec{&dst.TypeSpec{
				Name: dst.NewIdent("pub-decl"),
			}}})
		converterMoq.onCall().IsolationStruct("PublicInterface", "mock").
			returnResults(nil)
		converterMoq.onCall().IsolationStruct("PublicInterface", "recorder").
			returnResults(nil)
		converterMoq.onCall().MethodStructs(ifaceSpec1, ifaceFuncs[0]).
			returnResults(nil, nil)
		converterMoq.onCall().MethodStructs(ifaceSpec1, ifaceFuncs[1]).
			returnResults(nil, nil)
		converterMoq.onCall().NewFunc(ifaceSpec1).
			returnResults(nil)
		converterMoq.onCall().IsolationAccessor(
			"PublicInterface", "mock", "mock").
			returnResults(nil)
		converterMoq.onCall().MockMethod("PublicInterface", ifaceFuncs[0]).
			returnResults(nil)
		converterMoq.onCall().MockMethod("PublicInterface", ifaceFuncs[1]).
			returnResults(nil)
		converterMoq.onCall().IsolationAccessor(
			"PublicInterface", "recorder", "onCall").
			returnResults(nil)
		converterMoq.onCall().RecorderMethods(
			"PublicInterface", ifaceFuncs[0]).
			returnResults(nil)
		converterMoq.onCall().RecorderMethods(
			"PublicInterface", ifaceFuncs[1]).
			returnResults(nil)
		converterMoq.onCall().ResetMethod(ifaceSpec1, ifaceFuncs).
			returnResults(nil)
		converterMoq.onCall().AssertMethod(ifaceSpec1, ifaceFuncs).
			returnResults(nil)
		iface2Funcs := []generator.Func{{
			Name:    "Read",
			Params:  readFnType.Params,
			Results: readFnType.Results,
		}}
		converterMoq.onCall().BaseStruct(ifaceSpec2, iface2Funcs).
			returnResults(nil)
		converterMoq.onCall().IsolationStruct("privateInterface", "mock").
			returnResults(nil)
		converterMoq.onCall().IsolationStruct("privateInterface", "recorder").
			returnResults(nil)
		converterMoq.onCall().MethodStructs(ifaceSpec2, iface2Funcs[0]).
			returnResults(nil, nil)
		converterMoq.onCall().NewFunc(ifaceSpec2).
			returnResults(nil)
		converterMoq.onCall().IsolationAccessor(
			"privateInterface", "mock", "mock").
			returnResults(nil)
		converterMoq.onCall().MockMethod("privateInterface", iface2Funcs[0]).
			returnResults(nil)
		converterMoq.onCall().IsolationAccessor(
			"privateInterface", "recorder", "onCall").
			returnResults(nil)
		converterMoq.onCall().RecorderMethods(
			"privateInterface", iface2Funcs[0]).
			returnResults(nil)
		converterMoq.onCall().ResetMethod(ifaceSpec2, iface2Funcs).
			returnResults(nil)
		converterMoq.onCall().AssertMethod(ifaceSpec2, iface2Funcs).
			returnResults(nil)

		gen := generator.New(false, "", "file_test.go", typeCacheMoq.mock(), converterMoq.mock())

		// ACT
		_, _, err := gen.Generate([]string{"PublicInterface", "privateInterface"}, ".", false)

		// ASSERT
		Expect(err).NotTo(HaveOccurred())
	})

	It("returns a convertor error", func() {
		// ASSEMBLE
		typeCacheMoq.onCall().Type(*ast.IdPath("PublicInterface", "."), false).
			returnResults(ifaceSpec1, "github.com/myshkin5/moqueries/generator", nil)
		ifaceFuncs := []generator.Func{{Name: "Func1", Params: func1Params}}
		converterMoq.onCall().BaseStruct(ifaceSpec1, ifaceFuncs).
			returnResults(&dst.GenDecl{Specs: []dst.Spec{&dst.TypeSpec{
				Name: dst.NewIdent("pub-decl"),
			}}})
		converterMoq.onCall().IsolationStruct("PublicInterface", "mock").
			returnResults(nil)
		converterMoq.onCall().IsolationStruct("PublicInterface", "recorder").
			returnResults(nil)
		expectedErr := errors.New("bad convertor")
		converterMoq.onCall().MethodStructs(ifaceSpec1, ifaceFuncs[0]).
			returnResults(nil, expectedErr)

		gen := generator.New(false, "", "file_test.go", typeCacheMoq.mock(), converterMoq.mock())

		// ACT
		fSet, file, err := gen.Generate([]string{"PublicInterface"}, ".", false)

		// ASSERT
		Expect(err).To(Equal(expectedErr))
		Expect(fSet).To(BeNil())
		Expect(file).To(BeNil())
	})

	It("loads tests types when requested", func() {
		// ASSEMBLE
		typeCacheMoq.onCall().Type(*ast.IdPath("PublicInterface", "."), true).
			returnResults(ifaceSpec1, "github.com/myshkin5/moqueries/generator", nil)
		typeCacheMoq.onCall().Type(*ast.IdPath("privateInterface", "."), true).
			returnResults(ifaceSpec2, "github.com/myshkin5/moqueries/generator", nil)

		ifaceFuncs := []generator.Func{{Name: "Func1", Params: func1Params}}
		converterMoq.onCall().BaseStruct(ifaceSpec1, ifaceFuncs).
			returnResults(nil)
		converterMoq.onCall().IsolationStruct("PublicInterface", "mock").
			returnResults(nil)
		converterMoq.onCall().IsolationStruct("PublicInterface", "recorder").
			returnResults(nil)
		converterMoq.onCall().MethodStructs(ifaceSpec1, ifaceFuncs[0]).
			returnResults(nil, nil)
		converterMoq.onCall().NewFunc(ifaceSpec1).
			returnResults(nil)
		converterMoq.onCall().IsolationAccessor(
			"PublicInterface", "mock", "mock").
			returnResults(nil)
		converterMoq.onCall().MockMethod("PublicInterface", ifaceFuncs[0]).
			returnResults(nil)
		converterMoq.onCall().IsolationAccessor(
			"PublicInterface", "recorder", "onCall").
			returnResults(nil)
		converterMoq.onCall().RecorderMethods(
			"PublicInterface", ifaceFuncs[0]).
			returnResults(nil)
		converterMoq.onCall().ResetMethod(ifaceSpec1, ifaceFuncs).
			returnResults(nil)
		converterMoq.onCall().AssertMethod(ifaceSpec1, ifaceFuncs).
			returnResults(nil)

		converterMoq.onCall().BaseStruct(ifaceSpec2, []generator.Func{}).
			returnResults(nil)
		converterMoq.onCall().IsolationStruct("privateInterface", "mock").
			returnResults(nil)
		converterMoq.onCall().IsolationStruct("privateInterface", "recorder").
			returnResults(nil)
		converterMoq.onCall().NewFunc(ifaceSpec2).
			returnResults(nil)
		converterMoq.onCall().IsolationAccessor(
			"privateInterface", "mock", "mock").
			returnResults(nil)
		converterMoq.onCall().IsolationAccessor(
			"privateInterface", "recorder", "onCall").
			returnResults(nil)
		converterMoq.onCall().ResetMethod(ifaceSpec2, []generator.Func{}).
			returnResults(nil)
		converterMoq.onCall().AssertMethod(ifaceSpec2, []generator.Func{}).
			returnResults(nil)

		gen := generator.New(false, "", "file_test.go", typeCacheMoq.mock(), converterMoq.mock())

		// ACT
		_, _, err := gen.Generate([]string{"PublicInterface", "privateInterface"}, ".", true)

		// ASSERT
		Expect(err).NotTo(HaveOccurred())
	})

	It("loads tests types when importing a test package", func() {
		// ASSEMBLE
		pubId := ast.IdPath("PublicInterface", "github.com/myshkin5/moqueries/generator")
		typeCacheMoq.onCall().Type(*pubId, true).
			returnResults(ifaceSpec1, "github.com/myshkin5/moqueries/generator", nil)
		priId := ast.IdPath("privateInterface", "github.com/myshkin5/moqueries/generator")
		typeCacheMoq.onCall().Type(*priId, true).
			returnResults(ifaceSpec2, "github.com/myshkin5/moqueries/generator", nil)

		ifaceFuncs := []generator.Func{{Name: "Func1", Params: func1Params}}
		converterMoq.onCall().BaseStruct(ifaceSpec1, ifaceFuncs).
			returnResults(nil)
		converterMoq.onCall().IsolationStruct("PublicInterface", "mock").
			returnResults(nil)
		converterMoq.onCall().IsolationStruct("PublicInterface", "recorder").
			returnResults(nil)
		converterMoq.onCall().MethodStructs(ifaceSpec1, ifaceFuncs[0]).
			returnResults(nil, nil)
		converterMoq.onCall().NewFunc(ifaceSpec1).
			returnResults(nil)
		converterMoq.onCall().IsolationAccessor(
			"PublicInterface", "mock", "mock").
			returnResults(nil)
		converterMoq.onCall().MockMethod("PublicInterface", ifaceFuncs[0]).
			returnResults(nil)
		converterMoq.onCall().IsolationAccessor(
			"PublicInterface", "recorder", "onCall").
			returnResults(nil)
		converterMoq.onCall().RecorderMethods(
			"PublicInterface", ifaceFuncs[0]).
			returnResults(nil)
		converterMoq.onCall().ResetMethod(ifaceSpec1, ifaceFuncs).
			returnResults(nil)
		converterMoq.onCall().AssertMethod(ifaceSpec1, ifaceFuncs).
			returnResults(nil)

		converterMoq.onCall().BaseStruct(ifaceSpec2, []generator.Func{}).
			returnResults(nil)
		converterMoq.onCall().IsolationStruct("privateInterface", "mock").
			returnResults(nil)
		converterMoq.onCall().IsolationStruct("privateInterface", "recorder").
			returnResults(nil)
		converterMoq.onCall().NewFunc(ifaceSpec2).
			returnResults(nil)
		converterMoq.onCall().IsolationAccessor(
			"privateInterface", "mock", "mock").
			returnResults(nil)
		converterMoq.onCall().IsolationAccessor(
			"privateInterface", "recorder", "onCall").
			returnResults(nil)
		converterMoq.onCall().ResetMethod(ifaceSpec2, []generator.Func{}).
			returnResults(nil)
		converterMoq.onCall().AssertMethod(ifaceSpec2, []generator.Func{}).
			returnResults(nil)

		gen := generator.New(false, "", "file_test.go", typeCacheMoq.mock(), converterMoq.mock())

		// ACT
		_, _, err := gen.Generate(
			[]string{"PublicInterface", "privateInterface"},
			"github.com/myshkin5/moqueries/generator_test",
			false)

		// ASSERT
		Expect(err).NotTo(HaveOccurred())
	})

	It("returns an error when the type cache returns an error", func() {
		// ASSEMBLE
		expectedErr := errors.New("bad cache")
		typeCacheMoq.onCall().Type(*ast.IdPath("BadInterface", "."), false).
			returnResults(nil, "", expectedErr)

		gen := generator.New(false, "", "file_test.go", typeCacheMoq.mock(), converterMoq.mock())

		// ACT
		fSet, file, err := gen.Generate([]string{"BadInterface"}, ".", false)

		// ASSERT
		Expect(err).To(Equal(expectedErr))
		Expect(fSet).To(BeNil())
		Expect(file).To(BeNil())
	})

	It("returns an error when recursive lookups return an error", func() {
		// ASSEMBLE
		// PublicInterface embeds privateInterface
		ifaceMethods1.List = append(ifaceMethods1.List, &dst.Field{
			Type: &dst.Ident{
				Name: "privateInterface",
				Path: "github.com/myshkin5/moqueries/generator",
			},
		})
		typeCacheMoq.onCall().Type(*ast.IdPath("PublicInterface", "."), false).
			returnResults(ifaceSpec1, "github.com/myshkin5/moqueries/generator", nil)
		expectedErr := errors.New("bad cache")
		typeCacheMoq.onCall().Type(*ast.IdPath("privateInterface", "github.com/myshkin5/moqueries/generator"), false).
			returnResults(nil, "", expectedErr)

		gen := generator.New(false, "", "file_test.go", typeCacheMoq.mock(), converterMoq.mock())

		// ACT
		fSet, file, err := gen.Generate([]string{"PublicInterface"}, ".", false)

		// ASSERT
		Expect(err).To(Equal(expectedErr))
		Expect(fSet).To(BeNil())
		Expect(file).To(BeNil())
	})

	It("returns an error when recursive function lookups return an error", func() {
		// ASSEMBLE
		// PublicInterface embeds privateInterface which embeds io.Reader
		ifaceMethods1.List = append(ifaceMethods1.List, &dst.Field{
			Type: &dst.Ident{
				Name: "privateInterface",
				Path: "github.com/myshkin5/moqueries/generator",
			},
		})
		ifaceMethods2.List = append(ifaceMethods2.List, &dst.Field{
			Type: &dst.Ident{
				Name: "Reader",
				Path: "io",
			},
		})
		typeCacheMoq.onCall().Type(*ast.IdPath("PublicInterface", "."), false).
			returnResults(ifaceSpec1, "github.com/myshkin5/moqueries/generator", nil)
		typeCacheMoq.onCall().Type(*ast.IdPath("privateInterface", "github.com/myshkin5/moqueries/generator"), false).
			returnResults(ifaceSpec2, "github.com/myshkin5/moqueries/generator", nil)
		expectedErr := errors.New("bad cache")
		typeCacheMoq.onCall().Type(*ast.IdPath("Reader", "io"), false).
			returnResults(nil, "", expectedErr)

		gen := generator.New(false, "", "file_test.go", typeCacheMoq.mock(), converterMoq.mock())

		// ACT
		fSet, file, err := gen.Generate([]string{"PublicInterface"}, ".", false)

		// ASSERT
		Expect(err).To(Equal(expectedErr))
		Expect(fSet).To(BeNil())
		Expect(file).To(BeNil())
	})

	It("handles function types", func() {
		// ASSEMBLE
		typeCacheMoq.onCall().Type(*ast.IdPath("PublicFn", "."), false).
			returnResults(fnSpec, "github.com/myshkin5/moqueries/generator", nil)
		fnFuncs := []generator.Func{{Params: func1Params}}
		converterMoq.onCall().BaseStruct(fnSpec, fnFuncs).
			returnResults(&dst.GenDecl{Specs: []dst.Spec{&dst.TypeSpec{
				Name: dst.NewIdent("pub-decl"),
			}}})
		converterMoq.onCall().IsolationStruct("PublicFn", "mock").
			returnResults(nil)
		converterMoq.onCall().MethodStructs(fnSpec, fnFuncs[0]).
			returnResults(nil, nil)
		converterMoq.onCall().NewFunc(fnSpec).
			returnResults(nil)
		converterMoq.onCall().FuncClosure("PublicFn", "github.com/myshkin5/moqueries/generator", fnFuncs[0]).
			returnResults(nil)
		converterMoq.onCall().MockMethod("PublicFn", fnFuncs[0]).
			returnResults(nil)
		converterMoq.onCall().RecorderMethods("PublicFn", fnFuncs[0]).
			returnResults(nil)
		converterMoq.onCall().ResetMethod(fnSpec, fnFuncs).
			returnResults(nil)
		converterMoq.onCall().AssertMethod(fnSpec, fnFuncs).
			returnResults(nil)

		gen := generator.New(false, "", "file_test.go", typeCacheMoq.mock(), converterMoq.mock())

		// ACT
		_, _, err := gen.Generate([]string{"PublicFn"}, ".", false)

		// ASSERT
		Expect(err).NotTo(HaveOccurred())
	})
})
