package generator_test

import (
	"errors"
	"testing"

	"github.com/dave/dst"

	"github.com/myshkin5/moqueries/ast"
	"github.com/myshkin5/moqueries/generator"
	"github.com/myshkin5/moqueries/logs"
	"github.com/myshkin5/moqueries/moq"
)

func TestMoqGenerator(t *testing.T) {
	var (
		scene            *moq.Scene
		findPackageFnMoq *moqFindPackageFn
		typeCacheMoq     *moqTypeCache
		converterMoq     *moqConverterer

		ifaceSpec1    *dst.TypeSpec
		ifaceSpec2    *dst.TypeSpec
		ifaceMethods1 *dst.FieldList
		ifaceMethods2 *dst.FieldList
		func1         *dst.Field
		func1Params   *dst.FieldList

		readFnType *dst.FuncType
		readerSpec *dst.TypeSpec

		fnSpec *dst.TypeSpec
	)

	beforeEach := func(t *testing.T) {
		logs.Init(false)

		if scene != nil {
			t.Fatal("afterEach not called")
		}
		scene = moq.NewScene(t)
		findPackageFnMoq = newMoqFindPackageFn(scene, nil)
		typeCacheMoq = newMoqTypeCache(scene, nil)
		converterMoq = newMoqConverterer(scene, nil)

		func1Params = &dst.FieldList{List: []*dst.Field{
			{
				Names: []*dst.Ident{dst.NewIdent("firstParm")},
				Type: &dst.StarExpr{X: &dst.SelectorExpr{
					X:   dst.NewIdent("cobra"),
					Sel: dst.NewIdent("Command"),
				}},
			},
			{Type: dst.NewIdent("string")},
			{
				Type: &dst.StarExpr{X: &dst.SelectorExpr{
					X:   dst.NewIdent("dst"),
					Sel: dst.NewIdent("InterfaceType"),
				}},
			},
		}}
		func1 = &dst.Field{
			Names: []*dst.Ident{dst.NewIdent("Func1")},
			Type:  &dst.FuncType{Params: func1Params, Results: nil},
		}
		ifaceMethods1 = &dst.FieldList{List: []*dst.Field{func1}}
		ifaceSpec1 = &dst.TypeSpec{
			Name: dst.NewIdent("PublicInterface"),
			Type: &dst.InterfaceType{Methods: ifaceMethods1},
		}
		ifaceMethods2 = &dst.FieldList{}
		ifaceSpec2 = &dst.TypeSpec{
			Name: dst.NewIdent("privateInterface"),
			Type: &dst.InterfaceType{Methods: ifaceMethods2},
		}

		readFnType = &dst.FuncType{
			Params: &dst.FieldList{List: []*dst.Field{{
				Names: []*dst.Ident{dst.NewIdent("p")},
				Type:  &dst.ArrayType{Elt: dst.NewIdent("byte")},
			}}},
			Results: &dst.FieldList{List: []*dst.Field{
				{
					Names: []*dst.Ident{dst.NewIdent("n")},
					Type:  dst.NewIdent("int"),
				},
				{
					Names: []*dst.Ident{dst.NewIdent("err")},
					Type:  dst.NewIdent("error"),
				},
			}},
		}
		readerSpec = &dst.TypeSpec{
			Name: &dst.Ident{Name: "Reader", Path: "io"},
			Type: &dst.InterfaceType{Methods: &dst.FieldList{
				List: []*dst.Field{{
					Names: []*dst.Ident{dst.NewIdent("Read")},
					Type:  readFnType,
				}},
			}},
		}

		fnSpec = &dst.TypeSpec{
			Name: dst.NewIdent("PublicFn"),
			Type: &dst.FuncType{Params: func1Params, Results: nil},
		}
	}

	afterEach := func() {
		scene.AssertExpectationsMet()
		scene = nil
	}

	newGenerator := func(export bool, dest string) *generator.MoqGenerator {
		return generator.New(
			export,
			"",
			dest,
			findPackageFnMoq.mock(),
			typeCacheMoq.mock(),
			converterMoq.mock())
	}

	t.Run("always returns a header comment", func(t *testing.T) {
		// ASSEMBLE
		beforeEach(t)
		defer afterEach()
		gen := newGenerator(false, "dir/file_test.go")

		findPackageFnMoq.onCall("dir").returnResults("dir", nil)

		// ACT
		_, file, err := gen.Generate(nil, ".", false)
		// ASSERT
		if err != nil {
			t.Errorf("got %#v, wanted nil err", err)
		}
		if file == nil {
			t.Fatalf("got nil file, wanted not nil")
		}
		if len(file.Decs.Start) < 1 {
			t.Errorf("got %d, wanted > 0 len start", len(file.Decs.Start))
		}
		expectedStart := "// Code generated by Moqueries - https://github.com/myshkin5/moqueries - DO NOT EDIT!"
		if file.Decs.Start[0] != expectedStart {
			t.Errorf("got %s, wanted %s", file.Decs.Start[0], expectedStart)
		}
	})

	t.Run("defaults a test package when not exported and the package isn't specified", func(t *testing.T) {
		// ASSEMBLE
		beforeEach(t)
		defer afterEach()
		gen := newGenerator(false, "dir/file_test.go")

		findPackageFnMoq.onCall("dir").returnResults("dir", nil)

		// ACT
		_, file, err := gen.Generate(nil, ".", false)
		// ASSERT
		if err != nil {
			t.Errorf("got %#v, wanted nil err", err)
		}
		if file.Name.Name != "dir_test" {
			t.Errorf("got %s, wanted dir_test", file.Name.Name)
		}
	})

	t.Run("defaults a non-test package when exported and the package isn't specified", func(t *testing.T) {
		// ASSEMBLE
		beforeEach(t)
		defer afterEach()
		gen := newGenerator(true, "dir/file_test.go")

		findPackageFnMoq.onCall("dir").returnResults("dir", nil)

		// ACT
		_, file, err := gen.Generate(nil, ".", false)
		// ASSERT
		if err != nil {
			t.Errorf("got %#v, wanted nil err", err)
		}
		if file.Name.Name != "dir" {
			t.Errorf("got %s, wanted dir", file.Name.Name)
		}
	})

	t.Run("can put mocks in parent packages when given a relative destination", func(t *testing.T) {
		// ASSEMBLE
		beforeEach(t)
		defer afterEach()
		gen := newGenerator(true, "../file_test.go")

		findPackageFnMoq.onCall("..").returnResults("otherpkg", nil)

		// ACT
		_, file, err := gen.Generate(nil, ".", false)
		// ASSERT
		if err != nil {
			t.Errorf("got %#v, wanted nil err", err)
		}
		if file.Name.Name != "otherpkg" {
			t.Errorf("got %s, wanted otherpkg", file.Name.Name)
		}
	})

	t.Run("defaults the package to a test name based on the current"+
		" directory when it isn't specified and not exported", func(t *testing.T) {
		// ASSEMBLE
		beforeEach(t)
		defer afterEach()
		gen := newGenerator(false, "file_test.go")

		findPackageFnMoq.onCall(".").returnResults("thispkg", nil)

		// ACT
		_, file, err := gen.Generate(nil, ".", false)
		// ASSERT
		if err != nil {
			t.Errorf("got %#v, wanted nil err", err)
		}
		if file.Name.Name != "thispkg_test" {
			t.Errorf("got %s, wanted generator_test", file.Name.Name)
		}
	})

	t.Run("defaults the package to a non-test name based on the current"+
		" directory when it isn't specified and exported", func(t *testing.T) {
		// ASSEMBLE
		beforeEach(t)
		defer afterEach()
		gen := newGenerator(true, "file_test.go")

		findPackageFnMoq.onCall(".").returnResults("thispkg", nil)

		// ACT
		_, file, err := gen.Generate(nil, ".", false)
		// ASSERT
		if err != nil {
			t.Errorf("got %#v, wanted nil err", err)
		}
		if file.Name.Name != "thispkg" {
			t.Errorf("got %s, wanted generator", file.Name.Name)
		}
	})

	t.Run("recursively looks up nested interfaces", func(t *testing.T) {
		// ASSEMBLE
		beforeEach(t)
		defer afterEach()
		findPackageFnMoq.onCall(".").returnResults("thispkg", nil)
		// PublicInterface embeds privateInterface which embeds io.Reader
		ifaceMethods1.List = append(ifaceMethods1.List, &dst.Field{
			Type: &dst.Ident{
				Name: "privateInterface",
				Path: "github.com/myshkin5/moqueries/generator",
			},
		})
		ifaceMethods2.List = append(ifaceMethods2.List, &dst.Field{
			Type: &dst.Ident{
				Name: "Reader",
				Path: "io",
			},
		})
		typeCacheMoq.onCall().Type(*ast.IdPath("PublicInterface", "."), false).
			returnResults(ifaceSpec1, "github.com/myshkin5/moqueries/generator", nil)
		typeCacheMoq.onCall().Type(*ast.IdPath("privateInterface", "github.com/myshkin5/moqueries/generator"), false).
			returnResults(ifaceSpec2, "github.com/myshkin5/moqueries/generator", nil)
		typeCacheMoq.onCall().Type(*ast.IdPath("Reader", "io"), false).
			returnResults(readerSpec, "", nil)
		typeCacheMoq.onCall().Type(*ast.IdPath("privateInterface", "."), false).
			returnResults(ifaceSpec2, "github.com/myshkin5/moqueries/generator", nil)
		typeCacheMoq.onCall().Type(*ast.IdPath("Reader", "io"), false).
			returnResults(readerSpec, "", nil)
		ifaceFuncs := []generator.Func{
			{Name: "Func1", Params: func1Params},
			{
				Name:    "Read",
				Params:  readFnType.Params,
				Results: readFnType.Results,
			},
		}
		converterMoq.onCall().BaseStruct(ifaceSpec1, ifaceFuncs).
			returnResults(&dst.GenDecl{Specs: []dst.Spec{&dst.TypeSpec{
				Name: dst.NewIdent("pub-decl"),
			}}})
		converterMoq.onCall().IsolationStruct("PublicInterface", "mock").
			returnResults(nil)
		converterMoq.onCall().IsolationStruct("PublicInterface", "recorder").
			returnResults(nil)
		converterMoq.onCall().MethodStructs(ifaceSpec1, ifaceFuncs[0]).
			returnResults(nil, nil)
		converterMoq.onCall().MethodStructs(ifaceSpec1, ifaceFuncs[1]).
			returnResults(nil, nil)
		converterMoq.onCall().NewFunc(ifaceSpec1, ifaceFuncs).
			returnResults(nil)
		converterMoq.onCall().IsolationAccessor(
			"PublicInterface", "mock", "mock").
			returnResults(nil)
		converterMoq.onCall().MockMethod("PublicInterface", ifaceFuncs[0]).
			returnResults(nil)
		converterMoq.onCall().MockMethod("PublicInterface", ifaceFuncs[1]).
			returnResults(nil)
		converterMoq.onCall().IsolationAccessor(
			"PublicInterface", "recorder", "onCall").
			returnResults(nil)
		converterMoq.onCall().RecorderMethods(
			"PublicInterface", ifaceFuncs[0]).
			returnResults(nil)
		converterMoq.onCall().RecorderMethods(
			"PublicInterface", ifaceFuncs[1]).
			returnResults(nil)
		converterMoq.onCall().ResetMethod(ifaceSpec1, ifaceFuncs).
			returnResults(nil)
		converterMoq.onCall().AssertMethod(ifaceSpec1, ifaceFuncs).
			returnResults(nil)
		iface2Funcs := []generator.Func{{
			Name:    "Read",
			Params:  readFnType.Params,
			Results: readFnType.Results,
		}}
		converterMoq.onCall().BaseStruct(ifaceSpec2, iface2Funcs).
			returnResults(nil)
		converterMoq.onCall().IsolationStruct("privateInterface", "mock").
			returnResults(nil)
		converterMoq.onCall().IsolationStruct("privateInterface", "recorder").
			returnResults(nil)
		converterMoq.onCall().MethodStructs(ifaceSpec2, iface2Funcs[0]).
			returnResults(nil, nil)
		converterMoq.onCall().NewFunc(ifaceSpec2, iface2Funcs).
			returnResults(nil)
		converterMoq.onCall().IsolationAccessor(
			"privateInterface", "mock", "mock").
			returnResults(nil)
		converterMoq.onCall().MockMethod("privateInterface", iface2Funcs[0]).
			returnResults(nil)
		converterMoq.onCall().IsolationAccessor(
			"privateInterface", "recorder", "onCall").
			returnResults(nil)
		converterMoq.onCall().RecorderMethods(
			"privateInterface", iface2Funcs[0]).
			returnResults(nil)
		converterMoq.onCall().ResetMethod(ifaceSpec2, iface2Funcs).
			returnResults(nil)
		converterMoq.onCall().AssertMethod(ifaceSpec2, iface2Funcs).
			returnResults(nil)

		gen := newGenerator(false, "file_test.go")

		// ACT
		_, _, err := gen.Generate([]string{"PublicInterface", "privateInterface"}, ".", false)
		// ASSERT
		if err != nil {
			t.Errorf("got %#v, wanted nil err", err)
		}
	})

	t.Run("successfully navigates type aliases", func(t *testing.T) {
		// ASSEMBLE
		beforeEach(t)
		defer afterEach()

		findPackageFnMoq.onCall(".").returnResults("thispkg", nil)

		ifaceSpec := &dst.TypeSpec{
			Name: dst.NewIdent("AliasType"),
			Type: ast.IdPath("Reader", "io"),
		}

		typeCacheMoq.onCall().Type(*ast.IdPath("AliasType", "."), false).
			returnResults(ifaceSpec, "github.com/myshkin5/moqueries/generator", nil)
		typeCacheMoq.onCall().Type(*ast.IdPath("Reader", "io"), false).
			returnResults(readerSpec, "", nil)

		ifaceFuncs := []generator.Func{
			{
				Name:    "Read",
				Params:  readFnType.Params,
				Results: readFnType.Results,
			},
		}
		converterMoq.onCall().BaseStruct(ifaceSpec, ifaceFuncs).
			returnResults(nil)
		converterMoq.onCall().IsolationStruct("AliasType", "mock").
			returnResults(nil)
		converterMoq.onCall().IsolationStruct("AliasType", "recorder").
			returnResults(nil)
		converterMoq.onCall().MethodStructs(ifaceSpec, ifaceFuncs[0]).
			returnResults(nil, nil)
		converterMoq.onCall().NewFunc(ifaceSpec, ifaceFuncs).
			returnResults(nil)
		converterMoq.onCall().IsolationAccessor(
			"AliasType", "mock", "mock").
			returnResults(nil)
		converterMoq.onCall().MockMethod("AliasType", ifaceFuncs[0]).
			returnResults(nil)
		converterMoq.onCall().IsolationAccessor(
			"AliasType", "recorder", "onCall").
			returnResults(nil)
		converterMoq.onCall().RecorderMethods(
			"AliasType", ifaceFuncs[0]).
			returnResults(nil)
		converterMoq.onCall().ResetMethod(ifaceSpec, ifaceFuncs).
			returnResults(nil)
		converterMoq.onCall().AssertMethod(ifaceSpec, ifaceFuncs).
			returnResults(nil)

		gen := newGenerator(false, "file_test.go")

		// ACT
		_, _, err := gen.Generate([]string{"AliasType"}, ".", false)
		// ASSERT
		if err != nil {
			t.Errorf("got %#v, wanted nil err", err)
		}
	})

	t.Run("returns a convertor error", func(t *testing.T) {
		// ASSEMBLE
		beforeEach(t)
		defer afterEach()
		findPackageFnMoq.onCall(".").returnResults("thispkg", nil)
		typeCacheMoq.onCall().Type(*ast.IdPath("PublicInterface", "."), false).
			returnResults(ifaceSpec1, "github.com/myshkin5/moqueries/generator", nil)
		ifaceFuncs := []generator.Func{{Name: "Func1", Params: func1Params}}
		converterMoq.onCall().BaseStruct(ifaceSpec1, ifaceFuncs).
			returnResults(&dst.GenDecl{Specs: []dst.Spec{&dst.TypeSpec{
				Name: dst.NewIdent("pub-decl"),
			}}})
		converterMoq.onCall().IsolationStruct("PublicInterface", "mock").
			returnResults(nil)
		converterMoq.onCall().IsolationStruct("PublicInterface", "recorder").
			returnResults(nil)
		expectedErr := errors.New("bad convertor")
		converterMoq.onCall().MethodStructs(ifaceSpec1, ifaceFuncs[0]).
			returnResults(nil, expectedErr)

		gen := newGenerator(false, "file_test.go")

		// ACT
		fSet, file, err := gen.Generate([]string{"PublicInterface"}, ".", false)

		// ASSERT
		if err != expectedErr {
			t.Errorf("got %#v, wanted %#v", err, expectedErr)
		}
		if fSet != nil {
			t.Errorf("got %#v, wanted nil", fSet)
		}
		if file != nil {
			t.Errorf("got %#v, wanted nil", file)
		}
	})

	t.Run("loads tests types when requested", func(t *testing.T) {
		// ASSEMBLE
		beforeEach(t)
		defer afterEach()
		findPackageFnMoq.onCall(".").returnResults("thispkg", nil)
		typeCacheMoq.onCall().Type(*ast.IdPath("PublicInterface", "."), true).
			returnResults(ifaceSpec1, "github.com/myshkin5/moqueries/generator", nil)
		typeCacheMoq.onCall().Type(*ast.IdPath("privateInterface", "."), true).
			returnResults(ifaceSpec2, "github.com/myshkin5/moqueries/generator", nil)

		iface1Funcs := []generator.Func{{Name: "Func1", Params: func1Params}}
		converterMoq.onCall().BaseStruct(ifaceSpec1, iface1Funcs).
			returnResults(nil)
		converterMoq.onCall().IsolationStruct("PublicInterface", "mock").
			returnResults(nil)
		converterMoq.onCall().IsolationStruct("PublicInterface", "recorder").
			returnResults(nil)
		converterMoq.onCall().MethodStructs(ifaceSpec1, iface1Funcs[0]).
			returnResults(nil, nil)
		converterMoq.onCall().NewFunc(ifaceSpec1, iface1Funcs).
			returnResults(nil)
		converterMoq.onCall().IsolationAccessor(
			"PublicInterface", "mock", "mock").
			returnResults(nil)
		converterMoq.onCall().MockMethod("PublicInterface", iface1Funcs[0]).
			returnResults(nil)
		converterMoq.onCall().IsolationAccessor(
			"PublicInterface", "recorder", "onCall").
			returnResults(nil)
		converterMoq.onCall().RecorderMethods(
			"PublicInterface", iface1Funcs[0]).
			returnResults(nil)
		converterMoq.onCall().ResetMethod(ifaceSpec1, iface1Funcs).
			returnResults(nil)
		converterMoq.onCall().AssertMethod(ifaceSpec1, iface1Funcs).
			returnResults(nil)

		var iface2Funcs []generator.Func
		converterMoq.onCall().BaseStruct(ifaceSpec2, iface2Funcs).
			returnResults(nil)
		converterMoq.onCall().IsolationStruct("privateInterface", "mock").
			returnResults(nil)
		converterMoq.onCall().IsolationStruct("privateInterface", "recorder").
			returnResults(nil)
		converterMoq.onCall().NewFunc(ifaceSpec2, iface2Funcs).
			returnResults(nil)
		converterMoq.onCall().IsolationAccessor(
			"privateInterface", "mock", "mock").
			returnResults(nil)
		converterMoq.onCall().IsolationAccessor(
			"privateInterface", "recorder", "onCall").
			returnResults(nil)
		converterMoq.onCall().ResetMethod(ifaceSpec2, iface2Funcs).
			returnResults(nil)
		converterMoq.onCall().AssertMethod(ifaceSpec2, iface2Funcs).
			returnResults(nil)

		gen := newGenerator(false, "file_test.go")

		// ACT
		_, _, err := gen.Generate([]string{"PublicInterface", "privateInterface"}, ".", true)
		// ASSERT
		if err != nil {
			t.Errorf("got %#v, wanted nil err", err)
		}
	})

	t.Run("loads tests types when importing a test package", func(t *testing.T) {
		// ASSEMBLE
		beforeEach(t)
		defer afterEach()
		findPackageFnMoq.onCall(".").returnResults("thispkg", nil)
		pubId := ast.IdPath("PublicInterface", "github.com/myshkin5/moqueries/generator")
		typeCacheMoq.onCall().Type(*pubId, true).
			returnResults(ifaceSpec1, "github.com/myshkin5/moqueries/generator", nil)
		priId := ast.IdPath("privateInterface", "github.com/myshkin5/moqueries/generator")
		typeCacheMoq.onCall().Type(*priId, true).
			returnResults(ifaceSpec2, "github.com/myshkin5/moqueries/generator", nil)

		iface1Funcs := []generator.Func{{Name: "Func1", Params: func1Params}}
		converterMoq.onCall().BaseStruct(ifaceSpec1, iface1Funcs).
			returnResults(nil)
		converterMoq.onCall().IsolationStruct("PublicInterface", "mock").
			returnResults(nil)
		converterMoq.onCall().IsolationStruct("PublicInterface", "recorder").
			returnResults(nil)
		converterMoq.onCall().MethodStructs(ifaceSpec1, iface1Funcs[0]).
			returnResults(nil, nil)
		converterMoq.onCall().NewFunc(ifaceSpec1, iface1Funcs).
			returnResults(nil)
		converterMoq.onCall().IsolationAccessor(
			"PublicInterface", "mock", "mock").
			returnResults(nil)
		converterMoq.onCall().MockMethod("PublicInterface", iface1Funcs[0]).
			returnResults(nil)
		converterMoq.onCall().IsolationAccessor(
			"PublicInterface", "recorder", "onCall").
			returnResults(nil)
		converterMoq.onCall().RecorderMethods(
			"PublicInterface", iface1Funcs[0]).
			returnResults(nil)
		converterMoq.onCall().ResetMethod(ifaceSpec1, iface1Funcs).
			returnResults(nil)
		converterMoq.onCall().AssertMethod(ifaceSpec1, iface1Funcs).
			returnResults(nil)

		var iface2Funcs []generator.Func
		converterMoq.onCall().BaseStruct(ifaceSpec2, iface2Funcs).
			returnResults(nil)
		converterMoq.onCall().IsolationStruct("privateInterface", "mock").
			returnResults(nil)
		converterMoq.onCall().IsolationStruct("privateInterface", "recorder").
			returnResults(nil)
		converterMoq.onCall().NewFunc(ifaceSpec2, iface2Funcs).
			returnResults(nil)
		converterMoq.onCall().IsolationAccessor(
			"privateInterface", "mock", "mock").
			returnResults(nil)
		converterMoq.onCall().IsolationAccessor(
			"privateInterface", "recorder", "onCall").
			returnResults(nil)
		converterMoq.onCall().ResetMethod(ifaceSpec2, []generator.Func{}).
			returnResults(nil)
		converterMoq.onCall().AssertMethod(ifaceSpec2, []generator.Func{}).
			returnResults(nil)

		gen := newGenerator(false, "file_test.go")

		// ACT
		_, _, err := gen.Generate(
			[]string{"PublicInterface", "privateInterface"},
			"github.com/myshkin5/moqueries/generator_test",
			false)
		// ASSERT
		if err != nil {
			t.Errorf("got %#v, wanted nil err", err)
		}
	})

	t.Run("returns an error when the type cache returns an error", func(t *testing.T) {
		// ASSEMBLE
		beforeEach(t)
		defer afterEach()
		findPackageFnMoq.onCall(".").returnResults("thispkg", nil)
		expectedErr := errors.New("bad cache")
		typeCacheMoq.onCall().Type(*ast.IdPath("BadInterface", "."), false).
			returnResults(nil, "", expectedErr)

		gen := newGenerator(false, "file_test.go")

		// ACT
		fSet, file, err := gen.Generate([]string{"BadInterface"}, ".", false)

		// ASSERT
		if err != expectedErr {
			t.Errorf("got %#v, wanted %#v", err, expectedErr)
		}
		if fSet != nil {
			t.Errorf("got %#v, wanted nil", fSet)
		}
		if file != nil {
			t.Errorf("got %#v, wanted nil", file)
		}
	})

	t.Run("returns an error when recursive lookups return an error", func(t *testing.T) {
		// ASSEMBLE
		beforeEach(t)
		defer afterEach()
		findPackageFnMoq.onCall(".").returnResults("thispkg", nil)
		// PublicInterface embeds privateInterface
		ifaceMethods1.List = append(ifaceMethods1.List, &dst.Field{
			Type: &dst.Ident{
				Name: "privateInterface",
				Path: "github.com/myshkin5/moqueries/generator",
			},
		})
		typeCacheMoq.onCall().Type(*ast.IdPath("PublicInterface", "."), false).
			returnResults(ifaceSpec1, "github.com/myshkin5/moqueries/generator", nil)
		expectedErr := errors.New("bad cache")
		typeCacheMoq.onCall().Type(*ast.IdPath("privateInterface", "github.com/myshkin5/moqueries/generator"), false).
			returnResults(nil, "", expectedErr)

		gen := newGenerator(false, "file_test.go")

		// ACT
		fSet, file, err := gen.Generate([]string{"PublicInterface"}, ".", false)

		// ASSERT
		if err != expectedErr {
			t.Errorf("got %#v, wanted %#v", err, expectedErr)
		}
		if fSet != nil {
			t.Errorf("got %#v, wanted nil", fSet)
		}
		if file != nil {
			t.Errorf("got %#v, wanted nil", file)
		}
	})

	t.Run("returns an error when recursive function lookups return an error", func(t *testing.T) {
		// ASSEMBLE
		beforeEach(t)
		defer afterEach()
		findPackageFnMoq.onCall(".").returnResults("thispkg", nil)
		// PublicInterface embeds privateInterface which embeds io.Reader
		ifaceMethods1.List = append(ifaceMethods1.List, &dst.Field{
			Type: &dst.Ident{
				Name: "privateInterface",
				Path: "github.com/myshkin5/moqueries/generator",
			},
		})
		ifaceMethods2.List = append(ifaceMethods2.List, &dst.Field{
			Type: &dst.Ident{
				Name: "Reader",
				Path: "io",
			},
		})
		typeCacheMoq.onCall().Type(*ast.IdPath("PublicInterface", "."), false).
			returnResults(ifaceSpec1, "github.com/myshkin5/moqueries/generator", nil)
		typeCacheMoq.onCall().Type(*ast.IdPath("privateInterface", "github.com/myshkin5/moqueries/generator"), false).
			returnResults(ifaceSpec2, "github.com/myshkin5/moqueries/generator", nil)
		expectedErr := errors.New("bad cache")
		typeCacheMoq.onCall().Type(*ast.IdPath("Reader", "io"), false).
			returnResults(nil, "", expectedErr)

		gen := newGenerator(false, "file_test.go")

		// ACT
		fSet, file, err := gen.Generate([]string{"PublicInterface"}, ".", false)

		// ASSERT
		if err != expectedErr {
			t.Errorf("got %#v, wanted %#v", err, expectedErr)
		}
		if fSet != nil {
			t.Errorf("got %#v, wanted nil", fSet)
		}
		if file != nil {
			t.Errorf("got %#v, wanted nil", file)
		}
	})

	t.Run("handles function types", func(t *testing.T) {
		// ASSEMBLE
		beforeEach(t)
		defer afterEach()
		findPackageFnMoq.onCall(".").returnResults("thispkg", nil)
		typeCacheMoq.onCall().Type(*ast.IdPath("PublicFn", "."), false).
			returnResults(fnSpec, "github.com/myshkin5/moqueries/generator", nil)
		fnFuncs := []generator.Func{{Params: func1Params}}
		converterMoq.onCall().BaseStruct(fnSpec, fnFuncs).
			returnResults(&dst.GenDecl{Specs: []dst.Spec{&dst.TypeSpec{
				Name: dst.NewIdent("pub-decl"),
			}}})
		converterMoq.onCall().IsolationStruct("PublicFn", "mock").
			returnResults(nil)
		converterMoq.onCall().MethodStructs(fnSpec, fnFuncs[0]).
			returnResults(nil, nil)
		converterMoq.onCall().NewFunc(fnSpec, fnFuncs).
			returnResults(nil)
		converterMoq.onCall().FuncClosure("PublicFn", "github.com/myshkin5/moqueries/generator", fnFuncs[0]).
			returnResults(nil)
		converterMoq.onCall().MockMethod("PublicFn", fnFuncs[0]).
			returnResults(nil)
		converterMoq.onCall().RecorderMethods("PublicFn", fnFuncs[0]).
			returnResults(nil)
		converterMoq.onCall().ResetMethod(fnSpec, fnFuncs).
			returnResults(nil)
		converterMoq.onCall().AssertMethod(fnSpec, fnFuncs).
			returnResults(nil)

		gen := newGenerator(false, "file_test.go")

		// ACT
		_, _, err := gen.Generate([]string{"PublicFn"}, ".", false)
		// ASSERT
		if err != nil {
			t.Errorf("got %#v, wanted nil err", err)
		}
	})
}
