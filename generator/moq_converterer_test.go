// Code generated by Moqueries - https://moqueries.org - DO NOT EDIT.

package generator_test

import (
	"fmt"

	"github.com/dave/dst"
	"moqueries.org/cli/generator"
	"moqueries.org/runtime/hash"
	"moqueries.org/runtime/impl"
	"moqueries.org/runtime/moq"
)

// The following type assertion assures that generator.Converterer is mocked
// completely
var _ generator.Converterer = (*moqConverterer_mock)(nil)

// moqConverterer holds the state of a moq of the Converterer type
type moqConverterer struct {
	moq *moqConverterer_mock

	moq_BaseDecls *impl.Moq[
		*moqConverterer_BaseDecls_adaptor,
		moqConverterer_BaseDecls_params,
		moqConverterer_BaseDecls_paramsKey,
		moqConverterer_BaseDecls_results,
	]
	moq_MockStructs *impl.Moq[
		*moqConverterer_MockStructs_adaptor,
		moqConverterer_MockStructs_params,
		moqConverterer_MockStructs_paramsKey,
		moqConverterer_MockStructs_results,
	]
	moq_MethodStructs *impl.Moq[
		*moqConverterer_MethodStructs_adaptor,
		moqConverterer_MethodStructs_params,
		moqConverterer_MethodStructs_paramsKey,
		moqConverterer_MethodStructs_results,
	]
	moq_NewFunc *impl.Moq[
		*moqConverterer_NewFunc_adaptor,
		moqConverterer_NewFunc_params,
		moqConverterer_NewFunc_paramsKey,
		moqConverterer_NewFunc_results,
	]
	moq_IsolationAccessor *impl.Moq[
		*moqConverterer_IsolationAccessor_adaptor,
		moqConverterer_IsolationAccessor_params,
		moqConverterer_IsolationAccessor_paramsKey,
		moqConverterer_IsolationAccessor_results,
	]
	moq_FuncClosure *impl.Moq[
		*moqConverterer_FuncClosure_adaptor,
		moqConverterer_FuncClosure_params,
		moqConverterer_FuncClosure_paramsKey,
		moqConverterer_FuncClosure_results,
	]
	moq_MockMethod *impl.Moq[
		*moqConverterer_MockMethod_adaptor,
		moqConverterer_MockMethod_params,
		moqConverterer_MockMethod_paramsKey,
		moqConverterer_MockMethod_results,
	]
	moq_RecorderMethods *impl.Moq[
		*moqConverterer_RecorderMethods_adaptor,
		moqConverterer_RecorderMethods_params,
		moqConverterer_RecorderMethods_paramsKey,
		moqConverterer_RecorderMethods_results,
	]
	moq_ResetMethod *impl.Moq[
		*moqConverterer_ResetMethod_adaptor,
		moqConverterer_ResetMethod_params,
		moqConverterer_ResetMethod_paramsKey,
		moqConverterer_ResetMethod_results,
	]
	moq_AssertMethod *impl.Moq[
		*moqConverterer_AssertMethod_adaptor,
		moqConverterer_AssertMethod_params,
		moqConverterer_AssertMethod_paramsKey,
		moqConverterer_AssertMethod_results,
	]

	runtime moqConverterer_runtime
}

// moqConverterer_mock isolates the mock interface of the Converterer type
type moqConverterer_mock struct {
	moq *moqConverterer
}

// moqConverterer_recorder isolates the recorder interface of the Converterer
// type
type moqConverterer_recorder struct {
	moq *moqConverterer
}

// moqConverterer_runtime holds runtime configuration for the Converterer type
type moqConverterer_runtime struct {
	parameterIndexing struct {
		BaseDecls         moqConverterer_BaseDecls_paramIndexing
		MockStructs       moqConverterer_MockStructs_paramIndexing
		MethodStructs     moqConverterer_MethodStructs_paramIndexing
		NewFunc           moqConverterer_NewFunc_paramIndexing
		IsolationAccessor moqConverterer_IsolationAccessor_paramIndexing
		FuncClosure       moqConverterer_FuncClosure_paramIndexing
		MockMethod        moqConverterer_MockMethod_paramIndexing
		RecorderMethods   moqConverterer_RecorderMethods_paramIndexing
		ResetMethod       moqConverterer_ResetMethod_paramIndexing
		AssertMethod      moqConverterer_AssertMethod_paramIndexing
	}
}

// moqConverterer_BaseDecls_adaptor adapts moqConverterer as needed by the
// runtime
type moqConverterer_BaseDecls_adaptor struct {
	moq *moqConverterer
}

// moqConverterer_BaseDecls_params holds the params of the Converterer type
type moqConverterer_BaseDecls_params struct{}

// moqConverterer_BaseDecls_paramsKey holds the map key params of the
// Converterer type
type moqConverterer_BaseDecls_paramsKey struct {
	params struct{}
	hashes struct{}
}

// moqConverterer_BaseDecls_results holds the results of the Converterer type
type moqConverterer_BaseDecls_results struct {
	baseDecls []dst.Decl
	err       error
}

// moqConverterer_BaseDecls_paramIndexing holds the parameter indexing runtime
// configuration for the Converterer type
type moqConverterer_BaseDecls_paramIndexing struct{}

// moqConverterer_BaseDecls_doFn defines the type of function needed when
// calling andDo for the Converterer type
type moqConverterer_BaseDecls_doFn func()

// moqConverterer_BaseDecls_doReturnFn defines the type of function needed when
// calling doReturnResults for the Converterer type
type moqConverterer_BaseDecls_doReturnFn func() (baseDecls []dst.Decl, err error)

// moqConverterer_BaseDecls_recorder routes recorded function calls to the
// moqConverterer moq
type moqConverterer_BaseDecls_recorder struct {
	recorder *impl.Recorder[
		*moqConverterer_BaseDecls_adaptor,
		moqConverterer_BaseDecls_params,
		moqConverterer_BaseDecls_paramsKey,
		moqConverterer_BaseDecls_results,
	]
}

// moqConverterer_BaseDecls_anyParams isolates the any params functions of the
// Converterer type
type moqConverterer_BaseDecls_anyParams struct {
	recorder *moqConverterer_BaseDecls_recorder
}

// moqConverterer_MockStructs_adaptor adapts moqConverterer as needed by the
// runtime
type moqConverterer_MockStructs_adaptor struct {
	moq *moqConverterer
}

// moqConverterer_MockStructs_params holds the params of the Converterer type
type moqConverterer_MockStructs_params struct{}

// moqConverterer_MockStructs_paramsKey holds the map key params of the
// Converterer type
type moqConverterer_MockStructs_paramsKey struct {
	params struct{}
	hashes struct{}
}

// moqConverterer_MockStructs_results holds the results of the Converterer type
type moqConverterer_MockStructs_results struct {
	structDecls []dst.Decl
	err         error
}

// moqConverterer_MockStructs_paramIndexing holds the parameter indexing
// runtime configuration for the Converterer type
type moqConverterer_MockStructs_paramIndexing struct{}

// moqConverterer_MockStructs_doFn defines the type of function needed when
// calling andDo for the Converterer type
type moqConverterer_MockStructs_doFn func()

// moqConverterer_MockStructs_doReturnFn defines the type of function needed
// when calling doReturnResults for the Converterer type
type moqConverterer_MockStructs_doReturnFn func() (structDecls []dst.Decl, err error)

// moqConverterer_MockStructs_recorder routes recorded function calls to the
// moqConverterer moq
type moqConverterer_MockStructs_recorder struct {
	recorder *impl.Recorder[
		*moqConverterer_MockStructs_adaptor,
		moqConverterer_MockStructs_params,
		moqConverterer_MockStructs_paramsKey,
		moqConverterer_MockStructs_results,
	]
}

// moqConverterer_MockStructs_anyParams isolates the any params functions of
// the Converterer type
type moqConverterer_MockStructs_anyParams struct {
	recorder *moqConverterer_MockStructs_recorder
}

// moqConverterer_MethodStructs_adaptor adapts moqConverterer as needed by the
// runtime
type moqConverterer_MethodStructs_adaptor struct {
	moq *moqConverterer
}

// moqConverterer_MethodStructs_params holds the params of the Converterer type
type moqConverterer_MethodStructs_params struct{ fn generator.Func }

// moqConverterer_MethodStructs_paramsKey holds the map key params of the
// Converterer type
type moqConverterer_MethodStructs_paramsKey struct {
	params struct{ fn generator.Func }
	hashes struct{ fn hash.Hash }
}

// moqConverterer_MethodStructs_results holds the results of the Converterer
// type
type moqConverterer_MethodStructs_results struct {
	structDecls []dst.Decl
	err         error
}

// moqConverterer_MethodStructs_paramIndexing holds the parameter indexing
// runtime configuration for the Converterer type
type moqConverterer_MethodStructs_paramIndexing struct {
	fn moq.ParamIndexing
}

// moqConverterer_MethodStructs_doFn defines the type of function needed when
// calling andDo for the Converterer type
type moqConverterer_MethodStructs_doFn func(fn generator.Func)

// moqConverterer_MethodStructs_doReturnFn defines the type of function needed
// when calling doReturnResults for the Converterer type
type moqConverterer_MethodStructs_doReturnFn func(fn generator.Func) (structDecls []dst.Decl, err error)

// moqConverterer_MethodStructs_recorder routes recorded function calls to the
// moqConverterer moq
type moqConverterer_MethodStructs_recorder struct {
	recorder *impl.Recorder[
		*moqConverterer_MethodStructs_adaptor,
		moqConverterer_MethodStructs_params,
		moqConverterer_MethodStructs_paramsKey,
		moqConverterer_MethodStructs_results,
	]
}

// moqConverterer_MethodStructs_anyParams isolates the any params functions of
// the Converterer type
type moqConverterer_MethodStructs_anyParams struct {
	recorder *moqConverterer_MethodStructs_recorder
}

// moqConverterer_NewFunc_adaptor adapts moqConverterer as needed by the
// runtime
type moqConverterer_NewFunc_adaptor struct {
	moq *moqConverterer
}

// moqConverterer_NewFunc_params holds the params of the Converterer type
type moqConverterer_NewFunc_params struct{}

// moqConverterer_NewFunc_paramsKey holds the map key params of the Converterer
// type
type moqConverterer_NewFunc_paramsKey struct {
	params struct{}
	hashes struct{}
}

// moqConverterer_NewFunc_results holds the results of the Converterer type
type moqConverterer_NewFunc_results struct {
	funcDecl *dst.FuncDecl
	err      error
}

// moqConverterer_NewFunc_paramIndexing holds the parameter indexing runtime
// configuration for the Converterer type
type moqConverterer_NewFunc_paramIndexing struct{}

// moqConverterer_NewFunc_doFn defines the type of function needed when calling
// andDo for the Converterer type
type moqConverterer_NewFunc_doFn func()

// moqConverterer_NewFunc_doReturnFn defines the type of function needed when
// calling doReturnResults for the Converterer type
type moqConverterer_NewFunc_doReturnFn func() (funcDecl *dst.FuncDecl, err error)

// moqConverterer_NewFunc_recorder routes recorded function calls to the
// moqConverterer moq
type moqConverterer_NewFunc_recorder struct {
	recorder *impl.Recorder[
		*moqConverterer_NewFunc_adaptor,
		moqConverterer_NewFunc_params,
		moqConverterer_NewFunc_paramsKey,
		moqConverterer_NewFunc_results,
	]
}

// moqConverterer_NewFunc_anyParams isolates the any params functions of the
// Converterer type
type moqConverterer_NewFunc_anyParams struct {
	recorder *moqConverterer_NewFunc_recorder
}

// moqConverterer_IsolationAccessor_adaptor adapts moqConverterer as needed by
// the runtime
type moqConverterer_IsolationAccessor_adaptor struct {
	moq *moqConverterer
}

// moqConverterer_IsolationAccessor_params holds the params of the Converterer
// type
type moqConverterer_IsolationAccessor_params struct{ suffix, fnName string }

// moqConverterer_IsolationAccessor_paramsKey holds the map key params of the
// Converterer type
type moqConverterer_IsolationAccessor_paramsKey struct {
	params struct{ suffix, fnName string }
	hashes struct{ suffix, fnName hash.Hash }
}

// moqConverterer_IsolationAccessor_results holds the results of the
// Converterer type
type moqConverterer_IsolationAccessor_results struct {
	funcDecl *dst.FuncDecl
	err      error
}

// moqConverterer_IsolationAccessor_paramIndexing holds the parameter indexing
// runtime configuration for the Converterer type
type moqConverterer_IsolationAccessor_paramIndexing struct {
	suffix, fnName moq.ParamIndexing
}

// moqConverterer_IsolationAccessor_doFn defines the type of function needed
// when calling andDo for the Converterer type
type moqConverterer_IsolationAccessor_doFn func(suffix, fnName string)

// moqConverterer_IsolationAccessor_doReturnFn defines the type of function
// needed when calling doReturnResults for the Converterer type
type moqConverterer_IsolationAccessor_doReturnFn func(suffix, fnName string) (funcDecl *dst.FuncDecl, err error)

// moqConverterer_IsolationAccessor_recorder routes recorded function calls to
// the moqConverterer moq
type moqConverterer_IsolationAccessor_recorder struct {
	recorder *impl.Recorder[
		*moqConverterer_IsolationAccessor_adaptor,
		moqConverterer_IsolationAccessor_params,
		moqConverterer_IsolationAccessor_paramsKey,
		moqConverterer_IsolationAccessor_results,
	]
}

// moqConverterer_IsolationAccessor_anyParams isolates the any params functions
// of the Converterer type
type moqConverterer_IsolationAccessor_anyParams struct {
	recorder *moqConverterer_IsolationAccessor_recorder
}

// moqConverterer_FuncClosure_adaptor adapts moqConverterer as needed by the
// runtime
type moqConverterer_FuncClosure_adaptor struct {
	moq *moqConverterer
}

// moqConverterer_FuncClosure_params holds the params of the Converterer type
type moqConverterer_FuncClosure_params struct{ fn generator.Func }

// moqConverterer_FuncClosure_paramsKey holds the map key params of the
// Converterer type
type moqConverterer_FuncClosure_paramsKey struct {
	params struct{ fn generator.Func }
	hashes struct{ fn hash.Hash }
}

// moqConverterer_FuncClosure_results holds the results of the Converterer type
type moqConverterer_FuncClosure_results struct {
	funcDecl *dst.FuncDecl
	err      error
}

// moqConverterer_FuncClosure_paramIndexing holds the parameter indexing
// runtime configuration for the Converterer type
type moqConverterer_FuncClosure_paramIndexing struct {
	fn moq.ParamIndexing
}

// moqConverterer_FuncClosure_doFn defines the type of function needed when
// calling andDo for the Converterer type
type moqConverterer_FuncClosure_doFn func(fn generator.Func)

// moqConverterer_FuncClosure_doReturnFn defines the type of function needed
// when calling doReturnResults for the Converterer type
type moqConverterer_FuncClosure_doReturnFn func(fn generator.Func) (funcDecl *dst.FuncDecl, err error)

// moqConverterer_FuncClosure_recorder routes recorded function calls to the
// moqConverterer moq
type moqConverterer_FuncClosure_recorder struct {
	recorder *impl.Recorder[
		*moqConverterer_FuncClosure_adaptor,
		moqConverterer_FuncClosure_params,
		moqConverterer_FuncClosure_paramsKey,
		moqConverterer_FuncClosure_results,
	]
}

// moqConverterer_FuncClosure_anyParams isolates the any params functions of
// the Converterer type
type moqConverterer_FuncClosure_anyParams struct {
	recorder *moqConverterer_FuncClosure_recorder
}

// moqConverterer_MockMethod_adaptor adapts moqConverterer as needed by the
// runtime
type moqConverterer_MockMethod_adaptor struct {
	moq *moqConverterer
}

// moqConverterer_MockMethod_params holds the params of the Converterer type
type moqConverterer_MockMethod_params struct{ fn generator.Func }

// moqConverterer_MockMethod_paramsKey holds the map key params of the
// Converterer type
type moqConverterer_MockMethod_paramsKey struct {
	params struct{ fn generator.Func }
	hashes struct{ fn hash.Hash }
}

// moqConverterer_MockMethod_results holds the results of the Converterer type
type moqConverterer_MockMethod_results struct {
	funcDecl *dst.FuncDecl
	err      error
}

// moqConverterer_MockMethod_paramIndexing holds the parameter indexing runtime
// configuration for the Converterer type
type moqConverterer_MockMethod_paramIndexing struct {
	fn moq.ParamIndexing
}

// moqConverterer_MockMethod_doFn defines the type of function needed when
// calling andDo for the Converterer type
type moqConverterer_MockMethod_doFn func(fn generator.Func)

// moqConverterer_MockMethod_doReturnFn defines the type of function needed
// when calling doReturnResults for the Converterer type
type moqConverterer_MockMethod_doReturnFn func(fn generator.Func) (funcDecl *dst.FuncDecl, err error)

// moqConverterer_MockMethod_recorder routes recorded function calls to the
// moqConverterer moq
type moqConverterer_MockMethod_recorder struct {
	recorder *impl.Recorder[
		*moqConverterer_MockMethod_adaptor,
		moqConverterer_MockMethod_params,
		moqConverterer_MockMethod_paramsKey,
		moqConverterer_MockMethod_results,
	]
}

// moqConverterer_MockMethod_anyParams isolates the any params functions of the
// Converterer type
type moqConverterer_MockMethod_anyParams struct {
	recorder *moqConverterer_MockMethod_recorder
}

// moqConverterer_RecorderMethods_adaptor adapts moqConverterer as needed by
// the runtime
type moqConverterer_RecorderMethods_adaptor struct {
	moq *moqConverterer
}

// moqConverterer_RecorderMethods_params holds the params of the Converterer
// type
type moqConverterer_RecorderMethods_params struct{ fn generator.Func }

// moqConverterer_RecorderMethods_paramsKey holds the map key params of the
// Converterer type
type moqConverterer_RecorderMethods_paramsKey struct {
	params struct{ fn generator.Func }
	hashes struct{ fn hash.Hash }
}

// moqConverterer_RecorderMethods_results holds the results of the Converterer
// type
type moqConverterer_RecorderMethods_results struct {
	funcDecls []dst.Decl
	err       error
}

// moqConverterer_RecorderMethods_paramIndexing holds the parameter indexing
// runtime configuration for the Converterer type
type moqConverterer_RecorderMethods_paramIndexing struct {
	fn moq.ParamIndexing
}

// moqConverterer_RecorderMethods_doFn defines the type of function needed when
// calling andDo for the Converterer type
type moqConverterer_RecorderMethods_doFn func(fn generator.Func)

// moqConverterer_RecorderMethods_doReturnFn defines the type of function
// needed when calling doReturnResults for the Converterer type
type moqConverterer_RecorderMethods_doReturnFn func(fn generator.Func) (funcDecls []dst.Decl, err error)

// moqConverterer_RecorderMethods_recorder routes recorded function calls to
// the moqConverterer moq
type moqConverterer_RecorderMethods_recorder struct {
	recorder *impl.Recorder[
		*moqConverterer_RecorderMethods_adaptor,
		moqConverterer_RecorderMethods_params,
		moqConverterer_RecorderMethods_paramsKey,
		moqConverterer_RecorderMethods_results,
	]
}

// moqConverterer_RecorderMethods_anyParams isolates the any params functions
// of the Converterer type
type moqConverterer_RecorderMethods_anyParams struct {
	recorder *moqConverterer_RecorderMethods_recorder
}

// moqConverterer_ResetMethod_adaptor adapts moqConverterer as needed by the
// runtime
type moqConverterer_ResetMethod_adaptor struct {
	moq *moqConverterer
}

// moqConverterer_ResetMethod_params holds the params of the Converterer type
type moqConverterer_ResetMethod_params struct{}

// moqConverterer_ResetMethod_paramsKey holds the map key params of the
// Converterer type
type moqConverterer_ResetMethod_paramsKey struct {
	params struct{}
	hashes struct{}
}

// moqConverterer_ResetMethod_results holds the results of the Converterer type
type moqConverterer_ResetMethod_results struct {
	funcDecl *dst.FuncDecl
	err      error
}

// moqConverterer_ResetMethod_paramIndexing holds the parameter indexing
// runtime configuration for the Converterer type
type moqConverterer_ResetMethod_paramIndexing struct{}

// moqConverterer_ResetMethod_doFn defines the type of function needed when
// calling andDo for the Converterer type
type moqConverterer_ResetMethod_doFn func()

// moqConverterer_ResetMethod_doReturnFn defines the type of function needed
// when calling doReturnResults for the Converterer type
type moqConverterer_ResetMethod_doReturnFn func() (funcDecl *dst.FuncDecl, err error)

// moqConverterer_ResetMethod_recorder routes recorded function calls to the
// moqConverterer moq
type moqConverterer_ResetMethod_recorder struct {
	recorder *impl.Recorder[
		*moqConverterer_ResetMethod_adaptor,
		moqConverterer_ResetMethod_params,
		moqConverterer_ResetMethod_paramsKey,
		moqConverterer_ResetMethod_results,
	]
}

// moqConverterer_ResetMethod_anyParams isolates the any params functions of
// the Converterer type
type moqConverterer_ResetMethod_anyParams struct {
	recorder *moqConverterer_ResetMethod_recorder
}

// moqConverterer_AssertMethod_adaptor adapts moqConverterer as needed by the
// runtime
type moqConverterer_AssertMethod_adaptor struct {
	moq *moqConverterer
}

// moqConverterer_AssertMethod_params holds the params of the Converterer type
type moqConverterer_AssertMethod_params struct{}

// moqConverterer_AssertMethod_paramsKey holds the map key params of the
// Converterer type
type moqConverterer_AssertMethod_paramsKey struct {
	params struct{}
	hashes struct{}
}

// moqConverterer_AssertMethod_results holds the results of the Converterer
// type
type moqConverterer_AssertMethod_results struct {
	funcDecl *dst.FuncDecl
	err      error
}

// moqConverterer_AssertMethod_paramIndexing holds the parameter indexing
// runtime configuration for the Converterer type
type moqConverterer_AssertMethod_paramIndexing struct{}

// moqConverterer_AssertMethod_doFn defines the type of function needed when
// calling andDo for the Converterer type
type moqConverterer_AssertMethod_doFn func()

// moqConverterer_AssertMethod_doReturnFn defines the type of function needed
// when calling doReturnResults for the Converterer type
type moqConverterer_AssertMethod_doReturnFn func() (funcDecl *dst.FuncDecl, err error)

// moqConverterer_AssertMethod_recorder routes recorded function calls to the
// moqConverterer moq
type moqConverterer_AssertMethod_recorder struct {
	recorder *impl.Recorder[
		*moqConverterer_AssertMethod_adaptor,
		moqConverterer_AssertMethod_params,
		moqConverterer_AssertMethod_paramsKey,
		moqConverterer_AssertMethod_results,
	]
}

// moqConverterer_AssertMethod_anyParams isolates the any params functions of
// the Converterer type
type moqConverterer_AssertMethod_anyParams struct {
	recorder *moqConverterer_AssertMethod_recorder
}

// newMoqConverterer creates a new moq of the Converterer type
func newMoqConverterer(scene *moq.Scene, config *moq.Config) *moqConverterer {
	adaptor1 := &moqConverterer_BaseDecls_adaptor{}
	adaptor2 := &moqConverterer_MockStructs_adaptor{}
	adaptor3 := &moqConverterer_MethodStructs_adaptor{}
	adaptor4 := &moqConverterer_NewFunc_adaptor{}
	adaptor5 := &moqConverterer_IsolationAccessor_adaptor{}
	adaptor6 := &moqConverterer_FuncClosure_adaptor{}
	adaptor7 := &moqConverterer_MockMethod_adaptor{}
	adaptor8 := &moqConverterer_RecorderMethods_adaptor{}
	adaptor9 := &moqConverterer_ResetMethod_adaptor{}
	adaptor10 := &moqConverterer_AssertMethod_adaptor{}
	m := &moqConverterer{
		moq: &moqConverterer_mock{},

		moq_BaseDecls: impl.NewMoq[
			*moqConverterer_BaseDecls_adaptor,
			moqConverterer_BaseDecls_params,
			moqConverterer_BaseDecls_paramsKey,
			moqConverterer_BaseDecls_results,
		](scene, adaptor1, config),
		moq_MockStructs: impl.NewMoq[
			*moqConverterer_MockStructs_adaptor,
			moqConverterer_MockStructs_params,
			moqConverterer_MockStructs_paramsKey,
			moqConverterer_MockStructs_results,
		](scene, adaptor2, config),
		moq_MethodStructs: impl.NewMoq[
			*moqConverterer_MethodStructs_adaptor,
			moqConverterer_MethodStructs_params,
			moqConverterer_MethodStructs_paramsKey,
			moqConverterer_MethodStructs_results,
		](scene, adaptor3, config),
		moq_NewFunc: impl.NewMoq[
			*moqConverterer_NewFunc_adaptor,
			moqConverterer_NewFunc_params,
			moqConverterer_NewFunc_paramsKey,
			moqConverterer_NewFunc_results,
		](scene, adaptor4, config),
		moq_IsolationAccessor: impl.NewMoq[
			*moqConverterer_IsolationAccessor_adaptor,
			moqConverterer_IsolationAccessor_params,
			moqConverterer_IsolationAccessor_paramsKey,
			moqConverterer_IsolationAccessor_results,
		](scene, adaptor5, config),
		moq_FuncClosure: impl.NewMoq[
			*moqConverterer_FuncClosure_adaptor,
			moqConverterer_FuncClosure_params,
			moqConverterer_FuncClosure_paramsKey,
			moqConverterer_FuncClosure_results,
		](scene, adaptor6, config),
		moq_MockMethod: impl.NewMoq[
			*moqConverterer_MockMethod_adaptor,
			moqConverterer_MockMethod_params,
			moqConverterer_MockMethod_paramsKey,
			moqConverterer_MockMethod_results,
		](scene, adaptor7, config),
		moq_RecorderMethods: impl.NewMoq[
			*moqConverterer_RecorderMethods_adaptor,
			moqConverterer_RecorderMethods_params,
			moqConverterer_RecorderMethods_paramsKey,
			moqConverterer_RecorderMethods_results,
		](scene, adaptor8, config),
		moq_ResetMethod: impl.NewMoq[
			*moqConverterer_ResetMethod_adaptor,
			moqConverterer_ResetMethod_params,
			moqConverterer_ResetMethod_paramsKey,
			moqConverterer_ResetMethod_results,
		](scene, adaptor9, config),
		moq_AssertMethod: impl.NewMoq[
			*moqConverterer_AssertMethod_adaptor,
			moqConverterer_AssertMethod_params,
			moqConverterer_AssertMethod_paramsKey,
			moqConverterer_AssertMethod_results,
		](scene, adaptor10, config),

		runtime: moqConverterer_runtime{parameterIndexing: struct {
			BaseDecls         moqConverterer_BaseDecls_paramIndexing
			MockStructs       moqConverterer_MockStructs_paramIndexing
			MethodStructs     moqConverterer_MethodStructs_paramIndexing
			NewFunc           moqConverterer_NewFunc_paramIndexing
			IsolationAccessor moqConverterer_IsolationAccessor_paramIndexing
			FuncClosure       moqConverterer_FuncClosure_paramIndexing
			MockMethod        moqConverterer_MockMethod_paramIndexing
			RecorderMethods   moqConverterer_RecorderMethods_paramIndexing
			ResetMethod       moqConverterer_ResetMethod_paramIndexing
			AssertMethod      moqConverterer_AssertMethod_paramIndexing
		}{
			BaseDecls:   moqConverterer_BaseDecls_paramIndexing{},
			MockStructs: moqConverterer_MockStructs_paramIndexing{},
			MethodStructs: moqConverterer_MethodStructs_paramIndexing{
				fn: moq.ParamIndexByHash,
			},
			NewFunc: moqConverterer_NewFunc_paramIndexing{},
			IsolationAccessor: moqConverterer_IsolationAccessor_paramIndexing{
				suffix: moq.ParamIndexByValue,
				fnName: moq.ParamIndexByValue,
			},
			FuncClosure: moqConverterer_FuncClosure_paramIndexing{
				fn: moq.ParamIndexByHash,
			},
			MockMethod: moqConverterer_MockMethod_paramIndexing{
				fn: moq.ParamIndexByHash,
			},
			RecorderMethods: moqConverterer_RecorderMethods_paramIndexing{
				fn: moq.ParamIndexByHash,
			},
			ResetMethod:  moqConverterer_ResetMethod_paramIndexing{},
			AssertMethod: moqConverterer_AssertMethod_paramIndexing{},
		}},
	}
	m.moq.moq = m

	adaptor1.moq = m
	adaptor2.moq = m
	adaptor3.moq = m
	adaptor4.moq = m
	adaptor5.moq = m
	adaptor6.moq = m
	adaptor7.moq = m
	adaptor8.moq = m
	adaptor9.moq = m
	adaptor10.moq = m

	scene.AddMoq(m)
	return m
}

// mock returns the mock implementation of the Converterer type
func (m *moqConverterer) mock() *moqConverterer_mock { return m.moq }

func (m *moqConverterer_mock) BaseDecls() ([]dst.Decl, error) {
	m.moq.moq_BaseDecls.Scene.T.Helper()
	params := moqConverterer_BaseDecls_params{}

	var result1 []dst.Decl
	var result2 error
	if result := m.moq.moq_BaseDecls.Function(params); result != nil {
		result1 = result.baseDecls
		result2 = result.err
	}
	return result1, result2
}

func (m *moqConverterer_mock) MockStructs() ([]dst.Decl, error) {
	m.moq.moq_MockStructs.Scene.T.Helper()
	params := moqConverterer_MockStructs_params{}

	var result1 []dst.Decl
	var result2 error
	if result := m.moq.moq_MockStructs.Function(params); result != nil {
		result1 = result.structDecls
		result2 = result.err
	}
	return result1, result2
}

func (m *moqConverterer_mock) MethodStructs(fn generator.Func) ([]dst.Decl, error) {
	m.moq.moq_MethodStructs.Scene.T.Helper()
	params := moqConverterer_MethodStructs_params{
		fn: fn,
	}

	var result1 []dst.Decl
	var result2 error
	if result := m.moq.moq_MethodStructs.Function(params); result != nil {
		result1 = result.structDecls
		result2 = result.err
	}
	return result1, result2
}

func (m *moqConverterer_mock) NewFunc() (*dst.FuncDecl, error) {
	m.moq.moq_NewFunc.Scene.T.Helper()
	params := moqConverterer_NewFunc_params{}

	var result1 *dst.FuncDecl
	var result2 error
	if result := m.moq.moq_NewFunc.Function(params); result != nil {
		result1 = result.funcDecl
		result2 = result.err
	}
	return result1, result2
}

func (m *moqConverterer_mock) IsolationAccessor(suffix, fnName string) (*dst.FuncDecl, error) {
	m.moq.moq_IsolationAccessor.Scene.T.Helper()
	params := moqConverterer_IsolationAccessor_params{
		suffix: suffix,
		fnName: fnName,
	}

	var result1 *dst.FuncDecl
	var result2 error
	if result := m.moq.moq_IsolationAccessor.Function(params); result != nil {
		result1 = result.funcDecl
		result2 = result.err
	}
	return result1, result2
}

func (m *moqConverterer_mock) FuncClosure(fn generator.Func) (*dst.FuncDecl, error) {
	m.moq.moq_FuncClosure.Scene.T.Helper()
	params := moqConverterer_FuncClosure_params{
		fn: fn,
	}

	var result1 *dst.FuncDecl
	var result2 error
	if result := m.moq.moq_FuncClosure.Function(params); result != nil {
		result1 = result.funcDecl
		result2 = result.err
	}
	return result1, result2
}

func (m *moqConverterer_mock) MockMethod(fn generator.Func) (*dst.FuncDecl, error) {
	m.moq.moq_MockMethod.Scene.T.Helper()
	params := moqConverterer_MockMethod_params{
		fn: fn,
	}

	var result1 *dst.FuncDecl
	var result2 error
	if result := m.moq.moq_MockMethod.Function(params); result != nil {
		result1 = result.funcDecl
		result2 = result.err
	}
	return result1, result2
}

func (m *moqConverterer_mock) RecorderMethods(fn generator.Func) ([]dst.Decl, error) {
	m.moq.moq_RecorderMethods.Scene.T.Helper()
	params := moqConverterer_RecorderMethods_params{
		fn: fn,
	}

	var result1 []dst.Decl
	var result2 error
	if result := m.moq.moq_RecorderMethods.Function(params); result != nil {
		result1 = result.funcDecls
		result2 = result.err
	}
	return result1, result2
}

func (m *moqConverterer_mock) ResetMethod() (*dst.FuncDecl, error) {
	m.moq.moq_ResetMethod.Scene.T.Helper()
	params := moqConverterer_ResetMethod_params{}

	var result1 *dst.FuncDecl
	var result2 error
	if result := m.moq.moq_ResetMethod.Function(params); result != nil {
		result1 = result.funcDecl
		result2 = result.err
	}
	return result1, result2
}

func (m *moqConverterer_mock) AssertMethod() (*dst.FuncDecl, error) {
	m.moq.moq_AssertMethod.Scene.T.Helper()
	params := moqConverterer_AssertMethod_params{}

	var result1 *dst.FuncDecl
	var result2 error
	if result := m.moq.moq_AssertMethod.Function(params); result != nil {
		result1 = result.funcDecl
		result2 = result.err
	}
	return result1, result2
}

// onCall returns the recorder implementation of the Converterer type
func (m *moqConverterer) onCall() *moqConverterer_recorder {
	return &moqConverterer_recorder{
		moq: m,
	}
}

func (m *moqConverterer_recorder) BaseDecls() *moqConverterer_BaseDecls_recorder {
	return &moqConverterer_BaseDecls_recorder{
		recorder: m.moq.moq_BaseDecls.OnCall(moqConverterer_BaseDecls_params{}),
	}
}

func (r *moqConverterer_BaseDecls_recorder) any() *moqConverterer_BaseDecls_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqConverterer_BaseDecls_anyParams{recorder: r}
}

func (r *moqConverterer_BaseDecls_recorder) seq() *moqConverterer_BaseDecls_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqConverterer_BaseDecls_recorder) noSeq() *moqConverterer_BaseDecls_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqConverterer_BaseDecls_recorder) returnResults(baseDecls []dst.Decl, err error) *moqConverterer_BaseDecls_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqConverterer_BaseDecls_results{
		baseDecls: baseDecls,
		err:       err,
	})
	return r
}

func (r *moqConverterer_BaseDecls_recorder) andDo(fn moqConverterer_BaseDecls_doFn) *moqConverterer_BaseDecls_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqConverterer_BaseDecls_params) {
		fn()
	}, false) {
		return nil
	}
	return r
}

func (r *moqConverterer_BaseDecls_recorder) doReturnResults(fn moqConverterer_BaseDecls_doReturnFn) *moqConverterer_BaseDecls_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqConverterer_BaseDecls_params) *moqConverterer_BaseDecls_results {
		baseDecls, err := fn()
		return &moqConverterer_BaseDecls_results{
			baseDecls: baseDecls,
			err:       err,
		}
	})
	return r
}

func (r *moqConverterer_BaseDecls_recorder) repeat(repeaters ...moq.Repeater) *moqConverterer_BaseDecls_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqConverterer_BaseDecls_adaptor) PrettyParams(params moqConverterer_BaseDecls_params) string {
	return fmt.Sprintf("BaseDecls()")
}

func (a *moqConverterer_BaseDecls_adaptor) ParamsKey(params moqConverterer_BaseDecls_params, anyParams uint64) moqConverterer_BaseDecls_paramsKey {
	a.moq.moq_BaseDecls.Scene.T.Helper()
	return moqConverterer_BaseDecls_paramsKey{
		params: struct{}{},
		hashes: struct{}{},
	}
}

func (m *moqConverterer_recorder) MockStructs() *moqConverterer_MockStructs_recorder {
	return &moqConverterer_MockStructs_recorder{
		recorder: m.moq.moq_MockStructs.OnCall(moqConverterer_MockStructs_params{}),
	}
}

func (r *moqConverterer_MockStructs_recorder) any() *moqConverterer_MockStructs_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqConverterer_MockStructs_anyParams{recorder: r}
}

func (r *moqConverterer_MockStructs_recorder) seq() *moqConverterer_MockStructs_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqConverterer_MockStructs_recorder) noSeq() *moqConverterer_MockStructs_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqConverterer_MockStructs_recorder) returnResults(structDecls []dst.Decl, err error) *moqConverterer_MockStructs_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqConverterer_MockStructs_results{
		structDecls: structDecls,
		err:         err,
	})
	return r
}

func (r *moqConverterer_MockStructs_recorder) andDo(fn moqConverterer_MockStructs_doFn) *moqConverterer_MockStructs_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqConverterer_MockStructs_params) {
		fn()
	}, false) {
		return nil
	}
	return r
}

func (r *moqConverterer_MockStructs_recorder) doReturnResults(fn moqConverterer_MockStructs_doReturnFn) *moqConverterer_MockStructs_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqConverterer_MockStructs_params) *moqConverterer_MockStructs_results {
		structDecls, err := fn()
		return &moqConverterer_MockStructs_results{
			structDecls: structDecls,
			err:         err,
		}
	})
	return r
}

func (r *moqConverterer_MockStructs_recorder) repeat(repeaters ...moq.Repeater) *moqConverterer_MockStructs_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqConverterer_MockStructs_adaptor) PrettyParams(params moqConverterer_MockStructs_params) string {
	return fmt.Sprintf("MockStructs()")
}

func (a *moqConverterer_MockStructs_adaptor) ParamsKey(params moqConverterer_MockStructs_params, anyParams uint64) moqConverterer_MockStructs_paramsKey {
	a.moq.moq_MockStructs.Scene.T.Helper()
	return moqConverterer_MockStructs_paramsKey{
		params: struct{}{},
		hashes: struct{}{},
	}
}

func (m *moqConverterer_recorder) MethodStructs(fn generator.Func) *moqConverterer_MethodStructs_recorder {
	return &moqConverterer_MethodStructs_recorder{
		recorder: m.moq.moq_MethodStructs.OnCall(moqConverterer_MethodStructs_params{
			fn: fn,
		}),
	}
}

func (r *moqConverterer_MethodStructs_recorder) any() *moqConverterer_MethodStructs_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqConverterer_MethodStructs_anyParams{recorder: r}
}

func (a *moqConverterer_MethodStructs_anyParams) fn() *moqConverterer_MethodStructs_recorder {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (r *moqConverterer_MethodStructs_recorder) seq() *moqConverterer_MethodStructs_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqConverterer_MethodStructs_recorder) noSeq() *moqConverterer_MethodStructs_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqConverterer_MethodStructs_recorder) returnResults(structDecls []dst.Decl, err error) *moqConverterer_MethodStructs_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqConverterer_MethodStructs_results{
		structDecls: structDecls,
		err:         err,
	})
	return r
}

func (r *moqConverterer_MethodStructs_recorder) andDo(fn moqConverterer_MethodStructs_doFn) *moqConverterer_MethodStructs_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqConverterer_MethodStructs_params) {
		fn(params.fn)
	}, false) {
		return nil
	}
	return r
}

func (r *moqConverterer_MethodStructs_recorder) doReturnResults(fn moqConverterer_MethodStructs_doReturnFn) *moqConverterer_MethodStructs_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqConverterer_MethodStructs_params) *moqConverterer_MethodStructs_results {
		structDecls, err := fn(params.fn)
		return &moqConverterer_MethodStructs_results{
			structDecls: structDecls,
			err:         err,
		}
	})
	return r
}

func (r *moqConverterer_MethodStructs_recorder) repeat(repeaters ...moq.Repeater) *moqConverterer_MethodStructs_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqConverterer_MethodStructs_adaptor) PrettyParams(params moqConverterer_MethodStructs_params) string {
	return fmt.Sprintf("MethodStructs(%#v)", params.fn)
}

func (a *moqConverterer_MethodStructs_adaptor) ParamsKey(params moqConverterer_MethodStructs_params, anyParams uint64) moqConverterer_MethodStructs_paramsKey {
	a.moq.moq_MethodStructs.Scene.T.Helper()
	fnUsed, fnUsedHash := impl.ParamKey(
		params.fn, 1, a.moq.runtime.parameterIndexing.MethodStructs.fn, anyParams)
	return moqConverterer_MethodStructs_paramsKey{
		params: struct{ fn generator.Func }{
			fn: fnUsed,
		},
		hashes: struct{ fn hash.Hash }{
			fn: fnUsedHash,
		},
	}
}

func (m *moqConverterer_recorder) NewFunc() *moqConverterer_NewFunc_recorder {
	return &moqConverterer_NewFunc_recorder{
		recorder: m.moq.moq_NewFunc.OnCall(moqConverterer_NewFunc_params{}),
	}
}

func (r *moqConverterer_NewFunc_recorder) any() *moqConverterer_NewFunc_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqConverterer_NewFunc_anyParams{recorder: r}
}

func (r *moqConverterer_NewFunc_recorder) seq() *moqConverterer_NewFunc_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqConverterer_NewFunc_recorder) noSeq() *moqConverterer_NewFunc_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqConverterer_NewFunc_recorder) returnResults(funcDecl *dst.FuncDecl, err error) *moqConverterer_NewFunc_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqConverterer_NewFunc_results{
		funcDecl: funcDecl,
		err:      err,
	})
	return r
}

func (r *moqConverterer_NewFunc_recorder) andDo(fn moqConverterer_NewFunc_doFn) *moqConverterer_NewFunc_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqConverterer_NewFunc_params) {
		fn()
	}, false) {
		return nil
	}
	return r
}

func (r *moqConverterer_NewFunc_recorder) doReturnResults(fn moqConverterer_NewFunc_doReturnFn) *moqConverterer_NewFunc_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqConverterer_NewFunc_params) *moqConverterer_NewFunc_results {
		funcDecl, err := fn()
		return &moqConverterer_NewFunc_results{
			funcDecl: funcDecl,
			err:      err,
		}
	})
	return r
}

func (r *moqConverterer_NewFunc_recorder) repeat(repeaters ...moq.Repeater) *moqConverterer_NewFunc_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqConverterer_NewFunc_adaptor) PrettyParams(params moqConverterer_NewFunc_params) string {
	return fmt.Sprintf("NewFunc()")
}

func (a *moqConverterer_NewFunc_adaptor) ParamsKey(params moqConverterer_NewFunc_params, anyParams uint64) moqConverterer_NewFunc_paramsKey {
	a.moq.moq_NewFunc.Scene.T.Helper()
	return moqConverterer_NewFunc_paramsKey{
		params: struct{}{},
		hashes: struct{}{},
	}
}

func (m *moqConverterer_recorder) IsolationAccessor(suffix, fnName string) *moqConverterer_IsolationAccessor_recorder {
	return &moqConverterer_IsolationAccessor_recorder{
		recorder: m.moq.moq_IsolationAccessor.OnCall(moqConverterer_IsolationAccessor_params{
			suffix: suffix,
			fnName: fnName,
		}),
	}
}

func (r *moqConverterer_IsolationAccessor_recorder) any() *moqConverterer_IsolationAccessor_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqConverterer_IsolationAccessor_anyParams{recorder: r}
}

func (a *moqConverterer_IsolationAccessor_anyParams) suffix() *moqConverterer_IsolationAccessor_recorder {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (a *moqConverterer_IsolationAccessor_anyParams) fnName() *moqConverterer_IsolationAccessor_recorder {
	a.recorder.recorder.AnyParam(2)
	return a.recorder
}

func (r *moqConverterer_IsolationAccessor_recorder) seq() *moqConverterer_IsolationAccessor_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqConverterer_IsolationAccessor_recorder) noSeq() *moqConverterer_IsolationAccessor_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqConverterer_IsolationAccessor_recorder) returnResults(funcDecl *dst.FuncDecl, err error) *moqConverterer_IsolationAccessor_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqConverterer_IsolationAccessor_results{
		funcDecl: funcDecl,
		err:      err,
	})
	return r
}

func (r *moqConverterer_IsolationAccessor_recorder) andDo(fn moqConverterer_IsolationAccessor_doFn) *moqConverterer_IsolationAccessor_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqConverterer_IsolationAccessor_params) {
		fn(params.suffix, params.fnName)
	}, false) {
		return nil
	}
	return r
}

func (r *moqConverterer_IsolationAccessor_recorder) doReturnResults(fn moqConverterer_IsolationAccessor_doReturnFn) *moqConverterer_IsolationAccessor_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqConverterer_IsolationAccessor_params) *moqConverterer_IsolationAccessor_results {
		funcDecl, err := fn(params.suffix, params.fnName)
		return &moqConverterer_IsolationAccessor_results{
			funcDecl: funcDecl,
			err:      err,
		}
	})
	return r
}

func (r *moqConverterer_IsolationAccessor_recorder) repeat(repeaters ...moq.Repeater) *moqConverterer_IsolationAccessor_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqConverterer_IsolationAccessor_adaptor) PrettyParams(params moqConverterer_IsolationAccessor_params) string {
	return fmt.Sprintf("IsolationAccessor(%#v, %#v)", params.suffix, params.fnName)
}

func (a *moqConverterer_IsolationAccessor_adaptor) ParamsKey(params moqConverterer_IsolationAccessor_params, anyParams uint64) moqConverterer_IsolationAccessor_paramsKey {
	a.moq.moq_IsolationAccessor.Scene.T.Helper()
	suffixUsed, suffixUsedHash := impl.ParamKey(
		params.suffix, 1, a.moq.runtime.parameterIndexing.IsolationAccessor.suffix, anyParams)
	fnNameUsed, fnNameUsedHash := impl.ParamKey(
		params.fnName, 2, a.moq.runtime.parameterIndexing.IsolationAccessor.fnName, anyParams)
	return moqConverterer_IsolationAccessor_paramsKey{
		params: struct{ suffix, fnName string }{
			suffix: suffixUsed,
			fnName: fnNameUsed,
		},
		hashes: struct{ suffix, fnName hash.Hash }{
			suffix: suffixUsedHash,
			fnName: fnNameUsedHash,
		},
	}
}

func (m *moqConverterer_recorder) FuncClosure(fn generator.Func) *moqConverterer_FuncClosure_recorder {
	return &moqConverterer_FuncClosure_recorder{
		recorder: m.moq.moq_FuncClosure.OnCall(moqConverterer_FuncClosure_params{
			fn: fn,
		}),
	}
}

func (r *moqConverterer_FuncClosure_recorder) any() *moqConverterer_FuncClosure_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqConverterer_FuncClosure_anyParams{recorder: r}
}

func (a *moqConverterer_FuncClosure_anyParams) fn() *moqConverterer_FuncClosure_recorder {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (r *moqConverterer_FuncClosure_recorder) seq() *moqConverterer_FuncClosure_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqConverterer_FuncClosure_recorder) noSeq() *moqConverterer_FuncClosure_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqConverterer_FuncClosure_recorder) returnResults(funcDecl *dst.FuncDecl, err error) *moqConverterer_FuncClosure_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqConverterer_FuncClosure_results{
		funcDecl: funcDecl,
		err:      err,
	})
	return r
}

func (r *moqConverterer_FuncClosure_recorder) andDo(fn moqConverterer_FuncClosure_doFn) *moqConverterer_FuncClosure_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqConverterer_FuncClosure_params) {
		fn(params.fn)
	}, false) {
		return nil
	}
	return r
}

func (r *moqConverterer_FuncClosure_recorder) doReturnResults(fn moqConverterer_FuncClosure_doReturnFn) *moqConverterer_FuncClosure_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqConverterer_FuncClosure_params) *moqConverterer_FuncClosure_results {
		funcDecl, err := fn(params.fn)
		return &moqConverterer_FuncClosure_results{
			funcDecl: funcDecl,
			err:      err,
		}
	})
	return r
}

func (r *moqConverterer_FuncClosure_recorder) repeat(repeaters ...moq.Repeater) *moqConverterer_FuncClosure_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqConverterer_FuncClosure_adaptor) PrettyParams(params moqConverterer_FuncClosure_params) string {
	return fmt.Sprintf("FuncClosure(%#v)", params.fn)
}

func (a *moqConverterer_FuncClosure_adaptor) ParamsKey(params moqConverterer_FuncClosure_params, anyParams uint64) moqConverterer_FuncClosure_paramsKey {
	a.moq.moq_FuncClosure.Scene.T.Helper()
	fnUsed, fnUsedHash := impl.ParamKey(
		params.fn, 1, a.moq.runtime.parameterIndexing.FuncClosure.fn, anyParams)
	return moqConverterer_FuncClosure_paramsKey{
		params: struct{ fn generator.Func }{
			fn: fnUsed,
		},
		hashes: struct{ fn hash.Hash }{
			fn: fnUsedHash,
		},
	}
}

func (m *moqConverterer_recorder) MockMethod(fn generator.Func) *moqConverterer_MockMethod_recorder {
	return &moqConverterer_MockMethod_recorder{
		recorder: m.moq.moq_MockMethod.OnCall(moqConverterer_MockMethod_params{
			fn: fn,
		}),
	}
}

func (r *moqConverterer_MockMethod_recorder) any() *moqConverterer_MockMethod_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqConverterer_MockMethod_anyParams{recorder: r}
}

func (a *moqConverterer_MockMethod_anyParams) fn() *moqConverterer_MockMethod_recorder {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (r *moqConverterer_MockMethod_recorder) seq() *moqConverterer_MockMethod_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqConverterer_MockMethod_recorder) noSeq() *moqConverterer_MockMethod_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqConverterer_MockMethod_recorder) returnResults(funcDecl *dst.FuncDecl, err error) *moqConverterer_MockMethod_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqConverterer_MockMethod_results{
		funcDecl: funcDecl,
		err:      err,
	})
	return r
}

func (r *moqConverterer_MockMethod_recorder) andDo(fn moqConverterer_MockMethod_doFn) *moqConverterer_MockMethod_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqConverterer_MockMethod_params) {
		fn(params.fn)
	}, false) {
		return nil
	}
	return r
}

func (r *moqConverterer_MockMethod_recorder) doReturnResults(fn moqConverterer_MockMethod_doReturnFn) *moqConverterer_MockMethod_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqConverterer_MockMethod_params) *moqConverterer_MockMethod_results {
		funcDecl, err := fn(params.fn)
		return &moqConverterer_MockMethod_results{
			funcDecl: funcDecl,
			err:      err,
		}
	})
	return r
}

func (r *moqConverterer_MockMethod_recorder) repeat(repeaters ...moq.Repeater) *moqConverterer_MockMethod_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqConverterer_MockMethod_adaptor) PrettyParams(params moqConverterer_MockMethod_params) string {
	return fmt.Sprintf("MockMethod(%#v)", params.fn)
}

func (a *moqConverterer_MockMethod_adaptor) ParamsKey(params moqConverterer_MockMethod_params, anyParams uint64) moqConverterer_MockMethod_paramsKey {
	a.moq.moq_MockMethod.Scene.T.Helper()
	fnUsed, fnUsedHash := impl.ParamKey(
		params.fn, 1, a.moq.runtime.parameterIndexing.MockMethod.fn, anyParams)
	return moqConverterer_MockMethod_paramsKey{
		params: struct{ fn generator.Func }{
			fn: fnUsed,
		},
		hashes: struct{ fn hash.Hash }{
			fn: fnUsedHash,
		},
	}
}

func (m *moqConverterer_recorder) RecorderMethods(fn generator.Func) *moqConverterer_RecorderMethods_recorder {
	return &moqConverterer_RecorderMethods_recorder{
		recorder: m.moq.moq_RecorderMethods.OnCall(moqConverterer_RecorderMethods_params{
			fn: fn,
		}),
	}
}

func (r *moqConverterer_RecorderMethods_recorder) any() *moqConverterer_RecorderMethods_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqConverterer_RecorderMethods_anyParams{recorder: r}
}

func (a *moqConverterer_RecorderMethods_anyParams) fn() *moqConverterer_RecorderMethods_recorder {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (r *moqConverterer_RecorderMethods_recorder) seq() *moqConverterer_RecorderMethods_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqConverterer_RecorderMethods_recorder) noSeq() *moqConverterer_RecorderMethods_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqConverterer_RecorderMethods_recorder) returnResults(funcDecls []dst.Decl, err error) *moqConverterer_RecorderMethods_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqConverterer_RecorderMethods_results{
		funcDecls: funcDecls,
		err:       err,
	})
	return r
}

func (r *moqConverterer_RecorderMethods_recorder) andDo(fn moqConverterer_RecorderMethods_doFn) *moqConverterer_RecorderMethods_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqConverterer_RecorderMethods_params) {
		fn(params.fn)
	}, false) {
		return nil
	}
	return r
}

func (r *moqConverterer_RecorderMethods_recorder) doReturnResults(fn moqConverterer_RecorderMethods_doReturnFn) *moqConverterer_RecorderMethods_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqConverterer_RecorderMethods_params) *moqConverterer_RecorderMethods_results {
		funcDecls, err := fn(params.fn)
		return &moqConverterer_RecorderMethods_results{
			funcDecls: funcDecls,
			err:       err,
		}
	})
	return r
}

func (r *moqConverterer_RecorderMethods_recorder) repeat(repeaters ...moq.Repeater) *moqConverterer_RecorderMethods_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqConverterer_RecorderMethods_adaptor) PrettyParams(params moqConverterer_RecorderMethods_params) string {
	return fmt.Sprintf("RecorderMethods(%#v)", params.fn)
}

func (a *moqConverterer_RecorderMethods_adaptor) ParamsKey(params moqConverterer_RecorderMethods_params, anyParams uint64) moqConverterer_RecorderMethods_paramsKey {
	a.moq.moq_RecorderMethods.Scene.T.Helper()
	fnUsed, fnUsedHash := impl.ParamKey(
		params.fn, 1, a.moq.runtime.parameterIndexing.RecorderMethods.fn, anyParams)
	return moqConverterer_RecorderMethods_paramsKey{
		params: struct{ fn generator.Func }{
			fn: fnUsed,
		},
		hashes: struct{ fn hash.Hash }{
			fn: fnUsedHash,
		},
	}
}

func (m *moqConverterer_recorder) ResetMethod() *moqConverterer_ResetMethod_recorder {
	return &moqConverterer_ResetMethod_recorder{
		recorder: m.moq.moq_ResetMethod.OnCall(moqConverterer_ResetMethod_params{}),
	}
}

func (r *moqConverterer_ResetMethod_recorder) any() *moqConverterer_ResetMethod_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqConverterer_ResetMethod_anyParams{recorder: r}
}

func (r *moqConverterer_ResetMethod_recorder) seq() *moqConverterer_ResetMethod_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqConverterer_ResetMethod_recorder) noSeq() *moqConverterer_ResetMethod_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqConverterer_ResetMethod_recorder) returnResults(funcDecl *dst.FuncDecl, err error) *moqConverterer_ResetMethod_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqConverterer_ResetMethod_results{
		funcDecl: funcDecl,
		err:      err,
	})
	return r
}

func (r *moqConverterer_ResetMethod_recorder) andDo(fn moqConverterer_ResetMethod_doFn) *moqConverterer_ResetMethod_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqConverterer_ResetMethod_params) {
		fn()
	}, false) {
		return nil
	}
	return r
}

func (r *moqConverterer_ResetMethod_recorder) doReturnResults(fn moqConverterer_ResetMethod_doReturnFn) *moqConverterer_ResetMethod_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqConverterer_ResetMethod_params) *moqConverterer_ResetMethod_results {
		funcDecl, err := fn()
		return &moqConverterer_ResetMethod_results{
			funcDecl: funcDecl,
			err:      err,
		}
	})
	return r
}

func (r *moqConverterer_ResetMethod_recorder) repeat(repeaters ...moq.Repeater) *moqConverterer_ResetMethod_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqConverterer_ResetMethod_adaptor) PrettyParams(params moqConverterer_ResetMethod_params) string {
	return fmt.Sprintf("ResetMethod()")
}

func (a *moqConverterer_ResetMethod_adaptor) ParamsKey(params moqConverterer_ResetMethod_params, anyParams uint64) moqConverterer_ResetMethod_paramsKey {
	a.moq.moq_ResetMethod.Scene.T.Helper()
	return moqConverterer_ResetMethod_paramsKey{
		params: struct{}{},
		hashes: struct{}{},
	}
}

func (m *moqConverterer_recorder) AssertMethod() *moqConverterer_AssertMethod_recorder {
	return &moqConverterer_AssertMethod_recorder{
		recorder: m.moq.moq_AssertMethod.OnCall(moqConverterer_AssertMethod_params{}),
	}
}

func (r *moqConverterer_AssertMethod_recorder) any() *moqConverterer_AssertMethod_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqConverterer_AssertMethod_anyParams{recorder: r}
}

func (r *moqConverterer_AssertMethod_recorder) seq() *moqConverterer_AssertMethod_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqConverterer_AssertMethod_recorder) noSeq() *moqConverterer_AssertMethod_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqConverterer_AssertMethod_recorder) returnResults(funcDecl *dst.FuncDecl, err error) *moqConverterer_AssertMethod_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqConverterer_AssertMethod_results{
		funcDecl: funcDecl,
		err:      err,
	})
	return r
}

func (r *moqConverterer_AssertMethod_recorder) andDo(fn moqConverterer_AssertMethod_doFn) *moqConverterer_AssertMethod_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqConverterer_AssertMethod_params) {
		fn()
	}, false) {
		return nil
	}
	return r
}

func (r *moqConverterer_AssertMethod_recorder) doReturnResults(fn moqConverterer_AssertMethod_doReturnFn) *moqConverterer_AssertMethod_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqConverterer_AssertMethod_params) *moqConverterer_AssertMethod_results {
		funcDecl, err := fn()
		return &moqConverterer_AssertMethod_results{
			funcDecl: funcDecl,
			err:      err,
		}
	})
	return r
}

func (r *moqConverterer_AssertMethod_recorder) repeat(repeaters ...moq.Repeater) *moqConverterer_AssertMethod_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqConverterer_AssertMethod_adaptor) PrettyParams(params moqConverterer_AssertMethod_params) string {
	return fmt.Sprintf("AssertMethod()")
}

func (a *moqConverterer_AssertMethod_adaptor) ParamsKey(params moqConverterer_AssertMethod_params, anyParams uint64) moqConverterer_AssertMethod_paramsKey {
	a.moq.moq_AssertMethod.Scene.T.Helper()
	return moqConverterer_AssertMethod_paramsKey{
		params: struct{}{},
		hashes: struct{}{},
	}
}

// Reset resets the state of the moq
func (m *moqConverterer) Reset() {
	m.moq_BaseDecls.Reset()
	m.moq_MockStructs.Reset()
	m.moq_MethodStructs.Reset()
	m.moq_NewFunc.Reset()
	m.moq_IsolationAccessor.Reset()
	m.moq_FuncClosure.Reset()
	m.moq_MockMethod.Reset()
	m.moq_RecorderMethods.Reset()
	m.moq_ResetMethod.Reset()
	m.moq_AssertMethod.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *moqConverterer) AssertExpectationsMet() {
	m.moq_BaseDecls.Scene.T.Helper()
	m.moq_BaseDecls.AssertExpectationsMet()
	m.moq_MockStructs.AssertExpectationsMet()
	m.moq_MethodStructs.AssertExpectationsMet()
	m.moq_NewFunc.AssertExpectationsMet()
	m.moq_IsolationAccessor.AssertExpectationsMet()
	m.moq_FuncClosure.AssertExpectationsMet()
	m.moq_MockMethod.AssertExpectationsMet()
	m.moq_RecorderMethods.AssertExpectationsMet()
	m.moq_ResetMethod.AssertExpectationsMet()
	m.moq_AssertMethod.AssertExpectationsMet()
}
