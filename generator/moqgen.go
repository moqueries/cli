package generator

import (
	"errors"
	"fmt"
	"go/token"
	"path"
	"path/filepath"
	"strings"

	"github.com/dave/dst"
	"github.com/dave/dst/decorator"
	"github.com/dave/dst/decorator/resolver/goast"

	"github.com/myshkin5/moqueries/ast"
	"github.com/myshkin5/moqueries/logs"
)

const (
	headerComment = "// Code generated by Moqueries - https://github.com/myshkin5/moqueries - DO NOT EDIT!"
	testPkgSuffix = "_test"
)

// ErrInvalidConfig is returned when configuration values are invalid or
// conflict with each other
var ErrInvalidConfig = errors.New("invalid configuration")

// Type describes the type being converted into a mock
type Type struct {
	TypeSpec   *dst.TypeSpec
	Funcs      []Func
	InPkgPath  string
	OutPkgPath string
}

//go:generate moqueries GetwdFunc

// GetwdFunc is the signature of os.Getwd
type GetwdFunc func() (string, error)

//go:generate moqueries NewConverterFunc

// NewConverterFunc creates a new converter for a specific type
type NewConverterFunc func(typ Type, export bool) Converterer

//go:generate moqueries Converterer

// Converterer is the interface used by MoqGenerator to invoke a Converter
type Converterer interface {
	BaseStruct() (structDecl *dst.GenDecl)
	IsolationStruct(suffix string) (structDecl *dst.GenDecl)
	MethodStructs(fn Func) (structDecls []dst.Decl, err error)
	NewFunc() (funcDecl *dst.FuncDecl)
	IsolationAccessor(suffix, fnName string) (funcDecl *dst.FuncDecl)
	FuncClosure(fn Func) (funcDecl *dst.FuncDecl)
	MockMethod(fn Func) (funcDecl *dst.FuncDecl)
	RecorderMethods(fn Func) (funcDecls []dst.Decl)
	ResetMethod() (funcDecl *dst.FuncDecl)
	AssertMethod() (funcDecl *dst.FuncDecl)
}

// MoqGenerator generates moqs
type MoqGenerator struct {
	typeCache      TypeCache
	getwdFn        GetwdFunc
	newConverterFn NewConverterFunc
}

//go:generate moqueries TypeCache

// TypeCache defines the interface to the Cache type
type TypeCache interface {
	Type(id dst.Ident, testImport bool) (*dst.TypeSpec, string, error)
	IsComparable(expr dst.Expr) (bool, error)
	IsDefaultComparable(expr dst.Expr) (bool, error)
	FindPackage(dir string) (string, error)
}

// New returns a new MoqGenerator
func New(
	typeCache TypeCache,
	getwdFn GetwdFunc,
	newConverterFn NewConverterFunc,
) *MoqGenerator {
	return &MoqGenerator{
		typeCache:      typeCache,
		getwdFn:        getwdFn,
		newConverterFn: newConverterFn,
	}
}

// Generate generates moqs for the given types in the given destination package
func (g *MoqGenerator) Generate(req GenerateRequest) (*dst.File, string, error) {
	relPath, err := g.relativePath(req.WorkingDir)
	if err != nil {
		return nil, "", err
	}

	outPkgPath, err := g.outPackagePath(req, relPath)
	if err != nil {
		return nil, "", err
	}
	file := initializeFile(outPkgPath)

	imp := importPath(req.Import, relPath)

	destPath, err := destinationPath(req, relPath)
	if err != nil {
		return nil, "", err
	}

	var decls []dst.Decl
	for _, inType := range req.Types {
		typeSpec, inPkgPath, err := g.typeCache.Type(
			*ast.IdPath(inType, imp), req.TestImport)
		if err != nil {
			return nil, "", err
		}

		funcs, tErr := g.findFuncs(typeSpec)
		if tErr != nil {
			return nil, "", tErr
		}

		typ := Type{
			TypeSpec:   typeSpec,
			Funcs:      funcs,
			InPkgPath:  inPkgPath,
			OutPkgPath: outPkgPath,
		}
		converter := g.newConverterFn(typ, req.Export)

		structs, err := g.structs(converter, typ)
		if err != nil {
			return nil, "", err
		}
		decls = append(decls, structs...)

		decls = append(decls, converter.NewFunc())

		decls = append(decls, g.methods(converter, typ, funcs)...)

		decls = append(decls, converter.ResetMethod())

		decls = append(decls, converter.AssertMethod())
	}
	file.Decls = decls

	return file, destPath, nil
}

func (g *MoqGenerator) outPackagePath(req GenerateRequest, relPath string) (string, error) {
	destDir := path.Join(relPath, req.DestinationDir, req.Destination)
	if strings.HasSuffix(destDir, ".go") {
		destDir = filepath.Dir(destDir)
	}
	outPkgPath, err := g.typeCache.FindPackage(destDir)
	if err != nil {
		return "", err
	}
	if req.Package == "" || req.Package == "." {
		if !req.Export {
			outPkgPath += testPkgSuffix
		}
	} else {
		outPkgPath = path.Join(path.Dir(outPkgPath), req.Package)
	}
	logs.Debugf("Output package: %s", outPkgPath)
	return outPkgPath, nil
}

func initializeFile(pkg string) *dst.File {
	fSet := token.NewFileSet()

	base := filepath.Base(pkg)
	src := fmt.Sprintf("%s\n\npackage %s\n", headerComment, base)
	file, err := decorator.NewDecoratorWithImports(fSet, pkg, goast.New()).Parse(src)
	if err != nil {
		logs.Panic("Could not create decorator", err)
	}

	return file
}

func (g *MoqGenerator) relativePath(workingDir string) (string, error) {
	wd, err := g.getwdFn()
	if err != nil {
		return "", fmt.Errorf("error getting current working directory: %w", err)
	}

	if workingDir == wd {
		return ".", nil
	}

	relPath, err := filepath.Rel(wd, workingDir)
	if err != nil {
		return "", fmt.Errorf("error getting relative import path from %s to %s: %w",
			wd, workingDir, err)
	}

	return relPath, err
}

func importPath(imp, relPath string) string {
	if imp != "." && !strings.HasPrefix(imp, "./") {
		return imp
	}

	imp = filepath.Join(relPath, imp)
	if strings.HasPrefix(imp, ".") {
		return imp
	}

	// Relative imports must always start with a `.` and filepath.Join will
	// remove a prefixed `./` of a relative path
	return "./" + imp
}

func (g *MoqGenerator) findFuncs(typeSpec *dst.TypeSpec) ([]Func, error) {
	switch typ := typeSpec.Type.(type) {
	case *dst.InterfaceType:
		return g.loadNestedInterfaces(typ)
	case *dst.FuncType:
		return []Func{
			{
				Params:  typ.Params,
				Results: typ.Results,
			},
		}, nil
	case *dst.Ident:
		var funcs []Func
		return g.loadTypeEquivalent(funcs, typ)
	default:
		logs.Panicf("Unknown type: %v", typeSpec.Type)
		panic("unreachable")
	}
}

func (g *MoqGenerator) loadNestedInterfaces(iType *dst.InterfaceType) ([]Func, error) {
	var funcs []Func

	for _, method := range iType.Methods.List {
		switch typ := method.Type.(type) {
		case *dst.FuncType:
			funcs = append(funcs, Func{
				Name:    method.Names[0].Name,
				Params:  typ.Params,
				Results: typ.Results,
			})
		case *dst.Ident:
			var err error
			funcs, err = g.loadTypeEquivalent(funcs, typ)
			if err != nil {
				return nil, err
			}
		default:
			logs.Panicf("Unknown type in interface method list: %v", method.Type)
		}
	}

	return funcs, nil
}

func (g *MoqGenerator) loadTypeEquivalent(funcs []Func, id *dst.Ident) ([]Func, error) {
	nestedType, _, err := g.typeCache.Type(*id, false)
	if err != nil {
		return nil, err
	}

	newFuncs, err := g.findFuncs(nestedType)
	if err != nil {
		return nil, err
	}
	funcs = append(funcs, newFuncs...)

	return funcs, nil
}

func (g *MoqGenerator) structs(converter Converterer, typ Type) ([]dst.Decl, error) {
	decls := []dst.Decl{
		converter.BaseStruct(),
		converter.IsolationStruct(mockIdent),
	}

	_, iOk := typ.TypeSpec.Type.(*dst.InterfaceType)
	_, aOk := typ.TypeSpec.Type.(*dst.Ident)
	if iOk || aOk {
		decls = append(decls, converter.IsolationStruct(recorderIdent))
	}

	for _, fn := range typ.Funcs {
		structs, err := converter.MethodStructs(fn)
		if err != nil {
			return nil, err
		}
		decls = append(decls, structs...)
	}

	return decls, nil
}

func (g *MoqGenerator) methods(
	converter Converterer, typ Type, funcs []Func,
) []dst.Decl {
	var decls []dst.Decl

	switch typ.TypeSpec.Type.(type) {
	case *dst.InterfaceType, *dst.Ident:
		decls = append(
			decls, converter.IsolationAccessor(mockIdent, mockFnName))

		for _, fn := range funcs {
			decls = append(decls, converter.MockMethod(fn))
		}

		decls = append(
			decls, converter.IsolationAccessor(recorderIdent, onCallFnName))

		for _, fn := range funcs {
			decls = append(decls, converter.RecorderMethods(fn)...)
		}
	case *dst.FuncType:
		if len(funcs) != 1 {
			logs.Panicf("Function moqs should have just one function, found: %d",
				len(funcs))
		}

		decls = append(
			decls, converter.FuncClosure(funcs[0]))

		decls = append(
			decls, converter.MockMethod(funcs[0]))

		decls = append(
			decls, converter.RecorderMethods(funcs[0])...)
	default:
		logs.Panicf("Unknown type: %v", typ.TypeSpec.Type)
	}

	return decls
}

func destinationPath(req GenerateRequest, relPath string) (string, error) {
	if req.Export && strings.HasSuffix(req.Destination, "_test.go") {
		logs.Warn("Exported moq in a test file will not be accessible in" +
			" other packages. Remove --export option or set the --destination" +
			" to a non-test file.")
	}

	if req.Destination != "" && req.DestinationDir != "" {
		return "", fmt.Errorf("%w: both --destination and"+
			" --destination-dir flags must not be present together", ErrInvalidConfig)
	}

	destPath := req.Destination
	if destPath == "" {
		destPath = "moq_"
		for n, typ := range req.Types {
			destPath += strings.ToLower(typ)
			if n+1 < len(req.Types) {
				destPath += "_"
			}
		}
		if !req.Export || (req.Package != "" && strings.HasSuffix(req.Package, testPkgSuffix)) {
			destPath += testPkgSuffix
		}
		destPath += ".go"
	}

	return filepath.Join(relPath, req.DestinationDir, destPath), nil
}
