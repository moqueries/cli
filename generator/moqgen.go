package generator

import (
	"fmt"
	"go/token"
	"path"
	"path/filepath"
	"strings"

	"github.com/dave/dst"
	"github.com/dave/dst/decorator"
	"github.com/dave/dst/decorator/resolver/goast"

	"github.com/myshkin5/moqueries/ast"
	"github.com/myshkin5/moqueries/logs"
)

const (
	headerComment = "// Code generated by Moqueries - https://github.com/myshkin5/moqueries - DO NOT EDIT!"
	testPkgSuffix = "_test"
)

// Type describes the type being converted into a mock
type Type struct {
	TypeSpec   *dst.TypeSpec
	Funcs      []Func
	InPkgPath  string
	OutPkgPath string
}

//go:generate moqueries NewConverterFunc

// NewConverterFunc creates a new converter for a specific type
type NewConverterFunc func(typ Type, export bool) Converterer

//go:generate moqueries Converterer

// Converterer is the interface used by MoqGenerator to invoke a Converter
type Converterer interface {
	BaseStruct() (structDecl *dst.GenDecl)
	IsolationStruct(suffix string) (structDecl *dst.GenDecl)
	MethodStructs(fn Func) (structDecls []dst.Decl, err error)
	NewFunc() (funcDecl *dst.FuncDecl)
	IsolationAccessor(suffix, fnName string) (funcDecl *dst.FuncDecl)
	FuncClosure(fn Func) (funcDecl *dst.FuncDecl)
	MockMethod(fn Func) (funcDecl *dst.FuncDecl)
	RecorderMethods(fn Func) (funcDecls []dst.Decl)
	ResetMethod() (funcDecl *dst.FuncDecl)
	AssertMethod() (funcDecl *dst.FuncDecl)
}

// MoqGenerator generates moqs
type MoqGenerator struct {
	typeCache      TypeCache
	newConverterFn NewConverterFunc
}

//go:generate moqueries TypeCache

// TypeCache defines the interface to the Cache type
type TypeCache interface {
	Type(id dst.Ident, loadTestPkgs bool) (*dst.TypeSpec, string, error)
	IsComparable(expr dst.Expr) (bool, error)
	IsDefaultComparable(expr dst.Expr) (bool, error)
	FindPackage(dir string) (string, error)
}

// New returns a new MoqGenerator
func New(typeCache TypeCache, newConverterFn NewConverterFunc) *MoqGenerator {
	return &MoqGenerator{
		typeCache:      typeCache,
		newConverterFn: newConverterFn,
	}
}

// Generate generates moqs for the given types in the given destination package
func (g *MoqGenerator) Generate(req GenerateRequest) (*token.FileSet, *dst.File, error) {
	outPkgPath, err := g.outPackagePath(req)
	if err != nil {
		return nil, nil, err
	}
	fSet, file := initializeFile(outPkgPath)

	var decls []dst.Decl
	for _, inType := range req.Types {
		typeSpec, inPkgPath, err := g.loadInType(inType, req.Import, req.TestImport)
		if err != nil {
			return nil, nil, err
		}

		funcs, tErr := g.findFuncs(typeSpec)
		if tErr != nil {
			return nil, nil, tErr
		}

		typ := Type{
			TypeSpec:   typeSpec,
			Funcs:      funcs,
			InPkgPath:  inPkgPath,
			OutPkgPath: outPkgPath,
		}
		converter := g.newConverterFn(typ, req.Export)

		structs, err := g.structs(converter, typ)
		if err != nil {
			return nil, nil, err
		}
		decls = append(decls, structs...)

		decls = append(decls, converter.NewFunc())

		decls = append(decls, g.methods(converter, typ, funcs)...)

		decls = append(decls, converter.ResetMethod())

		decls = append(decls, converter.AssertMethod())
	}
	file.Decls = decls

	return fSet, file, nil
}

func (g *MoqGenerator) outPackagePath(req GenerateRequest) (string, error) {
	dest := path.Join(req.DestinationDir, req.Destination)
	outPkgPath, err := g.typeCache.FindPackage(filepath.Dir(dest))
	if err != nil {
		return "", err
	}
	if req.Package == "" || req.Package == "." {
		if !req.Export {
			outPkgPath += testPkgSuffix
		}
	} else {
		outPkgPath = path.Join(path.Dir(outPkgPath), req.Package)
	}
	logs.Debugf("Output package: %s", outPkgPath)
	return outPkgPath, nil
}

func initializeFile(pkg string) (*token.FileSet, *dst.File) {
	fSet := token.NewFileSet()

	base := filepath.Base(pkg)
	src := fmt.Sprintf("%s\n\npackage %s\n", headerComment, base)
	file, err := decorator.NewDecoratorWithImports(fSet, pkg, goast.New()).Parse(src)
	if err != nil {
		logs.Panic("Could not create decorator", err)
	}

	return fSet, file
}

func (g *MoqGenerator) loadInType(inType, imp string, loadTestPkgs bool) (
	*dst.TypeSpec, string, error,
) {
	if strings.HasSuffix(imp, testPkgSuffix) {
		imp = strings.TrimSuffix(imp, testPkgSuffix)
		loadTestPkgs = true
	}
	return g.typeCache.Type(*ast.IdPath(inType, imp), loadTestPkgs)
}

func (g *MoqGenerator) findFuncs(typeSpec *dst.TypeSpec) ([]Func, error) {
	switch typ := typeSpec.Type.(type) {
	case *dst.InterfaceType:
		return g.loadNestedInterfaces(typ)
	case *dst.FuncType:
		return []Func{
			{
				Params:  typ.Params,
				Results: typ.Results,
			},
		}, nil
	case *dst.Ident:
		var funcs []Func
		return g.loadTypeEquivalent(funcs, typ)
	default:
		logs.Panicf("Unknown type: %v", typeSpec.Type)
		panic("unreachable")
	}
}

func (g *MoqGenerator) loadNestedInterfaces(iType *dst.InterfaceType) ([]Func, error) {
	var funcs []Func

	for _, method := range iType.Methods.List {
		switch typ := method.Type.(type) {
		case *dst.FuncType:
			funcs = append(funcs, Func{
				Name:    method.Names[0].Name,
				Params:  typ.Params,
				Results: typ.Results,
			})
		case *dst.Ident:
			var err error
			funcs, err = g.loadTypeEquivalent(funcs, typ)
			if err != nil {
				return nil, err
			}
		default:
			logs.Panicf("Unknown type in interface method list: %v", method.Type)
		}
	}

	return funcs, nil
}

func (g *MoqGenerator) loadTypeEquivalent(funcs []Func, id *dst.Ident) ([]Func, error) {
	nestedType, _, err := g.typeCache.Type(*id, false)
	if err != nil {
		return nil, err
	}

	newFuncs, err := g.findFuncs(nestedType)
	if err != nil {
		return nil, err
	}
	funcs = append(funcs, newFuncs...)

	return funcs, nil
}

func (g *MoqGenerator) structs(converter Converterer, typ Type) ([]dst.Decl, error) {
	decls := []dst.Decl{
		converter.BaseStruct(),
		converter.IsolationStruct(mockIdent),
	}

	_, iOk := typ.TypeSpec.Type.(*dst.InterfaceType)
	_, aOk := typ.TypeSpec.Type.(*dst.Ident)
	if iOk || aOk {
		decls = append(decls, converter.IsolationStruct(recorderIdent))
	}

	for _, fn := range typ.Funcs {
		structs, err := converter.MethodStructs(fn)
		if err != nil {
			return nil, err
		}
		decls = append(decls, structs...)
	}

	return decls, nil
}

func (g *MoqGenerator) methods(
	converter Converterer, typ Type, funcs []Func,
) []dst.Decl {
	var decls []dst.Decl

	switch typ.TypeSpec.Type.(type) {
	case *dst.InterfaceType, *dst.Ident:
		decls = append(
			decls, converter.IsolationAccessor(mockIdent, mockFnName))

		for _, fn := range funcs {
			decls = append(decls, converter.MockMethod(fn))
		}

		decls = append(
			decls, converter.IsolationAccessor(recorderIdent, onCallFnName))

		for _, fn := range funcs {
			decls = append(decls, converter.RecorderMethods(fn)...)
		}
	case *dst.FuncType:
		if len(funcs) != 1 {
			logs.Panicf("Function moqs should have just one function, found: %d",
				len(funcs))
		}

		decls = append(
			decls, converter.FuncClosure(funcs[0]))

		decls = append(
			decls, converter.MockMethod(funcs[0]))

		decls = append(
			decls, converter.RecorderMethods(funcs[0])...)
	default:
		logs.Panicf("Unknown type: %v", typ.TypeSpec.Type)
	}

	return decls
}
