// Code generated by Moqueries - https://moqueries.org - DO NOT EDIT.

package testmoqs_test

import (
	"fmt"
	"io"
	"unsafe"

	"moqueries.org/cli/generator/testmoqs"
	"moqueries.org/cli/generator/testmoqs/other"
	"moqueries.org/runtime/hash"
	"moqueries.org/runtime/impl"
	"moqueries.org/runtime/moq"
)

// moqUsualFn holds the state of a moq of the UsualFn type
type moqUsualFn struct {
	moq *impl.Moq[
		*moqUsualFn_adaptor,
		moqUsualFn_params,
		moqUsualFn_paramsKey,
		moqUsualFn_results,
	]

	runtime moqUsualFn_runtime
}

// moqUsualFn_runtime holds runtime configuration for the UsualFn type
type moqUsualFn_runtime struct {
	parameterIndexing moqUsualFn_paramIndexing
}

// moqUsualFn_adaptor adapts moqUsualFn as needed by the runtime
type moqUsualFn_adaptor struct {
	moq *moqUsualFn
}

// moqUsualFn_params holds the params of the UsualFn type
type moqUsualFn_params struct {
	sParam string
	bParam bool
}

// moqUsualFn_paramsKey holds the map key params of the UsualFn type
type moqUsualFn_paramsKey struct {
	params struct {
		sParam string
		bParam bool
	}
	hashes struct {
		sParam hash.Hash
		bParam hash.Hash
	}
}

// moqUsualFn_results holds the results of the UsualFn type
type moqUsualFn_results struct {
	sResult string
	err     error
}

// moqUsualFn_paramIndexing holds the parameter indexing runtime configuration
// for the UsualFn type
type moqUsualFn_paramIndexing struct {
	sParam moq.ParamIndexing
	bParam moq.ParamIndexing
}

// moqUsualFn_doFn defines the type of function needed when calling andDo for
// the UsualFn type
type moqUsualFn_doFn func(sParam string, bParam bool)

// moqUsualFn_doReturnFn defines the type of function needed when calling
// doReturnResults for the UsualFn type
type moqUsualFn_doReturnFn func(sParam string, bParam bool) (sResult string, err error)

// moqUsualFn_recorder routes recorded function calls to the moqUsualFn moq
type moqUsualFn_recorder struct {
	recorder *impl.Recorder[
		*moqUsualFn_adaptor,
		moqUsualFn_params,
		moqUsualFn_paramsKey,
		moqUsualFn_results,
	]
}

// moqUsualFn_anyParams isolates the any params functions of the UsualFn type
type moqUsualFn_anyParams struct {
	recorder *moqUsualFn_recorder
}

// newMoqUsualFn creates a new moq of the UsualFn type
func newMoqUsualFn(scene *moq.Scene, config *moq.Config) *moqUsualFn {
	adaptor1 := &moqUsualFn_adaptor{}
	m := &moqUsualFn{
		moq: impl.NewMoq[
			*moqUsualFn_adaptor,
			moqUsualFn_params,
			moqUsualFn_paramsKey,
			moqUsualFn_results,
		](scene, adaptor1, config),

		runtime: moqUsualFn_runtime{parameterIndexing: moqUsualFn_paramIndexing{
			sParam: moq.ParamIndexByValue,
			bParam: moq.ParamIndexByValue,
		}},
	}
	adaptor1.moq = m

	scene.AddMoq(m)
	return m
}

// mock returns the moq implementation of the UsualFn type
func (m *moqUsualFn) mock() testmoqs.UsualFn {
	return func(sParam string, bParam bool) (string, error) {
		m.moq.Scene.T.Helper()
		params := moqUsualFn_params{
			sParam: sParam,
			bParam: bParam,
		}

		var result1 string
		var result2 error
		if result := m.moq.Function(params); result != nil {
			result1 = result.sResult
			result2 = result.err
		}
		return result1, result2
	}
}

func (m *moqUsualFn) onCall(sParam string, bParam bool) *moqUsualFn_recorder {
	return &moqUsualFn_recorder{
		recorder: m.moq.OnCall(moqUsualFn_params{
			sParam: sParam,
			bParam: bParam,
		}),
	}
}

func (r *moqUsualFn_recorder) any() *moqUsualFn_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqUsualFn_anyParams{recorder: r}
}

func (a *moqUsualFn_anyParams) sParam() *moqUsualFn_recorder {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (a *moqUsualFn_anyParams) bParam() *moqUsualFn_recorder {
	a.recorder.recorder.AnyParam(2)
	return a.recorder
}

func (r *moqUsualFn_recorder) seq() *moqUsualFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqUsualFn_recorder) noSeq() *moqUsualFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqUsualFn_recorder) returnResults(sResult string, err error) *moqUsualFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqUsualFn_results{
		sResult: sResult,
		err:     err,
	})
	return r
}

func (r *moqUsualFn_recorder) andDo(fn moqUsualFn_doFn) *moqUsualFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqUsualFn_params) {
		fn(params.sParam, params.bParam)
	}, false) {
		return nil
	}
	return r
}

func (r *moqUsualFn_recorder) doReturnResults(fn moqUsualFn_doReturnFn) *moqUsualFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqUsualFn_params) *moqUsualFn_results {
		sResult, err := fn(params.sParam, params.bParam)
		return &moqUsualFn_results{
			sResult: sResult,
			err:     err,
		}
	})
	return r
}

func (r *moqUsualFn_recorder) repeat(repeaters ...moq.Repeater) *moqUsualFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqUsualFn_adaptor) PrettyParams(params moqUsualFn_params) string {
	return fmt.Sprintf("UsualFn(%#v, %#v)", params.sParam, params.bParam)
}

func (a *moqUsualFn_adaptor) ParamsKey(params moqUsualFn_params, anyParams uint64) moqUsualFn_paramsKey {
	a.moq.moq.Scene.T.Helper()
	sParamUsed, sParamUsedHash := impl.ParamKey(
		params.sParam, 1, a.moq.runtime.parameterIndexing.sParam, anyParams)
	bParamUsed, bParamUsedHash := impl.ParamKey(
		params.bParam, 2, a.moq.runtime.parameterIndexing.bParam, anyParams)
	return moqUsualFn_paramsKey{
		params: struct {
			sParam string
			bParam bool
		}{
			sParam: sParamUsed,
			bParam: bParamUsed,
		},
		hashes: struct {
			sParam hash.Hash
			bParam hash.Hash
		}{
			sParam: sParamUsedHash,
			bParam: bParamUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *moqUsualFn) Reset() {
	m.moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *moqUsualFn) AssertExpectationsMet() {
	m.moq.Scene.T.Helper()
	m.moq.AssertExpectationsMet()
}

// moqNoNamesFn holds the state of a moq of the NoNamesFn type
type moqNoNamesFn struct {
	moq *impl.Moq[
		*moqNoNamesFn_adaptor,
		moqNoNamesFn_params,
		moqNoNamesFn_paramsKey,
		moqNoNamesFn_results,
	]

	runtime moqNoNamesFn_runtime
}

// moqNoNamesFn_runtime holds runtime configuration for the NoNamesFn type
type moqNoNamesFn_runtime struct {
	parameterIndexing moqNoNamesFn_paramIndexing
}

// moqNoNamesFn_adaptor adapts moqNoNamesFn as needed by the runtime
type moqNoNamesFn_adaptor struct {
	moq *moqNoNamesFn
}

// moqNoNamesFn_params holds the params of the NoNamesFn type
type moqNoNamesFn_params struct {
	param1 string
	param2 bool
}

// moqNoNamesFn_paramsKey holds the map key params of the NoNamesFn type
type moqNoNamesFn_paramsKey struct {
	params struct {
		param1 string
		param2 bool
	}
	hashes struct {
		param1 hash.Hash
		param2 hash.Hash
	}
}

// moqNoNamesFn_results holds the results of the NoNamesFn type
type moqNoNamesFn_results struct {
	result1 string
	result2 error
}

// moqNoNamesFn_paramIndexing holds the parameter indexing runtime
// configuration for the NoNamesFn type
type moqNoNamesFn_paramIndexing struct {
	param1 moq.ParamIndexing
	param2 moq.ParamIndexing
}

// moqNoNamesFn_doFn defines the type of function needed when calling andDo for
// the NoNamesFn type
type moqNoNamesFn_doFn func(string, bool)

// moqNoNamesFn_doReturnFn defines the type of function needed when calling
// doReturnResults for the NoNamesFn type
type moqNoNamesFn_doReturnFn func(string, bool) (string, error)

// moqNoNamesFn_recorder routes recorded function calls to the moqNoNamesFn moq
type moqNoNamesFn_recorder struct {
	recorder *impl.Recorder[
		*moqNoNamesFn_adaptor,
		moqNoNamesFn_params,
		moqNoNamesFn_paramsKey,
		moqNoNamesFn_results,
	]
}

// moqNoNamesFn_anyParams isolates the any params functions of the NoNamesFn
// type
type moqNoNamesFn_anyParams struct {
	recorder *moqNoNamesFn_recorder
}

// newMoqNoNamesFn creates a new moq of the NoNamesFn type
func newMoqNoNamesFn(scene *moq.Scene, config *moq.Config) *moqNoNamesFn {
	adaptor1 := &moqNoNamesFn_adaptor{}
	m := &moqNoNamesFn{
		moq: impl.NewMoq[
			*moqNoNamesFn_adaptor,
			moqNoNamesFn_params,
			moqNoNamesFn_paramsKey,
			moqNoNamesFn_results,
		](scene, adaptor1, config),

		runtime: moqNoNamesFn_runtime{parameterIndexing: moqNoNamesFn_paramIndexing{
			param1: moq.ParamIndexByValue,
			param2: moq.ParamIndexByValue,
		}},
	}
	adaptor1.moq = m

	scene.AddMoq(m)
	return m
}

// mock returns the moq implementation of the NoNamesFn type
func (m *moqNoNamesFn) mock() testmoqs.NoNamesFn {
	return func(param1 string, param2 bool) (string, error) {
		m.moq.Scene.T.Helper()
		params := moqNoNamesFn_params{
			param1: param1,
			param2: param2,
		}

		var result1 string
		var result2 error
		if result := m.moq.Function(params); result != nil {
			result1 = result.result1
			result2 = result.result2
		}
		return result1, result2
	}
}

func (m *moqNoNamesFn) onCall(param1 string, param2 bool) *moqNoNamesFn_recorder {
	return &moqNoNamesFn_recorder{
		recorder: m.moq.OnCall(moqNoNamesFn_params{
			param1: param1,
			param2: param2,
		}),
	}
}

func (r *moqNoNamesFn_recorder) any() *moqNoNamesFn_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqNoNamesFn_anyParams{recorder: r}
}

func (a *moqNoNamesFn_anyParams) param1() *moqNoNamesFn_recorder {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (a *moqNoNamesFn_anyParams) param2() *moqNoNamesFn_recorder {
	a.recorder.recorder.AnyParam(2)
	return a.recorder
}

func (r *moqNoNamesFn_recorder) seq() *moqNoNamesFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqNoNamesFn_recorder) noSeq() *moqNoNamesFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqNoNamesFn_recorder) returnResults(result1 string, result2 error) *moqNoNamesFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqNoNamesFn_results{
		result1: result1,
		result2: result2,
	})
	return r
}

func (r *moqNoNamesFn_recorder) andDo(fn moqNoNamesFn_doFn) *moqNoNamesFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqNoNamesFn_params) {
		fn(params.param1, params.param2)
	}, false) {
		return nil
	}
	return r
}

func (r *moqNoNamesFn_recorder) doReturnResults(fn moqNoNamesFn_doReturnFn) *moqNoNamesFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqNoNamesFn_params) *moqNoNamesFn_results {
		result1, result2 := fn(params.param1, params.param2)
		return &moqNoNamesFn_results{
			result1: result1,
			result2: result2,
		}
	})
	return r
}

func (r *moqNoNamesFn_recorder) repeat(repeaters ...moq.Repeater) *moqNoNamesFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqNoNamesFn_adaptor) PrettyParams(params moqNoNamesFn_params) string {
	return fmt.Sprintf("NoNamesFn(%#v, %#v)", params.param1, params.param2)
}

func (a *moqNoNamesFn_adaptor) ParamsKey(params moqNoNamesFn_params, anyParams uint64) moqNoNamesFn_paramsKey {
	a.moq.moq.Scene.T.Helper()
	param1Used, param1UsedHash := impl.ParamKey(
		params.param1, 1, a.moq.runtime.parameterIndexing.param1, anyParams)
	param2Used, param2UsedHash := impl.ParamKey(
		params.param2, 2, a.moq.runtime.parameterIndexing.param2, anyParams)
	return moqNoNamesFn_paramsKey{
		params: struct {
			param1 string
			param2 bool
		}{
			param1: param1Used,
			param2: param2Used,
		},
		hashes: struct {
			param1 hash.Hash
			param2 hash.Hash
		}{
			param1: param1UsedHash,
			param2: param2UsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *moqNoNamesFn) Reset() {
	m.moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *moqNoNamesFn) AssertExpectationsMet() {
	m.moq.Scene.T.Helper()
	m.moq.AssertExpectationsMet()
}

// moqNoResultsFn holds the state of a moq of the NoResultsFn type
type moqNoResultsFn struct {
	moq *impl.Moq[
		*moqNoResultsFn_adaptor,
		moqNoResultsFn_params,
		moqNoResultsFn_paramsKey,
		moqNoResultsFn_results,
	]

	runtime moqNoResultsFn_runtime
}

// moqNoResultsFn_runtime holds runtime configuration for the NoResultsFn type
type moqNoResultsFn_runtime struct {
	parameterIndexing moqNoResultsFn_paramIndexing
}

// moqNoResultsFn_adaptor adapts moqNoResultsFn as needed by the runtime
type moqNoResultsFn_adaptor struct {
	moq *moqNoResultsFn
}

// moqNoResultsFn_params holds the params of the NoResultsFn type
type moqNoResultsFn_params struct {
	sParam string
	bParam bool
}

// moqNoResultsFn_paramsKey holds the map key params of the NoResultsFn type
type moqNoResultsFn_paramsKey struct {
	params struct {
		sParam string
		bParam bool
	}
	hashes struct {
		sParam hash.Hash
		bParam hash.Hash
	}
}

// moqNoResultsFn_results holds the results of the NoResultsFn type
type moqNoResultsFn_results struct{}

// moqNoResultsFn_paramIndexing holds the parameter indexing runtime
// configuration for the NoResultsFn type
type moqNoResultsFn_paramIndexing struct {
	sParam moq.ParamIndexing
	bParam moq.ParamIndexing
}

// moqNoResultsFn_doFn defines the type of function needed when calling andDo
// for the NoResultsFn type
type moqNoResultsFn_doFn func(sParam string, bParam bool)

// moqNoResultsFn_doReturnFn defines the type of function needed when calling
// doReturnResults for the NoResultsFn type
type moqNoResultsFn_doReturnFn func(sParam string, bParam bool)

// moqNoResultsFn_recorder routes recorded function calls to the moqNoResultsFn
// moq
type moqNoResultsFn_recorder struct {
	recorder *impl.Recorder[
		*moqNoResultsFn_adaptor,
		moqNoResultsFn_params,
		moqNoResultsFn_paramsKey,
		moqNoResultsFn_results,
	]
}

// moqNoResultsFn_anyParams isolates the any params functions of the
// NoResultsFn type
type moqNoResultsFn_anyParams struct {
	recorder *moqNoResultsFn_recorder
}

// newMoqNoResultsFn creates a new moq of the NoResultsFn type
func newMoqNoResultsFn(scene *moq.Scene, config *moq.Config) *moqNoResultsFn {
	adaptor1 := &moqNoResultsFn_adaptor{}
	m := &moqNoResultsFn{
		moq: impl.NewMoq[
			*moqNoResultsFn_adaptor,
			moqNoResultsFn_params,
			moqNoResultsFn_paramsKey,
			moqNoResultsFn_results,
		](scene, adaptor1, config),

		runtime: moqNoResultsFn_runtime{parameterIndexing: moqNoResultsFn_paramIndexing{
			sParam: moq.ParamIndexByValue,
			bParam: moq.ParamIndexByValue,
		}},
	}
	adaptor1.moq = m

	scene.AddMoq(m)
	return m
}

// mock returns the moq implementation of the NoResultsFn type
func (m *moqNoResultsFn) mock() testmoqs.NoResultsFn {
	return func(sParam string, bParam bool) {
		m.moq.Scene.T.Helper()
		params := moqNoResultsFn_params{
			sParam: sParam,
			bParam: bParam,
		}

		m.moq.Function(params)
	}
}

func (m *moqNoResultsFn) onCall(sParam string, bParam bool) *moqNoResultsFn_recorder {
	return &moqNoResultsFn_recorder{
		recorder: m.moq.OnCall(moqNoResultsFn_params{
			sParam: sParam,
			bParam: bParam,
		}),
	}
}

func (r *moqNoResultsFn_recorder) any() *moqNoResultsFn_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqNoResultsFn_anyParams{recorder: r}
}

func (a *moqNoResultsFn_anyParams) sParam() *moqNoResultsFn_recorder {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (a *moqNoResultsFn_anyParams) bParam() *moqNoResultsFn_recorder {
	a.recorder.recorder.AnyParam(2)
	return a.recorder
}

func (r *moqNoResultsFn_recorder) seq() *moqNoResultsFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqNoResultsFn_recorder) noSeq() *moqNoResultsFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqNoResultsFn_recorder) returnResults() *moqNoResultsFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqNoResultsFn_results{})
	return r
}

func (r *moqNoResultsFn_recorder) andDo(fn moqNoResultsFn_doFn) *moqNoResultsFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqNoResultsFn_params) {
		fn(params.sParam, params.bParam)
	}, false) {
		return nil
	}
	return r
}

func (r *moqNoResultsFn_recorder) doReturnResults(fn moqNoResultsFn_doReturnFn) *moqNoResultsFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqNoResultsFn_params) *moqNoResultsFn_results {
		fn(params.sParam, params.bParam)
		return &moqNoResultsFn_results{}
	})
	return r
}

func (r *moqNoResultsFn_recorder) repeat(repeaters ...moq.Repeater) *moqNoResultsFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqNoResultsFn_adaptor) PrettyParams(params moqNoResultsFn_params) string {
	return fmt.Sprintf("NoResultsFn(%#v, %#v)", params.sParam, params.bParam)
}

func (a *moqNoResultsFn_adaptor) ParamsKey(params moqNoResultsFn_params, anyParams uint64) moqNoResultsFn_paramsKey {
	a.moq.moq.Scene.T.Helper()
	sParamUsed, sParamUsedHash := impl.ParamKey(
		params.sParam, 1, a.moq.runtime.parameterIndexing.sParam, anyParams)
	bParamUsed, bParamUsedHash := impl.ParamKey(
		params.bParam, 2, a.moq.runtime.parameterIndexing.bParam, anyParams)
	return moqNoResultsFn_paramsKey{
		params: struct {
			sParam string
			bParam bool
		}{
			sParam: sParamUsed,
			bParam: bParamUsed,
		},
		hashes: struct {
			sParam hash.Hash
			bParam hash.Hash
		}{
			sParam: sParamUsedHash,
			bParam: bParamUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *moqNoResultsFn) Reset() {
	m.moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *moqNoResultsFn) AssertExpectationsMet() {
	m.moq.Scene.T.Helper()
	m.moq.AssertExpectationsMet()
}

// moqNoParamsFn holds the state of a moq of the NoParamsFn type
type moqNoParamsFn struct {
	moq *impl.Moq[
		*moqNoParamsFn_adaptor,
		moqNoParamsFn_params,
		moqNoParamsFn_paramsKey,
		moqNoParamsFn_results,
	]

	runtime moqNoParamsFn_runtime
}

// moqNoParamsFn_runtime holds runtime configuration for the NoParamsFn type
type moqNoParamsFn_runtime struct {
	parameterIndexing moqNoParamsFn_paramIndexing
}

// moqNoParamsFn_adaptor adapts moqNoParamsFn as needed by the runtime
type moqNoParamsFn_adaptor struct {
	moq *moqNoParamsFn
}

// moqNoParamsFn_params holds the params of the NoParamsFn type
type moqNoParamsFn_params struct{}

// moqNoParamsFn_paramsKey holds the map key params of the NoParamsFn type
type moqNoParamsFn_paramsKey struct {
	params struct{}
	hashes struct{}
}

// moqNoParamsFn_results holds the results of the NoParamsFn type
type moqNoParamsFn_results struct {
	sResult string
	err     error
}

// moqNoParamsFn_paramIndexing holds the parameter indexing runtime
// configuration for the NoParamsFn type
type moqNoParamsFn_paramIndexing struct{}

// moqNoParamsFn_doFn defines the type of function needed when calling andDo
// for the NoParamsFn type
type moqNoParamsFn_doFn func()

// moqNoParamsFn_doReturnFn defines the type of function needed when calling
// doReturnResults for the NoParamsFn type
type moqNoParamsFn_doReturnFn func() (sResult string, err error)

// moqNoParamsFn_recorder routes recorded function calls to the moqNoParamsFn
// moq
type moqNoParamsFn_recorder struct {
	recorder *impl.Recorder[
		*moqNoParamsFn_adaptor,
		moqNoParamsFn_params,
		moqNoParamsFn_paramsKey,
		moqNoParamsFn_results,
	]
}

// moqNoParamsFn_anyParams isolates the any params functions of the NoParamsFn
// type
type moqNoParamsFn_anyParams struct {
	recorder *moqNoParamsFn_recorder
}

// newMoqNoParamsFn creates a new moq of the NoParamsFn type
func newMoqNoParamsFn(scene *moq.Scene, config *moq.Config) *moqNoParamsFn {
	adaptor1 := &moqNoParamsFn_adaptor{}
	m := &moqNoParamsFn{
		moq: impl.NewMoq[
			*moqNoParamsFn_adaptor,
			moqNoParamsFn_params,
			moqNoParamsFn_paramsKey,
			moqNoParamsFn_results,
		](scene, adaptor1, config),

		runtime: moqNoParamsFn_runtime{parameterIndexing: moqNoParamsFn_paramIndexing{}},
	}
	adaptor1.moq = m

	scene.AddMoq(m)
	return m
}

// mock returns the moq implementation of the NoParamsFn type
func (m *moqNoParamsFn) mock() testmoqs.NoParamsFn {
	return func() (string, error) {
		m.moq.Scene.T.Helper()
		params := moqNoParamsFn_params{}

		var result1 string
		var result2 error
		if result := m.moq.Function(params); result != nil {
			result1 = result.sResult
			result2 = result.err
		}
		return result1, result2
	}
}

func (m *moqNoParamsFn) onCall() *moqNoParamsFn_recorder {
	return &moqNoParamsFn_recorder{
		recorder: m.moq.OnCall(moqNoParamsFn_params{}),
	}
}

func (r *moqNoParamsFn_recorder) any() *moqNoParamsFn_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqNoParamsFn_anyParams{recorder: r}
}

func (r *moqNoParamsFn_recorder) seq() *moqNoParamsFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqNoParamsFn_recorder) noSeq() *moqNoParamsFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqNoParamsFn_recorder) returnResults(sResult string, err error) *moqNoParamsFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqNoParamsFn_results{
		sResult: sResult,
		err:     err,
	})
	return r
}

func (r *moqNoParamsFn_recorder) andDo(fn moqNoParamsFn_doFn) *moqNoParamsFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqNoParamsFn_params) {
		fn()
	}, false) {
		return nil
	}
	return r
}

func (r *moqNoParamsFn_recorder) doReturnResults(fn moqNoParamsFn_doReturnFn) *moqNoParamsFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqNoParamsFn_params) *moqNoParamsFn_results {
		sResult, err := fn()
		return &moqNoParamsFn_results{
			sResult: sResult,
			err:     err,
		}
	})
	return r
}

func (r *moqNoParamsFn_recorder) repeat(repeaters ...moq.Repeater) *moqNoParamsFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqNoParamsFn_adaptor) PrettyParams(params moqNoParamsFn_params) string {
	return fmt.Sprintf("NoParamsFn()")
}

func (a *moqNoParamsFn_adaptor) ParamsKey(params moqNoParamsFn_params, anyParams uint64) moqNoParamsFn_paramsKey {
	a.moq.moq.Scene.T.Helper()
	return moqNoParamsFn_paramsKey{
		params: struct{}{},
		hashes: struct{}{},
	}
}

// Reset resets the state of the moq
func (m *moqNoParamsFn) Reset() {
	m.moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *moqNoParamsFn) AssertExpectationsMet() {
	m.moq.Scene.T.Helper()
	m.moq.AssertExpectationsMet()
}

// moqNothingFn holds the state of a moq of the NothingFn type
type moqNothingFn struct {
	moq *impl.Moq[
		*moqNothingFn_adaptor,
		moqNothingFn_params,
		moqNothingFn_paramsKey,
		moqNothingFn_results,
	]

	runtime moqNothingFn_runtime
}

// moqNothingFn_runtime holds runtime configuration for the NothingFn type
type moqNothingFn_runtime struct {
	parameterIndexing moqNothingFn_paramIndexing
}

// moqNothingFn_adaptor adapts moqNothingFn as needed by the runtime
type moqNothingFn_adaptor struct {
	moq *moqNothingFn
}

// moqNothingFn_params holds the params of the NothingFn type
type moqNothingFn_params struct{}

// moqNothingFn_paramsKey holds the map key params of the NothingFn type
type moqNothingFn_paramsKey struct {
	params struct{}
	hashes struct{}
}

// moqNothingFn_results holds the results of the NothingFn type
type moqNothingFn_results struct{}

// moqNothingFn_paramIndexing holds the parameter indexing runtime
// configuration for the NothingFn type
type moqNothingFn_paramIndexing struct{}

// moqNothingFn_doFn defines the type of function needed when calling andDo for
// the NothingFn type
type moqNothingFn_doFn func()

// moqNothingFn_doReturnFn defines the type of function needed when calling
// doReturnResults for the NothingFn type
type moqNothingFn_doReturnFn func()

// moqNothingFn_recorder routes recorded function calls to the moqNothingFn moq
type moqNothingFn_recorder struct {
	recorder *impl.Recorder[
		*moqNothingFn_adaptor,
		moqNothingFn_params,
		moqNothingFn_paramsKey,
		moqNothingFn_results,
	]
}

// moqNothingFn_anyParams isolates the any params functions of the NothingFn
// type
type moqNothingFn_anyParams struct {
	recorder *moqNothingFn_recorder
}

// newMoqNothingFn creates a new moq of the NothingFn type
func newMoqNothingFn(scene *moq.Scene, config *moq.Config) *moqNothingFn {
	adaptor1 := &moqNothingFn_adaptor{}
	m := &moqNothingFn{
		moq: impl.NewMoq[
			*moqNothingFn_adaptor,
			moqNothingFn_params,
			moqNothingFn_paramsKey,
			moqNothingFn_results,
		](scene, adaptor1, config),

		runtime: moqNothingFn_runtime{parameterIndexing: moqNothingFn_paramIndexing{}},
	}
	adaptor1.moq = m

	scene.AddMoq(m)
	return m
}

// mock returns the moq implementation of the NothingFn type
func (m *moqNothingFn) mock() testmoqs.NothingFn {
	return func() {
		m.moq.Scene.T.Helper()
		params := moqNothingFn_params{}

		m.moq.Function(params)
	}
}

func (m *moqNothingFn) onCall() *moqNothingFn_recorder {
	return &moqNothingFn_recorder{
		recorder: m.moq.OnCall(moqNothingFn_params{}),
	}
}

func (r *moqNothingFn_recorder) any() *moqNothingFn_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqNothingFn_anyParams{recorder: r}
}

func (r *moqNothingFn_recorder) seq() *moqNothingFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqNothingFn_recorder) noSeq() *moqNothingFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqNothingFn_recorder) returnResults() *moqNothingFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqNothingFn_results{})
	return r
}

func (r *moqNothingFn_recorder) andDo(fn moqNothingFn_doFn) *moqNothingFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqNothingFn_params) {
		fn()
	}, false) {
		return nil
	}
	return r
}

func (r *moqNothingFn_recorder) doReturnResults(fn moqNothingFn_doReturnFn) *moqNothingFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqNothingFn_params) *moqNothingFn_results {
		fn()
		return &moqNothingFn_results{}
	})
	return r
}

func (r *moqNothingFn_recorder) repeat(repeaters ...moq.Repeater) *moqNothingFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqNothingFn_adaptor) PrettyParams(params moqNothingFn_params) string {
	return fmt.Sprintf("NothingFn()")
}

func (a *moqNothingFn_adaptor) ParamsKey(params moqNothingFn_params, anyParams uint64) moqNothingFn_paramsKey {
	a.moq.moq.Scene.T.Helper()
	return moqNothingFn_paramsKey{
		params: struct{}{},
		hashes: struct{}{},
	}
}

// Reset resets the state of the moq
func (m *moqNothingFn) Reset() {
	m.moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *moqNothingFn) AssertExpectationsMet() {
	m.moq.Scene.T.Helper()
	m.moq.AssertExpectationsMet()
}

// moqVariadicFn holds the state of a moq of the VariadicFn type
type moqVariadicFn struct {
	moq *impl.Moq[
		*moqVariadicFn_adaptor,
		moqVariadicFn_params,
		moqVariadicFn_paramsKey,
		moqVariadicFn_results,
	]

	runtime moqVariadicFn_runtime
}

// moqVariadicFn_runtime holds runtime configuration for the VariadicFn type
type moqVariadicFn_runtime struct {
	parameterIndexing moqVariadicFn_paramIndexing
}

// moqVariadicFn_adaptor adapts moqVariadicFn as needed by the runtime
type moqVariadicFn_adaptor struct {
	moq *moqVariadicFn
}

// moqVariadicFn_params holds the params of the VariadicFn type
type moqVariadicFn_params struct {
	other bool
	args  []string
}

// moqVariadicFn_paramsKey holds the map key params of the VariadicFn type
type moqVariadicFn_paramsKey struct {
	params struct{ other bool }
	hashes struct {
		other hash.Hash
		args  hash.Hash
	}
}

// moqVariadicFn_results holds the results of the VariadicFn type
type moqVariadicFn_results struct {
	sResult string
	err     error
}

// moqVariadicFn_paramIndexing holds the parameter indexing runtime
// configuration for the VariadicFn type
type moqVariadicFn_paramIndexing struct {
	other moq.ParamIndexing
	args  moq.ParamIndexing
}

// moqVariadicFn_doFn defines the type of function needed when calling andDo
// for the VariadicFn type
type moqVariadicFn_doFn func(other bool, args ...string)

// moqVariadicFn_doReturnFn defines the type of function needed when calling
// doReturnResults for the VariadicFn type
type moqVariadicFn_doReturnFn func(other bool, args ...string) (sResult string, err error)

// moqVariadicFn_recorder routes recorded function calls to the moqVariadicFn
// moq
type moqVariadicFn_recorder struct {
	recorder *impl.Recorder[
		*moqVariadicFn_adaptor,
		moqVariadicFn_params,
		moqVariadicFn_paramsKey,
		moqVariadicFn_results,
	]
}

// moqVariadicFn_anyParams isolates the any params functions of the VariadicFn
// type
type moqVariadicFn_anyParams struct {
	recorder *moqVariadicFn_recorder
}

// newMoqVariadicFn creates a new moq of the VariadicFn type
func newMoqVariadicFn(scene *moq.Scene, config *moq.Config) *moqVariadicFn {
	adaptor1 := &moqVariadicFn_adaptor{}
	m := &moqVariadicFn{
		moq: impl.NewMoq[
			*moqVariadicFn_adaptor,
			moqVariadicFn_params,
			moqVariadicFn_paramsKey,
			moqVariadicFn_results,
		](scene, adaptor1, config),

		runtime: moqVariadicFn_runtime{parameterIndexing: moqVariadicFn_paramIndexing{
			other: moq.ParamIndexByValue,
			args:  moq.ParamIndexByHash,
		}},
	}
	adaptor1.moq = m

	scene.AddMoq(m)
	return m
}

// mock returns the moq implementation of the VariadicFn type
func (m *moqVariadicFn) mock() testmoqs.VariadicFn {
	return func(other bool, args ...string) (string, error) {
		m.moq.Scene.T.Helper()
		params := moqVariadicFn_params{
			other: other,
			args:  args,
		}

		var result1 string
		var result2 error
		if result := m.moq.Function(params); result != nil {
			result1 = result.sResult
			result2 = result.err
		}
		return result1, result2
	}
}

func (m *moqVariadicFn) onCall(other bool, args ...string) *moqVariadicFn_recorder {
	return &moqVariadicFn_recorder{
		recorder: m.moq.OnCall(moqVariadicFn_params{
			other: other,
			args:  args,
		}),
	}
}

func (r *moqVariadicFn_recorder) any() *moqVariadicFn_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqVariadicFn_anyParams{recorder: r}
}

func (a *moqVariadicFn_anyParams) other() *moqVariadicFn_recorder {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (a *moqVariadicFn_anyParams) args() *moqVariadicFn_recorder {
	a.recorder.recorder.AnyParam(2)
	return a.recorder
}

func (r *moqVariadicFn_recorder) seq() *moqVariadicFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqVariadicFn_recorder) noSeq() *moqVariadicFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqVariadicFn_recorder) returnResults(sResult string, err error) *moqVariadicFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqVariadicFn_results{
		sResult: sResult,
		err:     err,
	})
	return r
}

func (r *moqVariadicFn_recorder) andDo(fn moqVariadicFn_doFn) *moqVariadicFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqVariadicFn_params) {
		fn(params.other, params.args...)
	}, false) {
		return nil
	}
	return r
}

func (r *moqVariadicFn_recorder) doReturnResults(fn moqVariadicFn_doReturnFn) *moqVariadicFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqVariadicFn_params) *moqVariadicFn_results {
		sResult, err := fn(params.other, params.args...)
		return &moqVariadicFn_results{
			sResult: sResult,
			err:     err,
		}
	})
	return r
}

func (r *moqVariadicFn_recorder) repeat(repeaters ...moq.Repeater) *moqVariadicFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqVariadicFn_adaptor) PrettyParams(params moqVariadicFn_params) string {
	return fmt.Sprintf("VariadicFn(%#v, %#v)", params.other, params.args)
}

func (a *moqVariadicFn_adaptor) ParamsKey(params moqVariadicFn_params, anyParams uint64) moqVariadicFn_paramsKey {
	a.moq.moq.Scene.T.Helper()
	otherUsed, otherUsedHash := impl.ParamKey(
		params.other, 1, a.moq.runtime.parameterIndexing.other, anyParams)
	argsUsedHash := impl.HashOnlyParamKey(a.moq.moq.Scene.T,
		params.args, "args", 2, a.moq.runtime.parameterIndexing.args, anyParams)
	return moqVariadicFn_paramsKey{
		params: struct{ other bool }{
			other: otherUsed,
		},
		hashes: struct {
			other hash.Hash
			args  hash.Hash
		}{
			other: otherUsedHash,
			args:  argsUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *moqVariadicFn) Reset() {
	m.moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *moqVariadicFn) AssertExpectationsMet() {
	m.moq.Scene.T.Helper()
	m.moq.AssertExpectationsMet()
}

// moqRepeatedIdsFn holds the state of a moq of the RepeatedIdsFn type
type moqRepeatedIdsFn struct {
	moq *impl.Moq[
		*moqRepeatedIdsFn_adaptor,
		moqRepeatedIdsFn_params,
		moqRepeatedIdsFn_paramsKey,
		moqRepeatedIdsFn_results,
	]

	runtime moqRepeatedIdsFn_runtime
}

// moqRepeatedIdsFn_runtime holds runtime configuration for the RepeatedIdsFn
// type
type moqRepeatedIdsFn_runtime struct {
	parameterIndexing moqRepeatedIdsFn_paramIndexing
}

// moqRepeatedIdsFn_adaptor adapts moqRepeatedIdsFn as needed by the runtime
type moqRepeatedIdsFn_adaptor struct {
	moq *moqRepeatedIdsFn
}

// moqRepeatedIdsFn_params holds the params of the RepeatedIdsFn type
type moqRepeatedIdsFn_params struct {
	sParam1, sParam2 string
	bParam           bool
}

// moqRepeatedIdsFn_paramsKey holds the map key params of the RepeatedIdsFn
// type
type moqRepeatedIdsFn_paramsKey struct {
	params struct {
		sParam1, sParam2 string
		bParam           bool
	}
	hashes struct {
		sParam1, sParam2 hash.Hash
		bParam           hash.Hash
	}
}

// moqRepeatedIdsFn_results holds the results of the RepeatedIdsFn type
type moqRepeatedIdsFn_results struct {
	sResult1, sResult2 string
	err                error
}

// moqRepeatedIdsFn_paramIndexing holds the parameter indexing runtime
// configuration for the RepeatedIdsFn type
type moqRepeatedIdsFn_paramIndexing struct {
	sParam1, sParam2 moq.ParamIndexing
	bParam           moq.ParamIndexing
}

// moqRepeatedIdsFn_doFn defines the type of function needed when calling andDo
// for the RepeatedIdsFn type
type moqRepeatedIdsFn_doFn func(sParam1, sParam2 string, bParam bool)

// moqRepeatedIdsFn_doReturnFn defines the type of function needed when calling
// doReturnResults for the RepeatedIdsFn type
type moqRepeatedIdsFn_doReturnFn func(sParam1, sParam2 string, bParam bool) (sResult1, sResult2 string, err error)

// moqRepeatedIdsFn_recorder routes recorded function calls to the
// moqRepeatedIdsFn moq
type moqRepeatedIdsFn_recorder struct {
	recorder *impl.Recorder[
		*moqRepeatedIdsFn_adaptor,
		moqRepeatedIdsFn_params,
		moqRepeatedIdsFn_paramsKey,
		moqRepeatedIdsFn_results,
	]
}

// moqRepeatedIdsFn_anyParams isolates the any params functions of the
// RepeatedIdsFn type
type moqRepeatedIdsFn_anyParams struct {
	recorder *moqRepeatedIdsFn_recorder
}

// newMoqRepeatedIdsFn creates a new moq of the RepeatedIdsFn type
func newMoqRepeatedIdsFn(scene *moq.Scene, config *moq.Config) *moqRepeatedIdsFn {
	adaptor1 := &moqRepeatedIdsFn_adaptor{}
	m := &moqRepeatedIdsFn{
		moq: impl.NewMoq[
			*moqRepeatedIdsFn_adaptor,
			moqRepeatedIdsFn_params,
			moqRepeatedIdsFn_paramsKey,
			moqRepeatedIdsFn_results,
		](scene, adaptor1, config),

		runtime: moqRepeatedIdsFn_runtime{parameterIndexing: moqRepeatedIdsFn_paramIndexing{
			sParam1: moq.ParamIndexByValue,
			sParam2: moq.ParamIndexByValue,
			bParam:  moq.ParamIndexByValue,
		}},
	}
	adaptor1.moq = m

	scene.AddMoq(m)
	return m
}

// mock returns the moq implementation of the RepeatedIdsFn type
func (m *moqRepeatedIdsFn) mock() testmoqs.RepeatedIdsFn {
	return func(sParam1, sParam2 string, bParam bool) (string, string, error) {
		m.moq.Scene.T.Helper()
		params := moqRepeatedIdsFn_params{
			sParam1: sParam1,
			sParam2: sParam2,
			bParam:  bParam,
		}

		var result1 string
		var result2 string
		var result3 error
		if result := m.moq.Function(params); result != nil {
			result1 = result.sResult1
			result2 = result.sResult2
			result3 = result.err
		}
		return result1, result2, result3
	}
}

func (m *moqRepeatedIdsFn) onCall(sParam1, sParam2 string, bParam bool) *moqRepeatedIdsFn_recorder {
	return &moqRepeatedIdsFn_recorder{
		recorder: m.moq.OnCall(moqRepeatedIdsFn_params{
			sParam1: sParam1,
			sParam2: sParam2,
			bParam:  bParam,
		}),
	}
}

func (r *moqRepeatedIdsFn_recorder) any() *moqRepeatedIdsFn_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqRepeatedIdsFn_anyParams{recorder: r}
}

func (a *moqRepeatedIdsFn_anyParams) sParam1() *moqRepeatedIdsFn_recorder {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (a *moqRepeatedIdsFn_anyParams) sParam2() *moqRepeatedIdsFn_recorder {
	a.recorder.recorder.AnyParam(2)
	return a.recorder
}

func (a *moqRepeatedIdsFn_anyParams) bParam() *moqRepeatedIdsFn_recorder {
	a.recorder.recorder.AnyParam(3)
	return a.recorder
}

func (r *moqRepeatedIdsFn_recorder) seq() *moqRepeatedIdsFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqRepeatedIdsFn_recorder) noSeq() *moqRepeatedIdsFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqRepeatedIdsFn_recorder) returnResults(sResult1, sResult2 string, err error) *moqRepeatedIdsFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqRepeatedIdsFn_results{
		sResult1: sResult1,
		sResult2: sResult2,
		err:      err,
	})
	return r
}

func (r *moqRepeatedIdsFn_recorder) andDo(fn moqRepeatedIdsFn_doFn) *moqRepeatedIdsFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqRepeatedIdsFn_params) {
		fn(params.sParam1, params.sParam2, params.bParam)
	}, false) {
		return nil
	}
	return r
}

func (r *moqRepeatedIdsFn_recorder) doReturnResults(fn moqRepeatedIdsFn_doReturnFn) *moqRepeatedIdsFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqRepeatedIdsFn_params) *moqRepeatedIdsFn_results {
		sResult1, sResult2, err := fn(params.sParam1, params.sParam2, params.bParam)
		return &moqRepeatedIdsFn_results{
			sResult1: sResult1,
			sResult2: sResult2,
			err:      err,
		}
	})
	return r
}

func (r *moqRepeatedIdsFn_recorder) repeat(repeaters ...moq.Repeater) *moqRepeatedIdsFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqRepeatedIdsFn_adaptor) PrettyParams(params moqRepeatedIdsFn_params) string {
	return fmt.Sprintf("RepeatedIdsFn(%#v, %#v, %#v)", params.sParam1, params.sParam2, params.bParam)
}

func (a *moqRepeatedIdsFn_adaptor) ParamsKey(params moqRepeatedIdsFn_params, anyParams uint64) moqRepeatedIdsFn_paramsKey {
	a.moq.moq.Scene.T.Helper()
	sParam1Used, sParam1UsedHash := impl.ParamKey(
		params.sParam1, 1, a.moq.runtime.parameterIndexing.sParam1, anyParams)
	sParam2Used, sParam2UsedHash := impl.ParamKey(
		params.sParam2, 2, a.moq.runtime.parameterIndexing.sParam2, anyParams)
	bParamUsed, bParamUsedHash := impl.ParamKey(
		params.bParam, 3, a.moq.runtime.parameterIndexing.bParam, anyParams)
	return moqRepeatedIdsFn_paramsKey{
		params: struct {
			sParam1, sParam2 string
			bParam           bool
		}{
			sParam1: sParam1Used,
			sParam2: sParam2Used,
			bParam:  bParamUsed,
		},
		hashes: struct {
			sParam1, sParam2 hash.Hash
			bParam           hash.Hash
		}{
			sParam1: sParam1UsedHash,
			sParam2: sParam2UsedHash,
			bParam:  bParamUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *moqRepeatedIdsFn) Reset() {
	m.moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *moqRepeatedIdsFn) AssertExpectationsMet() {
	m.moq.Scene.T.Helper()
	m.moq.AssertExpectationsMet()
}

// moqTimesFn holds the state of a moq of the TimesFn type
type moqTimesFn struct {
	moq *impl.Moq[
		*moqTimesFn_adaptor,
		moqTimesFn_params,
		moqTimesFn_paramsKey,
		moqTimesFn_results,
	]

	runtime moqTimesFn_runtime
}

// moqTimesFn_runtime holds runtime configuration for the TimesFn type
type moqTimesFn_runtime struct {
	parameterIndexing moqTimesFn_paramIndexing
}

// moqTimesFn_adaptor adapts moqTimesFn as needed by the runtime
type moqTimesFn_adaptor struct {
	moq *moqTimesFn
}

// moqTimesFn_params holds the params of the TimesFn type
type moqTimesFn_params struct {
	times  string
	bParam bool
}

// moqTimesFn_paramsKey holds the map key params of the TimesFn type
type moqTimesFn_paramsKey struct {
	params struct {
		times  string
		bParam bool
	}
	hashes struct {
		times  hash.Hash
		bParam hash.Hash
	}
}

// moqTimesFn_results holds the results of the TimesFn type
type moqTimesFn_results struct {
	sResult string
	err     error
}

// moqTimesFn_paramIndexing holds the parameter indexing runtime configuration
// for the TimesFn type
type moqTimesFn_paramIndexing struct {
	times  moq.ParamIndexing
	bParam moq.ParamIndexing
}

// moqTimesFn_doFn defines the type of function needed when calling andDo for
// the TimesFn type
type moqTimesFn_doFn func(times string, bParam bool)

// moqTimesFn_doReturnFn defines the type of function needed when calling
// doReturnResults for the TimesFn type
type moqTimesFn_doReturnFn func(times string, bParam bool) (sResult string, err error)

// moqTimesFn_recorder routes recorded function calls to the moqTimesFn moq
type moqTimesFn_recorder struct {
	recorder *impl.Recorder[
		*moqTimesFn_adaptor,
		moqTimesFn_params,
		moqTimesFn_paramsKey,
		moqTimesFn_results,
	]
}

// moqTimesFn_anyParams isolates the any params functions of the TimesFn type
type moqTimesFn_anyParams struct {
	recorder *moqTimesFn_recorder
}

// newMoqTimesFn creates a new moq of the TimesFn type
func newMoqTimesFn(scene *moq.Scene, config *moq.Config) *moqTimesFn {
	adaptor1 := &moqTimesFn_adaptor{}
	m := &moqTimesFn{
		moq: impl.NewMoq[
			*moqTimesFn_adaptor,
			moqTimesFn_params,
			moqTimesFn_paramsKey,
			moqTimesFn_results,
		](scene, adaptor1, config),

		runtime: moqTimesFn_runtime{parameterIndexing: moqTimesFn_paramIndexing{
			times:  moq.ParamIndexByValue,
			bParam: moq.ParamIndexByValue,
		}},
	}
	adaptor1.moq = m

	scene.AddMoq(m)
	return m
}

// mock returns the moq implementation of the TimesFn type
func (m *moqTimesFn) mock() testmoqs.TimesFn {
	return func(times string, bParam bool) (string, error) {
		m.moq.Scene.T.Helper()
		params := moqTimesFn_params{
			times:  times,
			bParam: bParam,
		}

		var result1 string
		var result2 error
		if result := m.moq.Function(params); result != nil {
			result1 = result.sResult
			result2 = result.err
		}
		return result1, result2
	}
}

func (m *moqTimesFn) onCall(times string, bParam bool) *moqTimesFn_recorder {
	return &moqTimesFn_recorder{
		recorder: m.moq.OnCall(moqTimesFn_params{
			times:  times,
			bParam: bParam,
		}),
	}
}

func (r *moqTimesFn_recorder) any() *moqTimesFn_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqTimesFn_anyParams{recorder: r}
}

func (a *moqTimesFn_anyParams) times() *moqTimesFn_recorder {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (a *moqTimesFn_anyParams) bParam() *moqTimesFn_recorder {
	a.recorder.recorder.AnyParam(2)
	return a.recorder
}

func (r *moqTimesFn_recorder) seq() *moqTimesFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqTimesFn_recorder) noSeq() *moqTimesFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqTimesFn_recorder) returnResults(sResult string, err error) *moqTimesFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqTimesFn_results{
		sResult: sResult,
		err:     err,
	})
	return r
}

func (r *moqTimesFn_recorder) andDo(fn moqTimesFn_doFn) *moqTimesFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqTimesFn_params) {
		fn(params.times, params.bParam)
	}, false) {
		return nil
	}
	return r
}

func (r *moqTimesFn_recorder) doReturnResults(fn moqTimesFn_doReturnFn) *moqTimesFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqTimesFn_params) *moqTimesFn_results {
		sResult, err := fn(params.times, params.bParam)
		return &moqTimesFn_results{
			sResult: sResult,
			err:     err,
		}
	})
	return r
}

func (r *moqTimesFn_recorder) repeat(repeaters ...moq.Repeater) *moqTimesFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqTimesFn_adaptor) PrettyParams(params moqTimesFn_params) string {
	return fmt.Sprintf("TimesFn(%#v, %#v)", params.times, params.bParam)
}

func (a *moqTimesFn_adaptor) ParamsKey(params moqTimesFn_params, anyParams uint64) moqTimesFn_paramsKey {
	a.moq.moq.Scene.T.Helper()
	timesUsed, timesUsedHash := impl.ParamKey(
		params.times, 1, a.moq.runtime.parameterIndexing.times, anyParams)
	bParamUsed, bParamUsedHash := impl.ParamKey(
		params.bParam, 2, a.moq.runtime.parameterIndexing.bParam, anyParams)
	return moqTimesFn_paramsKey{
		params: struct {
			times  string
			bParam bool
		}{
			times:  timesUsed,
			bParam: bParamUsed,
		},
		hashes: struct {
			times  hash.Hash
			bParam hash.Hash
		}{
			times:  timesUsedHash,
			bParam: bParamUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *moqTimesFn) Reset() {
	m.moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *moqTimesFn) AssertExpectationsMet() {
	m.moq.Scene.T.Helper()
	m.moq.AssertExpectationsMet()
}

// moqDifficultParamNamesFn holds the state of a moq of the
// DifficultParamNamesFn type
type moqDifficultParamNamesFn struct {
	moq *impl.Moq[
		*moqDifficultParamNamesFn_adaptor,
		moqDifficultParamNamesFn_params,
		moqDifficultParamNamesFn_paramsKey,
		moqDifficultParamNamesFn_results,
	]

	runtime moqDifficultParamNamesFn_runtime
}

// moqDifficultParamNamesFn_runtime holds runtime configuration for the
// DifficultParamNamesFn type
type moqDifficultParamNamesFn_runtime struct {
	parameterIndexing moqDifficultParamNamesFn_paramIndexing
}

// moqDifficultParamNamesFn_adaptor adapts moqDifficultParamNamesFn as needed
// by the runtime
type moqDifficultParamNamesFn_adaptor struct {
	moq *moqDifficultParamNamesFn
}

// moqDifficultParamNamesFn_params holds the params of the
// DifficultParamNamesFn type
type moqDifficultParamNamesFn_params struct {
	param1, param2         bool
	param3                 string
	param, param5, param6  int
	param7, param8, param9 float32
}

// moqDifficultParamNamesFn_paramsKey holds the map key params of the
// DifficultParamNamesFn type
type moqDifficultParamNamesFn_paramsKey struct {
	params struct {
		param1, param2         bool
		param3                 string
		param, param5, param6  int
		param7, param8, param9 float32
	}
	hashes struct {
		param1, param2         hash.Hash
		param3                 hash.Hash
		param, param5, param6  hash.Hash
		param7, param8, param9 hash.Hash
	}
}

// moqDifficultParamNamesFn_results holds the results of the
// DifficultParamNamesFn type
type moqDifficultParamNamesFn_results struct{}

// moqDifficultParamNamesFn_paramIndexing holds the parameter indexing runtime
// configuration for the DifficultParamNamesFn type
type moqDifficultParamNamesFn_paramIndexing struct {
	param1, param2         moq.ParamIndexing
	param3                 moq.ParamIndexing
	param, param5, param6  moq.ParamIndexing
	param7, param8, param9 moq.ParamIndexing
}

// moqDifficultParamNamesFn_doFn defines the type of function needed when
// calling andDo for the DifficultParamNamesFn type
type moqDifficultParamNamesFn_doFn func(m, r bool, sequence string, param, params, i int, result, results, _ float32)

// moqDifficultParamNamesFn_doReturnFn defines the type of function needed when
// calling doReturnResults for the DifficultParamNamesFn type
type moqDifficultParamNamesFn_doReturnFn func(m, r bool, sequence string, param, params, i int, result, results, _ float32)

// moqDifficultParamNamesFn_recorder routes recorded function calls to the
// moqDifficultParamNamesFn moq
type moqDifficultParamNamesFn_recorder struct {
	recorder *impl.Recorder[
		*moqDifficultParamNamesFn_adaptor,
		moqDifficultParamNamesFn_params,
		moqDifficultParamNamesFn_paramsKey,
		moqDifficultParamNamesFn_results,
	]
}

// moqDifficultParamNamesFn_anyParams isolates the any params functions of the
// DifficultParamNamesFn type
type moqDifficultParamNamesFn_anyParams struct {
	recorder *moqDifficultParamNamesFn_recorder
}

// newMoqDifficultParamNamesFn creates a new moq of the DifficultParamNamesFn
// type
func newMoqDifficultParamNamesFn(scene *moq.Scene, config *moq.Config) *moqDifficultParamNamesFn {
	adaptor1 := &moqDifficultParamNamesFn_adaptor{}
	m := &moqDifficultParamNamesFn{
		moq: impl.NewMoq[
			*moqDifficultParamNamesFn_adaptor,
			moqDifficultParamNamesFn_params,
			moqDifficultParamNamesFn_paramsKey,
			moqDifficultParamNamesFn_results,
		](scene, adaptor1, config),

		runtime: moqDifficultParamNamesFn_runtime{parameterIndexing: moqDifficultParamNamesFn_paramIndexing{
			param1: moq.ParamIndexByValue,
			param2: moq.ParamIndexByValue,
			param3: moq.ParamIndexByValue,
			param:  moq.ParamIndexByValue,
			param5: moq.ParamIndexByValue,
			param6: moq.ParamIndexByValue,
			param7: moq.ParamIndexByValue,
			param8: moq.ParamIndexByValue,
			param9: moq.ParamIndexByValue,
		}},
	}
	adaptor1.moq = m

	scene.AddMoq(m)
	return m
}

// mock returns the moq implementation of the DifficultParamNamesFn type
func (m *moqDifficultParamNamesFn) mock() testmoqs.DifficultParamNamesFn {
	return func(param1, param2 bool, param3 string, param, param5, param6 int, param7, param8, param9 float32) {
		m.moq.Scene.T.Helper()
		params := moqDifficultParamNamesFn_params{
			param1: param1,
			param2: param2,
			param3: param3,
			param:  param,
			param5: param5,
			param6: param6,
			param7: param7,
			param8: param8,
			param9: param9,
		}

		m.moq.Function(params)
	}
}

func (m *moqDifficultParamNamesFn) onCall(param1, param2 bool, param3 string, param, param5, param6 int, param7, param8, param9 float32) *moqDifficultParamNamesFn_recorder {
	return &moqDifficultParamNamesFn_recorder{
		recorder: m.moq.OnCall(moqDifficultParamNamesFn_params{
			param1: param1,
			param2: param2,
			param3: param3,
			param:  param,
			param5: param5,
			param6: param6,
			param7: param7,
			param8: param8,
			param9: param9,
		}),
	}
}

func (r *moqDifficultParamNamesFn_recorder) any() *moqDifficultParamNamesFn_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqDifficultParamNamesFn_anyParams{recorder: r}
}

func (a *moqDifficultParamNamesFn_anyParams) param1() *moqDifficultParamNamesFn_recorder {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (a *moqDifficultParamNamesFn_anyParams) param2() *moqDifficultParamNamesFn_recorder {
	a.recorder.recorder.AnyParam(2)
	return a.recorder
}

func (a *moqDifficultParamNamesFn_anyParams) param3() *moqDifficultParamNamesFn_recorder {
	a.recorder.recorder.AnyParam(3)
	return a.recorder
}

func (a *moqDifficultParamNamesFn_anyParams) param() *moqDifficultParamNamesFn_recorder {
	a.recorder.recorder.AnyParam(4)
	return a.recorder
}

func (a *moqDifficultParamNamesFn_anyParams) param5() *moqDifficultParamNamesFn_recorder {
	a.recorder.recorder.AnyParam(5)
	return a.recorder
}

func (a *moqDifficultParamNamesFn_anyParams) param6() *moqDifficultParamNamesFn_recorder {
	a.recorder.recorder.AnyParam(6)
	return a.recorder
}

func (a *moqDifficultParamNamesFn_anyParams) param7() *moqDifficultParamNamesFn_recorder {
	a.recorder.recorder.AnyParam(7)
	return a.recorder
}

func (a *moqDifficultParamNamesFn_anyParams) param8() *moqDifficultParamNamesFn_recorder {
	a.recorder.recorder.AnyParam(8)
	return a.recorder
}

func (a *moqDifficultParamNamesFn_anyParams) param9() *moqDifficultParamNamesFn_recorder {
	a.recorder.recorder.AnyParam(9)
	return a.recorder
}

func (r *moqDifficultParamNamesFn_recorder) seq() *moqDifficultParamNamesFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqDifficultParamNamesFn_recorder) noSeq() *moqDifficultParamNamesFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqDifficultParamNamesFn_recorder) returnResults() *moqDifficultParamNamesFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqDifficultParamNamesFn_results{})
	return r
}

func (r *moqDifficultParamNamesFn_recorder) andDo(fn moqDifficultParamNamesFn_doFn) *moqDifficultParamNamesFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqDifficultParamNamesFn_params) {
		fn(params.param1, params.param2, params.param3, params.param, params.param5, params.param6, params.param7, params.param8, params.param9)
	}, false) {
		return nil
	}
	return r
}

func (r *moqDifficultParamNamesFn_recorder) doReturnResults(fn moqDifficultParamNamesFn_doReturnFn) *moqDifficultParamNamesFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqDifficultParamNamesFn_params) *moqDifficultParamNamesFn_results {
		fn(params.param1, params.param2, params.param3, params.param, params.param5, params.param6, params.param7, params.param8, params.param9)
		return &moqDifficultParamNamesFn_results{}
	})
	return r
}

func (r *moqDifficultParamNamesFn_recorder) repeat(repeaters ...moq.Repeater) *moqDifficultParamNamesFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqDifficultParamNamesFn_adaptor) PrettyParams(params moqDifficultParamNamesFn_params) string {
	return fmt.Sprintf("DifficultParamNamesFn(%#v, %#v, %#v, %#v, %#v, %#v, %#v, %#v, %#v)", params.param1, params.param2, params.param3, params.param, params.param5, params.param6, params.param7, params.param8, params.param9)
}

func (a *moqDifficultParamNamesFn_adaptor) ParamsKey(params moqDifficultParamNamesFn_params, anyParams uint64) moqDifficultParamNamesFn_paramsKey {
	a.moq.moq.Scene.T.Helper()
	param1Used, param1UsedHash := impl.ParamKey(
		params.param1, 1, a.moq.runtime.parameterIndexing.param1, anyParams)
	param2Used, param2UsedHash := impl.ParamKey(
		params.param2, 2, a.moq.runtime.parameterIndexing.param2, anyParams)
	param3Used, param3UsedHash := impl.ParamKey(
		params.param3, 3, a.moq.runtime.parameterIndexing.param3, anyParams)
	paramUsed, paramUsedHash := impl.ParamKey(
		params.param, 4, a.moq.runtime.parameterIndexing.param, anyParams)
	param5Used, param5UsedHash := impl.ParamKey(
		params.param5, 5, a.moq.runtime.parameterIndexing.param5, anyParams)
	param6Used, param6UsedHash := impl.ParamKey(
		params.param6, 6, a.moq.runtime.parameterIndexing.param6, anyParams)
	param7Used, param7UsedHash := impl.ParamKey(
		params.param7, 7, a.moq.runtime.parameterIndexing.param7, anyParams)
	param8Used, param8UsedHash := impl.ParamKey(
		params.param8, 8, a.moq.runtime.parameterIndexing.param8, anyParams)
	param9Used, param9UsedHash := impl.ParamKey(
		params.param9, 9, a.moq.runtime.parameterIndexing.param9, anyParams)
	return moqDifficultParamNamesFn_paramsKey{
		params: struct {
			param1, param2         bool
			param3                 string
			param, param5, param6  int
			param7, param8, param9 float32
		}{
			param1: param1Used,
			param2: param2Used,
			param3: param3Used,
			param:  paramUsed,
			param5: param5Used,
			param6: param6Used,
			param7: param7Used,
			param8: param8Used,
			param9: param9Used,
		},
		hashes: struct {
			param1, param2         hash.Hash
			param3                 hash.Hash
			param, param5, param6  hash.Hash
			param7, param8, param9 hash.Hash
		}{
			param1: param1UsedHash,
			param2: param2UsedHash,
			param3: param3UsedHash,
			param:  paramUsedHash,
			param5: param5UsedHash,
			param6: param6UsedHash,
			param7: param7UsedHash,
			param8: param8UsedHash,
			param9: param9UsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *moqDifficultParamNamesFn) Reset() {
	m.moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *moqDifficultParamNamesFn) AssertExpectationsMet() {
	m.moq.Scene.T.Helper()
	m.moq.AssertExpectationsMet()
}

// moqDifficultResultNamesFn holds the state of a moq of the
// DifficultResultNamesFn type
type moqDifficultResultNamesFn struct {
	moq *impl.Moq[
		*moqDifficultResultNamesFn_adaptor,
		moqDifficultResultNamesFn_params,
		moqDifficultResultNamesFn_paramsKey,
		moqDifficultResultNamesFn_results,
	]

	runtime moqDifficultResultNamesFn_runtime
}

// moqDifficultResultNamesFn_runtime holds runtime configuration for the
// DifficultResultNamesFn type
type moqDifficultResultNamesFn_runtime struct {
	parameterIndexing moqDifficultResultNamesFn_paramIndexing
}

// moqDifficultResultNamesFn_adaptor adapts moqDifficultResultNamesFn as needed
// by the runtime
type moqDifficultResultNamesFn_adaptor struct {
	moq *moqDifficultResultNamesFn
}

// moqDifficultResultNamesFn_params holds the params of the
// DifficultResultNamesFn type
type moqDifficultResultNamesFn_params struct{}

// moqDifficultResultNamesFn_paramsKey holds the map key params of the
// DifficultResultNamesFn type
type moqDifficultResultNamesFn_paramsKey struct {
	params struct{}
	hashes struct{}
}

// moqDifficultResultNamesFn_results holds the results of the
// DifficultResultNamesFn type
type moqDifficultResultNamesFn_results struct {
	result1, result2          string
	result3                   error
	param, result5, result6   int
	result7, result8, result9 float32
}

// moqDifficultResultNamesFn_paramIndexing holds the parameter indexing runtime
// configuration for the DifficultResultNamesFn type
type moqDifficultResultNamesFn_paramIndexing struct{}

// moqDifficultResultNamesFn_doFn defines the type of function needed when
// calling andDo for the DifficultResultNamesFn type
type moqDifficultResultNamesFn_doFn func()

// moqDifficultResultNamesFn_doReturnFn defines the type of function needed
// when calling doReturnResults for the DifficultResultNamesFn type
type moqDifficultResultNamesFn_doReturnFn func() (m, r string, sequence error, param, params, i int, result, results, _ float32)

// moqDifficultResultNamesFn_recorder routes recorded function calls to the
// moqDifficultResultNamesFn moq
type moqDifficultResultNamesFn_recorder struct {
	recorder *impl.Recorder[
		*moqDifficultResultNamesFn_adaptor,
		moqDifficultResultNamesFn_params,
		moqDifficultResultNamesFn_paramsKey,
		moqDifficultResultNamesFn_results,
	]
}

// moqDifficultResultNamesFn_anyParams isolates the any params functions of the
// DifficultResultNamesFn type
type moqDifficultResultNamesFn_anyParams struct {
	recorder *moqDifficultResultNamesFn_recorder
}

// newMoqDifficultResultNamesFn creates a new moq of the DifficultResultNamesFn
// type
func newMoqDifficultResultNamesFn(scene *moq.Scene, config *moq.Config) *moqDifficultResultNamesFn {
	adaptor1 := &moqDifficultResultNamesFn_adaptor{}
	m := &moqDifficultResultNamesFn{
		moq: impl.NewMoq[
			*moqDifficultResultNamesFn_adaptor,
			moqDifficultResultNamesFn_params,
			moqDifficultResultNamesFn_paramsKey,
			moqDifficultResultNamesFn_results,
		](scene, adaptor1, config),

		runtime: moqDifficultResultNamesFn_runtime{parameterIndexing: moqDifficultResultNamesFn_paramIndexing{}},
	}
	adaptor1.moq = m

	scene.AddMoq(m)
	return m
}

// mock returns the moq implementation of the DifficultResultNamesFn type
func (m *moqDifficultResultNamesFn) mock() testmoqs.DifficultResultNamesFn {
	return func() (string, string, error, int, int, int, float32, float32, float32) {
		m.moq.Scene.T.Helper()
		params := moqDifficultResultNamesFn_params{}

		var result1 string
		var result2 string
		var result3 error
		var result4 int
		var result5 int
		var result6 int
		var result7 float32
		var result8 float32
		var result9 float32
		if result := m.moq.Function(params); result != nil {
			result1 = result.result1
			result2 = result.result2
			result3 = result.result3
			result4 = result.param
			result5 = result.result5
			result6 = result.result6
			result7 = result.result7
			result8 = result.result8
			result9 = result.result9
		}
		return result1, result2, result3, result4, result5, result6, result7, result8, result9
	}
}

func (m *moqDifficultResultNamesFn) onCall() *moqDifficultResultNamesFn_recorder {
	return &moqDifficultResultNamesFn_recorder{
		recorder: m.moq.OnCall(moqDifficultResultNamesFn_params{}),
	}
}

func (r *moqDifficultResultNamesFn_recorder) any() *moqDifficultResultNamesFn_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqDifficultResultNamesFn_anyParams{recorder: r}
}

func (r *moqDifficultResultNamesFn_recorder) seq() *moqDifficultResultNamesFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqDifficultResultNamesFn_recorder) noSeq() *moqDifficultResultNamesFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqDifficultResultNamesFn_recorder) returnResults(result1, result2 string, result3 error, param, result5, result6 int, result7, result8, result9 float32) *moqDifficultResultNamesFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqDifficultResultNamesFn_results{
		result1: result1,
		result2: result2,
		result3: result3,
		param:   param,
		result5: result5,
		result6: result6,
		result7: result7,
		result8: result8,
		result9: result9,
	})
	return r
}

func (r *moqDifficultResultNamesFn_recorder) andDo(fn moqDifficultResultNamesFn_doFn) *moqDifficultResultNamesFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqDifficultResultNamesFn_params) {
		fn()
	}, false) {
		return nil
	}
	return r
}

func (r *moqDifficultResultNamesFn_recorder) doReturnResults(fn moqDifficultResultNamesFn_doReturnFn) *moqDifficultResultNamesFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqDifficultResultNamesFn_params) *moqDifficultResultNamesFn_results {
		result1, result2, result3, param, result5, result6, result7, result8, result9 := fn()
		return &moqDifficultResultNamesFn_results{
			result1: result1,
			result2: result2,
			result3: result3,
			param:   param,
			result5: result5,
			result6: result6,
			result7: result7,
			result8: result8,
			result9: result9,
		}
	})
	return r
}

func (r *moqDifficultResultNamesFn_recorder) repeat(repeaters ...moq.Repeater) *moqDifficultResultNamesFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqDifficultResultNamesFn_adaptor) PrettyParams(params moqDifficultResultNamesFn_params) string {
	return fmt.Sprintf("DifficultResultNamesFn()")
}

func (a *moqDifficultResultNamesFn_adaptor) ParamsKey(params moqDifficultResultNamesFn_params, anyParams uint64) moqDifficultResultNamesFn_paramsKey {
	a.moq.moq.Scene.T.Helper()
	return moqDifficultResultNamesFn_paramsKey{
		params: struct{}{},
		hashes: struct{}{},
	}
}

// Reset resets the state of the moq
func (m *moqDifficultResultNamesFn) Reset() {
	m.moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *moqDifficultResultNamesFn) AssertExpectationsMet() {
	m.moq.Scene.T.Helper()
	m.moq.AssertExpectationsMet()
}

// moqPassByArrayFn holds the state of a moq of the PassByArrayFn type
type moqPassByArrayFn struct {
	moq *impl.Moq[
		*moqPassByArrayFn_adaptor,
		moqPassByArrayFn_params,
		moqPassByArrayFn_paramsKey,
		moqPassByArrayFn_results,
	]

	runtime moqPassByArrayFn_runtime
}

// moqPassByArrayFn_runtime holds runtime configuration for the PassByArrayFn
// type
type moqPassByArrayFn_runtime struct {
	parameterIndexing moqPassByArrayFn_paramIndexing
}

// moqPassByArrayFn_adaptor adapts moqPassByArrayFn as needed by the runtime
type moqPassByArrayFn_adaptor struct {
	moq *moqPassByArrayFn
}

// moqPassByArrayFn_params holds the params of the PassByArrayFn type
type moqPassByArrayFn_params struct{ p [3]testmoqs.Params }

// moqPassByArrayFn_paramsKey holds the map key params of the PassByArrayFn
// type
type moqPassByArrayFn_paramsKey struct {
	params struct{ p [3]testmoqs.Params }
	hashes struct{ p hash.Hash }
}

// moqPassByArrayFn_results holds the results of the PassByArrayFn type
type moqPassByArrayFn_results struct {
	result1 [3]testmoqs.Results
}

// moqPassByArrayFn_paramIndexing holds the parameter indexing runtime
// configuration for the PassByArrayFn type
type moqPassByArrayFn_paramIndexing struct {
	p moq.ParamIndexing
}

// moqPassByArrayFn_doFn defines the type of function needed when calling andDo
// for the PassByArrayFn type
type moqPassByArrayFn_doFn func(p [3]testmoqs.Params)

// moqPassByArrayFn_doReturnFn defines the type of function needed when calling
// doReturnResults for the PassByArrayFn type
type moqPassByArrayFn_doReturnFn func(p [3]testmoqs.Params) [3]testmoqs.Results

// moqPassByArrayFn_recorder routes recorded function calls to the
// moqPassByArrayFn moq
type moqPassByArrayFn_recorder struct {
	recorder *impl.Recorder[
		*moqPassByArrayFn_adaptor,
		moqPassByArrayFn_params,
		moqPassByArrayFn_paramsKey,
		moqPassByArrayFn_results,
	]
}

// moqPassByArrayFn_anyParams isolates the any params functions of the
// PassByArrayFn type
type moqPassByArrayFn_anyParams struct {
	recorder *moqPassByArrayFn_recorder
}

// newMoqPassByArrayFn creates a new moq of the PassByArrayFn type
func newMoqPassByArrayFn(scene *moq.Scene, config *moq.Config) *moqPassByArrayFn {
	adaptor1 := &moqPassByArrayFn_adaptor{}
	m := &moqPassByArrayFn{
		moq: impl.NewMoq[
			*moqPassByArrayFn_adaptor,
			moqPassByArrayFn_params,
			moqPassByArrayFn_paramsKey,
			moqPassByArrayFn_results,
		](scene, adaptor1, config),

		runtime: moqPassByArrayFn_runtime{parameterIndexing: moqPassByArrayFn_paramIndexing{
			p: moq.ParamIndexByValue,
		}},
	}
	adaptor1.moq = m

	scene.AddMoq(m)
	return m
}

// mock returns the moq implementation of the PassByArrayFn type
func (m *moqPassByArrayFn) mock() testmoqs.PassByArrayFn {
	return func(p [3]testmoqs.Params) [3]testmoqs.Results {
		m.moq.Scene.T.Helper()
		params := moqPassByArrayFn_params{
			p: p,
		}

		var result1 [3]testmoqs.Results
		if result := m.moq.Function(params); result != nil {
			result1 = result.result1
		}
		return result1
	}
}

func (m *moqPassByArrayFn) onCall(p [3]testmoqs.Params) *moqPassByArrayFn_recorder {
	return &moqPassByArrayFn_recorder{
		recorder: m.moq.OnCall(moqPassByArrayFn_params{
			p: p,
		}),
	}
}

func (r *moqPassByArrayFn_recorder) any() *moqPassByArrayFn_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqPassByArrayFn_anyParams{recorder: r}
}

func (a *moqPassByArrayFn_anyParams) p() *moqPassByArrayFn_recorder {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (r *moqPassByArrayFn_recorder) seq() *moqPassByArrayFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqPassByArrayFn_recorder) noSeq() *moqPassByArrayFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqPassByArrayFn_recorder) returnResults(result1 [3]testmoqs.Results) *moqPassByArrayFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqPassByArrayFn_results{
		result1: result1,
	})
	return r
}

func (r *moqPassByArrayFn_recorder) andDo(fn moqPassByArrayFn_doFn) *moqPassByArrayFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqPassByArrayFn_params) {
		fn(params.p)
	}, false) {
		return nil
	}
	return r
}

func (r *moqPassByArrayFn_recorder) doReturnResults(fn moqPassByArrayFn_doReturnFn) *moqPassByArrayFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqPassByArrayFn_params) *moqPassByArrayFn_results {
		result1 := fn(params.p)
		return &moqPassByArrayFn_results{
			result1: result1,
		}
	})
	return r
}

func (r *moqPassByArrayFn_recorder) repeat(repeaters ...moq.Repeater) *moqPassByArrayFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqPassByArrayFn_adaptor) PrettyParams(params moqPassByArrayFn_params) string {
	return fmt.Sprintf("PassByArrayFn(%#v)", params.p)
}

func (a *moqPassByArrayFn_adaptor) ParamsKey(params moqPassByArrayFn_params, anyParams uint64) moqPassByArrayFn_paramsKey {
	a.moq.moq.Scene.T.Helper()
	pUsed, pUsedHash := impl.ParamKey(
		params.p, 1, a.moq.runtime.parameterIndexing.p, anyParams)
	return moqPassByArrayFn_paramsKey{
		params: struct{ p [3]testmoqs.Params }{
			p: pUsed,
		},
		hashes: struct{ p hash.Hash }{
			p: pUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *moqPassByArrayFn) Reset() {
	m.moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *moqPassByArrayFn) AssertExpectationsMet() {
	m.moq.Scene.T.Helper()
	m.moq.AssertExpectationsMet()
}

// moqPassByChanFn holds the state of a moq of the PassByChanFn type
type moqPassByChanFn struct {
	moq *impl.Moq[
		*moqPassByChanFn_adaptor,
		moqPassByChanFn_params,
		moqPassByChanFn_paramsKey,
		moqPassByChanFn_results,
	]

	runtime moqPassByChanFn_runtime
}

// moqPassByChanFn_runtime holds runtime configuration for the PassByChanFn
// type
type moqPassByChanFn_runtime struct {
	parameterIndexing moqPassByChanFn_paramIndexing
}

// moqPassByChanFn_adaptor adapts moqPassByChanFn as needed by the runtime
type moqPassByChanFn_adaptor struct {
	moq *moqPassByChanFn
}

// moqPassByChanFn_params holds the params of the PassByChanFn type
type moqPassByChanFn_params struct{ p chan testmoqs.Params }

// moqPassByChanFn_paramsKey holds the map key params of the PassByChanFn type
type moqPassByChanFn_paramsKey struct {
	params struct{ p chan testmoqs.Params }
	hashes struct{ p hash.Hash }
}

// moqPassByChanFn_results holds the results of the PassByChanFn type
type moqPassByChanFn_results struct {
	result1 chan testmoqs.Results
}

// moqPassByChanFn_paramIndexing holds the parameter indexing runtime
// configuration for the PassByChanFn type
type moqPassByChanFn_paramIndexing struct {
	p moq.ParamIndexing
}

// moqPassByChanFn_doFn defines the type of function needed when calling andDo
// for the PassByChanFn type
type moqPassByChanFn_doFn func(p chan testmoqs.Params)

// moqPassByChanFn_doReturnFn defines the type of function needed when calling
// doReturnResults for the PassByChanFn type
type moqPassByChanFn_doReturnFn func(p chan testmoqs.Params) chan testmoqs.Results

// moqPassByChanFn_recorder routes recorded function calls to the
// moqPassByChanFn moq
type moqPassByChanFn_recorder struct {
	recorder *impl.Recorder[
		*moqPassByChanFn_adaptor,
		moqPassByChanFn_params,
		moqPassByChanFn_paramsKey,
		moqPassByChanFn_results,
	]
}

// moqPassByChanFn_anyParams isolates the any params functions of the
// PassByChanFn type
type moqPassByChanFn_anyParams struct {
	recorder *moqPassByChanFn_recorder
}

// newMoqPassByChanFn creates a new moq of the PassByChanFn type
func newMoqPassByChanFn(scene *moq.Scene, config *moq.Config) *moqPassByChanFn {
	adaptor1 := &moqPassByChanFn_adaptor{}
	m := &moqPassByChanFn{
		moq: impl.NewMoq[
			*moqPassByChanFn_adaptor,
			moqPassByChanFn_params,
			moqPassByChanFn_paramsKey,
			moqPassByChanFn_results,
		](scene, adaptor1, config),

		runtime: moqPassByChanFn_runtime{parameterIndexing: moqPassByChanFn_paramIndexing{
			p: moq.ParamIndexByValue,
		}},
	}
	adaptor1.moq = m

	scene.AddMoq(m)
	return m
}

// mock returns the moq implementation of the PassByChanFn type
func (m *moqPassByChanFn) mock() testmoqs.PassByChanFn {
	return func(p chan testmoqs.Params) chan testmoqs.Results {
		m.moq.Scene.T.Helper()
		params := moqPassByChanFn_params{
			p: p,
		}

		var result1 chan testmoqs.Results
		if result := m.moq.Function(params); result != nil {
			result1 = result.result1
		}
		return result1
	}
}

func (m *moqPassByChanFn) onCall(p chan testmoqs.Params) *moqPassByChanFn_recorder {
	return &moqPassByChanFn_recorder{
		recorder: m.moq.OnCall(moqPassByChanFn_params{
			p: p,
		}),
	}
}

func (r *moqPassByChanFn_recorder) any() *moqPassByChanFn_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqPassByChanFn_anyParams{recorder: r}
}

func (a *moqPassByChanFn_anyParams) p() *moqPassByChanFn_recorder {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (r *moqPassByChanFn_recorder) seq() *moqPassByChanFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqPassByChanFn_recorder) noSeq() *moqPassByChanFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqPassByChanFn_recorder) returnResults(result1 chan testmoqs.Results) *moqPassByChanFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqPassByChanFn_results{
		result1: result1,
	})
	return r
}

func (r *moqPassByChanFn_recorder) andDo(fn moqPassByChanFn_doFn) *moqPassByChanFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqPassByChanFn_params) {
		fn(params.p)
	}, false) {
		return nil
	}
	return r
}

func (r *moqPassByChanFn_recorder) doReturnResults(fn moqPassByChanFn_doReturnFn) *moqPassByChanFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqPassByChanFn_params) *moqPassByChanFn_results {
		result1 := fn(params.p)
		return &moqPassByChanFn_results{
			result1: result1,
		}
	})
	return r
}

func (r *moqPassByChanFn_recorder) repeat(repeaters ...moq.Repeater) *moqPassByChanFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqPassByChanFn_adaptor) PrettyParams(params moqPassByChanFn_params) string {
	return fmt.Sprintf("PassByChanFn(%#v)", params.p)
}

func (a *moqPassByChanFn_adaptor) ParamsKey(params moqPassByChanFn_params, anyParams uint64) moqPassByChanFn_paramsKey {
	a.moq.moq.Scene.T.Helper()
	pUsed, pUsedHash := impl.ParamKey(
		params.p, 1, a.moq.runtime.parameterIndexing.p, anyParams)
	return moqPassByChanFn_paramsKey{
		params: struct{ p chan testmoqs.Params }{
			p: pUsed,
		},
		hashes: struct{ p hash.Hash }{
			p: pUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *moqPassByChanFn) Reset() {
	m.moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *moqPassByChanFn) AssertExpectationsMet() {
	m.moq.Scene.T.Helper()
	m.moq.AssertExpectationsMet()
}

// moqPassByEllipsisFn holds the state of a moq of the PassByEllipsisFn type
type moqPassByEllipsisFn struct {
	moq *impl.Moq[
		*moqPassByEllipsisFn_adaptor,
		moqPassByEllipsisFn_params,
		moqPassByEllipsisFn_paramsKey,
		moqPassByEllipsisFn_results,
	]

	runtime moqPassByEllipsisFn_runtime
}

// moqPassByEllipsisFn_runtime holds runtime configuration for the
// PassByEllipsisFn type
type moqPassByEllipsisFn_runtime struct {
	parameterIndexing moqPassByEllipsisFn_paramIndexing
}

// moqPassByEllipsisFn_adaptor adapts moqPassByEllipsisFn as needed by the
// runtime
type moqPassByEllipsisFn_adaptor struct {
	moq *moqPassByEllipsisFn
}

// moqPassByEllipsisFn_params holds the params of the PassByEllipsisFn type
type moqPassByEllipsisFn_params struct{ p []testmoqs.Params }

// moqPassByEllipsisFn_paramsKey holds the map key params of the
// PassByEllipsisFn type
type moqPassByEllipsisFn_paramsKey struct {
	params struct{}
	hashes struct{ p hash.Hash }
}

// moqPassByEllipsisFn_results holds the results of the PassByEllipsisFn type
type moqPassByEllipsisFn_results struct {
	result1 string
	result2 error
}

// moqPassByEllipsisFn_paramIndexing holds the parameter indexing runtime
// configuration for the PassByEllipsisFn type
type moqPassByEllipsisFn_paramIndexing struct {
	p moq.ParamIndexing
}

// moqPassByEllipsisFn_doFn defines the type of function needed when calling
// andDo for the PassByEllipsisFn type
type moqPassByEllipsisFn_doFn func(p ...testmoqs.Params)

// moqPassByEllipsisFn_doReturnFn defines the type of function needed when
// calling doReturnResults for the PassByEllipsisFn type
type moqPassByEllipsisFn_doReturnFn func(p ...testmoqs.Params) (string, error)

// moqPassByEllipsisFn_recorder routes recorded function calls to the
// moqPassByEllipsisFn moq
type moqPassByEllipsisFn_recorder struct {
	recorder *impl.Recorder[
		*moqPassByEllipsisFn_adaptor,
		moqPassByEllipsisFn_params,
		moqPassByEllipsisFn_paramsKey,
		moqPassByEllipsisFn_results,
	]
}

// moqPassByEllipsisFn_anyParams isolates the any params functions of the
// PassByEllipsisFn type
type moqPassByEllipsisFn_anyParams struct {
	recorder *moqPassByEllipsisFn_recorder
}

// newMoqPassByEllipsisFn creates a new moq of the PassByEllipsisFn type
func newMoqPassByEllipsisFn(scene *moq.Scene, config *moq.Config) *moqPassByEllipsisFn {
	adaptor1 := &moqPassByEllipsisFn_adaptor{}
	m := &moqPassByEllipsisFn{
		moq: impl.NewMoq[
			*moqPassByEllipsisFn_adaptor,
			moqPassByEllipsisFn_params,
			moqPassByEllipsisFn_paramsKey,
			moqPassByEllipsisFn_results,
		](scene, adaptor1, config),

		runtime: moqPassByEllipsisFn_runtime{parameterIndexing: moqPassByEllipsisFn_paramIndexing{
			p: moq.ParamIndexByHash,
		}},
	}
	adaptor1.moq = m

	scene.AddMoq(m)
	return m
}

// mock returns the moq implementation of the PassByEllipsisFn type
func (m *moqPassByEllipsisFn) mock() testmoqs.PassByEllipsisFn {
	return func(p ...testmoqs.Params) (string, error) {
		m.moq.Scene.T.Helper()
		params := moqPassByEllipsisFn_params{
			p: p,
		}

		var result1 string
		var result2 error
		if result := m.moq.Function(params); result != nil {
			result1 = result.result1
			result2 = result.result2
		}
		return result1, result2
	}
}

func (m *moqPassByEllipsisFn) onCall(p ...testmoqs.Params) *moqPassByEllipsisFn_recorder {
	return &moqPassByEllipsisFn_recorder{
		recorder: m.moq.OnCall(moqPassByEllipsisFn_params{
			p: p,
		}),
	}
}

func (r *moqPassByEllipsisFn_recorder) any() *moqPassByEllipsisFn_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqPassByEllipsisFn_anyParams{recorder: r}
}

func (a *moqPassByEllipsisFn_anyParams) p() *moqPassByEllipsisFn_recorder {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (r *moqPassByEllipsisFn_recorder) seq() *moqPassByEllipsisFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqPassByEllipsisFn_recorder) noSeq() *moqPassByEllipsisFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqPassByEllipsisFn_recorder) returnResults(result1 string, result2 error) *moqPassByEllipsisFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqPassByEllipsisFn_results{
		result1: result1,
		result2: result2,
	})
	return r
}

func (r *moqPassByEllipsisFn_recorder) andDo(fn moqPassByEllipsisFn_doFn) *moqPassByEllipsisFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqPassByEllipsisFn_params) {
		fn(params.p...)
	}, false) {
		return nil
	}
	return r
}

func (r *moqPassByEllipsisFn_recorder) doReturnResults(fn moqPassByEllipsisFn_doReturnFn) *moqPassByEllipsisFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqPassByEllipsisFn_params) *moqPassByEllipsisFn_results {
		result1, result2 := fn(params.p...)
		return &moqPassByEllipsisFn_results{
			result1: result1,
			result2: result2,
		}
	})
	return r
}

func (r *moqPassByEllipsisFn_recorder) repeat(repeaters ...moq.Repeater) *moqPassByEllipsisFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqPassByEllipsisFn_adaptor) PrettyParams(params moqPassByEllipsisFn_params) string {
	return fmt.Sprintf("PassByEllipsisFn(%#v)", params.p)
}

func (a *moqPassByEllipsisFn_adaptor) ParamsKey(params moqPassByEllipsisFn_params, anyParams uint64) moqPassByEllipsisFn_paramsKey {
	a.moq.moq.Scene.T.Helper()
	pUsedHash := impl.HashOnlyParamKey(a.moq.moq.Scene.T,
		params.p, "p", 1, a.moq.runtime.parameterIndexing.p, anyParams)
	return moqPassByEllipsisFn_paramsKey{
		params: struct{}{},
		hashes: struct{ p hash.Hash }{
			p: pUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *moqPassByEllipsisFn) Reset() {
	m.moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *moqPassByEllipsisFn) AssertExpectationsMet() {
	m.moq.Scene.T.Helper()
	m.moq.AssertExpectationsMet()
}

// moqPassByMapFn holds the state of a moq of the PassByMapFn type
type moqPassByMapFn struct {
	moq *impl.Moq[
		*moqPassByMapFn_adaptor,
		moqPassByMapFn_params,
		moqPassByMapFn_paramsKey,
		moqPassByMapFn_results,
	]

	runtime moqPassByMapFn_runtime
}

// moqPassByMapFn_runtime holds runtime configuration for the PassByMapFn type
type moqPassByMapFn_runtime struct {
	parameterIndexing moqPassByMapFn_paramIndexing
}

// moqPassByMapFn_adaptor adapts moqPassByMapFn as needed by the runtime
type moqPassByMapFn_adaptor struct {
	moq *moqPassByMapFn
}

// moqPassByMapFn_params holds the params of the PassByMapFn type
type moqPassByMapFn_params struct{ p map[string]testmoqs.Params }

// moqPassByMapFn_paramsKey holds the map key params of the PassByMapFn type
type moqPassByMapFn_paramsKey struct {
	params struct{}
	hashes struct{ p hash.Hash }
}

// moqPassByMapFn_results holds the results of the PassByMapFn type
type moqPassByMapFn_results struct {
	result1 map[string]testmoqs.Results
}

// moqPassByMapFn_paramIndexing holds the parameter indexing runtime
// configuration for the PassByMapFn type
type moqPassByMapFn_paramIndexing struct {
	p moq.ParamIndexing
}

// moqPassByMapFn_doFn defines the type of function needed when calling andDo
// for the PassByMapFn type
type moqPassByMapFn_doFn func(p map[string]testmoqs.Params)

// moqPassByMapFn_doReturnFn defines the type of function needed when calling
// doReturnResults for the PassByMapFn type
type moqPassByMapFn_doReturnFn func(p map[string]testmoqs.Params) map[string]testmoqs.Results

// moqPassByMapFn_recorder routes recorded function calls to the moqPassByMapFn
// moq
type moqPassByMapFn_recorder struct {
	recorder *impl.Recorder[
		*moqPassByMapFn_adaptor,
		moqPassByMapFn_params,
		moqPassByMapFn_paramsKey,
		moqPassByMapFn_results,
	]
}

// moqPassByMapFn_anyParams isolates the any params functions of the
// PassByMapFn type
type moqPassByMapFn_anyParams struct {
	recorder *moqPassByMapFn_recorder
}

// newMoqPassByMapFn creates a new moq of the PassByMapFn type
func newMoqPassByMapFn(scene *moq.Scene, config *moq.Config) *moqPassByMapFn {
	adaptor1 := &moqPassByMapFn_adaptor{}
	m := &moqPassByMapFn{
		moq: impl.NewMoq[
			*moqPassByMapFn_adaptor,
			moqPassByMapFn_params,
			moqPassByMapFn_paramsKey,
			moqPassByMapFn_results,
		](scene, adaptor1, config),

		runtime: moqPassByMapFn_runtime{parameterIndexing: moqPassByMapFn_paramIndexing{
			p: moq.ParamIndexByHash,
		}},
	}
	adaptor1.moq = m

	scene.AddMoq(m)
	return m
}

// mock returns the moq implementation of the PassByMapFn type
func (m *moqPassByMapFn) mock() testmoqs.PassByMapFn {
	return func(p map[string]testmoqs.Params) map[string]testmoqs.Results {
		m.moq.Scene.T.Helper()
		params := moqPassByMapFn_params{
			p: p,
		}

		var result1 map[string]testmoqs.Results
		if result := m.moq.Function(params); result != nil {
			result1 = result.result1
		}
		return result1
	}
}

func (m *moqPassByMapFn) onCall(p map[string]testmoqs.Params) *moqPassByMapFn_recorder {
	return &moqPassByMapFn_recorder{
		recorder: m.moq.OnCall(moqPassByMapFn_params{
			p: p,
		}),
	}
}

func (r *moqPassByMapFn_recorder) any() *moqPassByMapFn_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqPassByMapFn_anyParams{recorder: r}
}

func (a *moqPassByMapFn_anyParams) p() *moqPassByMapFn_recorder {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (r *moqPassByMapFn_recorder) seq() *moqPassByMapFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqPassByMapFn_recorder) noSeq() *moqPassByMapFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqPassByMapFn_recorder) returnResults(result1 map[string]testmoqs.Results) *moqPassByMapFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqPassByMapFn_results{
		result1: result1,
	})
	return r
}

func (r *moqPassByMapFn_recorder) andDo(fn moqPassByMapFn_doFn) *moqPassByMapFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqPassByMapFn_params) {
		fn(params.p)
	}, false) {
		return nil
	}
	return r
}

func (r *moqPassByMapFn_recorder) doReturnResults(fn moqPassByMapFn_doReturnFn) *moqPassByMapFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqPassByMapFn_params) *moqPassByMapFn_results {
		result1 := fn(params.p)
		return &moqPassByMapFn_results{
			result1: result1,
		}
	})
	return r
}

func (r *moqPassByMapFn_recorder) repeat(repeaters ...moq.Repeater) *moqPassByMapFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqPassByMapFn_adaptor) PrettyParams(params moqPassByMapFn_params) string {
	return fmt.Sprintf("PassByMapFn(%#v)", params.p)
}

func (a *moqPassByMapFn_adaptor) ParamsKey(params moqPassByMapFn_params, anyParams uint64) moqPassByMapFn_paramsKey {
	a.moq.moq.Scene.T.Helper()
	pUsedHash := impl.HashOnlyParamKey(a.moq.moq.Scene.T,
		params.p, "p", 1, a.moq.runtime.parameterIndexing.p, anyParams)
	return moqPassByMapFn_paramsKey{
		params: struct{}{},
		hashes: struct{ p hash.Hash }{
			p: pUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *moqPassByMapFn) Reset() {
	m.moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *moqPassByMapFn) AssertExpectationsMet() {
	m.moq.Scene.T.Helper()
	m.moq.AssertExpectationsMet()
}

// moqPassByReferenceFn holds the state of a moq of the PassByReferenceFn type
type moqPassByReferenceFn struct {
	moq *impl.Moq[
		*moqPassByReferenceFn_adaptor,
		moqPassByReferenceFn_params,
		moqPassByReferenceFn_paramsKey,
		moqPassByReferenceFn_results,
	]

	runtime moqPassByReferenceFn_runtime
}

// moqPassByReferenceFn_runtime holds runtime configuration for the
// PassByReferenceFn type
type moqPassByReferenceFn_runtime struct {
	parameterIndexing moqPassByReferenceFn_paramIndexing
}

// moqPassByReferenceFn_adaptor adapts moqPassByReferenceFn as needed by the
// runtime
type moqPassByReferenceFn_adaptor struct {
	moq *moqPassByReferenceFn
}

// moqPassByReferenceFn_params holds the params of the PassByReferenceFn type
type moqPassByReferenceFn_params struct{ p *testmoqs.Params }

// moqPassByReferenceFn_paramsKey holds the map key params of the
// PassByReferenceFn type
type moqPassByReferenceFn_paramsKey struct {
	params struct{ p *testmoqs.Params }
	hashes struct{ p hash.Hash }
}

// moqPassByReferenceFn_results holds the results of the PassByReferenceFn type
type moqPassByReferenceFn_results struct {
	result1 *testmoqs.Results
}

// moqPassByReferenceFn_paramIndexing holds the parameter indexing runtime
// configuration for the PassByReferenceFn type
type moqPassByReferenceFn_paramIndexing struct {
	p moq.ParamIndexing
}

// moqPassByReferenceFn_doFn defines the type of function needed when calling
// andDo for the PassByReferenceFn type
type moqPassByReferenceFn_doFn func(p *testmoqs.Params)

// moqPassByReferenceFn_doReturnFn defines the type of function needed when
// calling doReturnResults for the PassByReferenceFn type
type moqPassByReferenceFn_doReturnFn func(p *testmoqs.Params) *testmoqs.Results

// moqPassByReferenceFn_recorder routes recorded function calls to the
// moqPassByReferenceFn moq
type moqPassByReferenceFn_recorder struct {
	recorder *impl.Recorder[
		*moqPassByReferenceFn_adaptor,
		moqPassByReferenceFn_params,
		moqPassByReferenceFn_paramsKey,
		moqPassByReferenceFn_results,
	]
}

// moqPassByReferenceFn_anyParams isolates the any params functions of the
// PassByReferenceFn type
type moqPassByReferenceFn_anyParams struct {
	recorder *moqPassByReferenceFn_recorder
}

// newMoqPassByReferenceFn creates a new moq of the PassByReferenceFn type
func newMoqPassByReferenceFn(scene *moq.Scene, config *moq.Config) *moqPassByReferenceFn {
	adaptor1 := &moqPassByReferenceFn_adaptor{}
	m := &moqPassByReferenceFn{
		moq: impl.NewMoq[
			*moqPassByReferenceFn_adaptor,
			moqPassByReferenceFn_params,
			moqPassByReferenceFn_paramsKey,
			moqPassByReferenceFn_results,
		](scene, adaptor1, config),

		runtime: moqPassByReferenceFn_runtime{parameterIndexing: moqPassByReferenceFn_paramIndexing{
			p: moq.ParamIndexByHash,
		}},
	}
	adaptor1.moq = m

	scene.AddMoq(m)
	return m
}

// mock returns the moq implementation of the PassByReferenceFn type
func (m *moqPassByReferenceFn) mock() testmoqs.PassByReferenceFn {
	return func(p *testmoqs.Params) *testmoqs.Results {
		m.moq.Scene.T.Helper()
		params := moqPassByReferenceFn_params{
			p: p,
		}

		var result1 *testmoqs.Results
		if result := m.moq.Function(params); result != nil {
			result1 = result.result1
		}
		return result1
	}
}

func (m *moqPassByReferenceFn) onCall(p *testmoqs.Params) *moqPassByReferenceFn_recorder {
	return &moqPassByReferenceFn_recorder{
		recorder: m.moq.OnCall(moqPassByReferenceFn_params{
			p: p,
		}),
	}
}

func (r *moqPassByReferenceFn_recorder) any() *moqPassByReferenceFn_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqPassByReferenceFn_anyParams{recorder: r}
}

func (a *moqPassByReferenceFn_anyParams) p() *moqPassByReferenceFn_recorder {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (r *moqPassByReferenceFn_recorder) seq() *moqPassByReferenceFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqPassByReferenceFn_recorder) noSeq() *moqPassByReferenceFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqPassByReferenceFn_recorder) returnResults(result1 *testmoqs.Results) *moqPassByReferenceFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqPassByReferenceFn_results{
		result1: result1,
	})
	return r
}

func (r *moqPassByReferenceFn_recorder) andDo(fn moqPassByReferenceFn_doFn) *moqPassByReferenceFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqPassByReferenceFn_params) {
		fn(params.p)
	}, false) {
		return nil
	}
	return r
}

func (r *moqPassByReferenceFn_recorder) doReturnResults(fn moqPassByReferenceFn_doReturnFn) *moqPassByReferenceFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqPassByReferenceFn_params) *moqPassByReferenceFn_results {
		result1 := fn(params.p)
		return &moqPassByReferenceFn_results{
			result1: result1,
		}
	})
	return r
}

func (r *moqPassByReferenceFn_recorder) repeat(repeaters ...moq.Repeater) *moqPassByReferenceFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqPassByReferenceFn_adaptor) PrettyParams(params moqPassByReferenceFn_params) string {
	return fmt.Sprintf("PassByReferenceFn(%#v)", params.p)
}

func (a *moqPassByReferenceFn_adaptor) ParamsKey(params moqPassByReferenceFn_params, anyParams uint64) moqPassByReferenceFn_paramsKey {
	a.moq.moq.Scene.T.Helper()
	pUsed, pUsedHash := impl.ParamKey(
		params.p, 1, a.moq.runtime.parameterIndexing.p, anyParams)
	return moqPassByReferenceFn_paramsKey{
		params: struct{ p *testmoqs.Params }{
			p: pUsed,
		},
		hashes: struct{ p hash.Hash }{
			p: pUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *moqPassByReferenceFn) Reset() {
	m.moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *moqPassByReferenceFn) AssertExpectationsMet() {
	m.moq.Scene.T.Helper()
	m.moq.AssertExpectationsMet()
}

// moqPassBySliceFn holds the state of a moq of the PassBySliceFn type
type moqPassBySliceFn struct {
	moq *impl.Moq[
		*moqPassBySliceFn_adaptor,
		moqPassBySliceFn_params,
		moqPassBySliceFn_paramsKey,
		moqPassBySliceFn_results,
	]

	runtime moqPassBySliceFn_runtime
}

// moqPassBySliceFn_runtime holds runtime configuration for the PassBySliceFn
// type
type moqPassBySliceFn_runtime struct {
	parameterIndexing moqPassBySliceFn_paramIndexing
}

// moqPassBySliceFn_adaptor adapts moqPassBySliceFn as needed by the runtime
type moqPassBySliceFn_adaptor struct {
	moq *moqPassBySliceFn
}

// moqPassBySliceFn_params holds the params of the PassBySliceFn type
type moqPassBySliceFn_params struct{ p []testmoqs.Params }

// moqPassBySliceFn_paramsKey holds the map key params of the PassBySliceFn
// type
type moqPassBySliceFn_paramsKey struct {
	params struct{}
	hashes struct{ p hash.Hash }
}

// moqPassBySliceFn_results holds the results of the PassBySliceFn type
type moqPassBySliceFn_results struct {
	result1 []testmoqs.Results
}

// moqPassBySliceFn_paramIndexing holds the parameter indexing runtime
// configuration for the PassBySliceFn type
type moqPassBySliceFn_paramIndexing struct {
	p moq.ParamIndexing
}

// moqPassBySliceFn_doFn defines the type of function needed when calling andDo
// for the PassBySliceFn type
type moqPassBySliceFn_doFn func(p []testmoqs.Params)

// moqPassBySliceFn_doReturnFn defines the type of function needed when calling
// doReturnResults for the PassBySliceFn type
type moqPassBySliceFn_doReturnFn func(p []testmoqs.Params) []testmoqs.Results

// moqPassBySliceFn_recorder routes recorded function calls to the
// moqPassBySliceFn moq
type moqPassBySliceFn_recorder struct {
	recorder *impl.Recorder[
		*moqPassBySliceFn_adaptor,
		moqPassBySliceFn_params,
		moqPassBySliceFn_paramsKey,
		moqPassBySliceFn_results,
	]
}

// moqPassBySliceFn_anyParams isolates the any params functions of the
// PassBySliceFn type
type moqPassBySliceFn_anyParams struct {
	recorder *moqPassBySliceFn_recorder
}

// newMoqPassBySliceFn creates a new moq of the PassBySliceFn type
func newMoqPassBySliceFn(scene *moq.Scene, config *moq.Config) *moqPassBySliceFn {
	adaptor1 := &moqPassBySliceFn_adaptor{}
	m := &moqPassBySliceFn{
		moq: impl.NewMoq[
			*moqPassBySliceFn_adaptor,
			moqPassBySliceFn_params,
			moqPassBySliceFn_paramsKey,
			moqPassBySliceFn_results,
		](scene, adaptor1, config),

		runtime: moqPassBySliceFn_runtime{parameterIndexing: moqPassBySliceFn_paramIndexing{
			p: moq.ParamIndexByHash,
		}},
	}
	adaptor1.moq = m

	scene.AddMoq(m)
	return m
}

// mock returns the moq implementation of the PassBySliceFn type
func (m *moqPassBySliceFn) mock() testmoqs.PassBySliceFn {
	return func(p []testmoqs.Params) []testmoqs.Results {
		m.moq.Scene.T.Helper()
		params := moqPassBySliceFn_params{
			p: p,
		}

		var result1 []testmoqs.Results
		if result := m.moq.Function(params); result != nil {
			result1 = result.result1
		}
		return result1
	}
}

func (m *moqPassBySliceFn) onCall(p []testmoqs.Params) *moqPassBySliceFn_recorder {
	return &moqPassBySliceFn_recorder{
		recorder: m.moq.OnCall(moqPassBySliceFn_params{
			p: p,
		}),
	}
}

func (r *moqPassBySliceFn_recorder) any() *moqPassBySliceFn_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqPassBySliceFn_anyParams{recorder: r}
}

func (a *moqPassBySliceFn_anyParams) p() *moqPassBySliceFn_recorder {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (r *moqPassBySliceFn_recorder) seq() *moqPassBySliceFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqPassBySliceFn_recorder) noSeq() *moqPassBySliceFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqPassBySliceFn_recorder) returnResults(result1 []testmoqs.Results) *moqPassBySliceFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqPassBySliceFn_results{
		result1: result1,
	})
	return r
}

func (r *moqPassBySliceFn_recorder) andDo(fn moqPassBySliceFn_doFn) *moqPassBySliceFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqPassBySliceFn_params) {
		fn(params.p)
	}, false) {
		return nil
	}
	return r
}

func (r *moqPassBySliceFn_recorder) doReturnResults(fn moqPassBySliceFn_doReturnFn) *moqPassBySliceFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqPassBySliceFn_params) *moqPassBySliceFn_results {
		result1 := fn(params.p)
		return &moqPassBySliceFn_results{
			result1: result1,
		}
	})
	return r
}

func (r *moqPassBySliceFn_recorder) repeat(repeaters ...moq.Repeater) *moqPassBySliceFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqPassBySliceFn_adaptor) PrettyParams(params moqPassBySliceFn_params) string {
	return fmt.Sprintf("PassBySliceFn(%#v)", params.p)
}

func (a *moqPassBySliceFn_adaptor) ParamsKey(params moqPassBySliceFn_params, anyParams uint64) moqPassBySliceFn_paramsKey {
	a.moq.moq.Scene.T.Helper()
	pUsedHash := impl.HashOnlyParamKey(a.moq.moq.Scene.T,
		params.p, "p", 1, a.moq.runtime.parameterIndexing.p, anyParams)
	return moqPassBySliceFn_paramsKey{
		params: struct{}{},
		hashes: struct{ p hash.Hash }{
			p: pUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *moqPassBySliceFn) Reset() {
	m.moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *moqPassBySliceFn) AssertExpectationsMet() {
	m.moq.Scene.T.Helper()
	m.moq.AssertExpectationsMet()
}

// moqPassByValueFn holds the state of a moq of the PassByValueFn type
type moqPassByValueFn struct {
	moq *impl.Moq[
		*moqPassByValueFn_adaptor,
		moqPassByValueFn_params,
		moqPassByValueFn_paramsKey,
		moqPassByValueFn_results,
	]

	runtime moqPassByValueFn_runtime
}

// moqPassByValueFn_runtime holds runtime configuration for the PassByValueFn
// type
type moqPassByValueFn_runtime struct {
	parameterIndexing moqPassByValueFn_paramIndexing
}

// moqPassByValueFn_adaptor adapts moqPassByValueFn as needed by the runtime
type moqPassByValueFn_adaptor struct {
	moq *moqPassByValueFn
}

// moqPassByValueFn_params holds the params of the PassByValueFn type
type moqPassByValueFn_params struct{ p testmoqs.Params }

// moqPassByValueFn_paramsKey holds the map key params of the PassByValueFn
// type
type moqPassByValueFn_paramsKey struct {
	params struct{ p testmoqs.Params }
	hashes struct{ p hash.Hash }
}

// moqPassByValueFn_results holds the results of the PassByValueFn type
type moqPassByValueFn_results struct {
	result1 testmoqs.Results
}

// moqPassByValueFn_paramIndexing holds the parameter indexing runtime
// configuration for the PassByValueFn type
type moqPassByValueFn_paramIndexing struct {
	p moq.ParamIndexing
}

// moqPassByValueFn_doFn defines the type of function needed when calling andDo
// for the PassByValueFn type
type moqPassByValueFn_doFn func(p testmoqs.Params)

// moqPassByValueFn_doReturnFn defines the type of function needed when calling
// doReturnResults for the PassByValueFn type
type moqPassByValueFn_doReturnFn func(p testmoqs.Params) testmoqs.Results

// moqPassByValueFn_recorder routes recorded function calls to the
// moqPassByValueFn moq
type moqPassByValueFn_recorder struct {
	recorder *impl.Recorder[
		*moqPassByValueFn_adaptor,
		moqPassByValueFn_params,
		moqPassByValueFn_paramsKey,
		moqPassByValueFn_results,
	]
}

// moqPassByValueFn_anyParams isolates the any params functions of the
// PassByValueFn type
type moqPassByValueFn_anyParams struct {
	recorder *moqPassByValueFn_recorder
}

// newMoqPassByValueFn creates a new moq of the PassByValueFn type
func newMoqPassByValueFn(scene *moq.Scene, config *moq.Config) *moqPassByValueFn {
	adaptor1 := &moqPassByValueFn_adaptor{}
	m := &moqPassByValueFn{
		moq: impl.NewMoq[
			*moqPassByValueFn_adaptor,
			moqPassByValueFn_params,
			moqPassByValueFn_paramsKey,
			moqPassByValueFn_results,
		](scene, adaptor1, config),

		runtime: moqPassByValueFn_runtime{parameterIndexing: moqPassByValueFn_paramIndexing{
			p: moq.ParamIndexByValue,
		}},
	}
	adaptor1.moq = m

	scene.AddMoq(m)
	return m
}

// mock returns the moq implementation of the PassByValueFn type
func (m *moqPassByValueFn) mock() testmoqs.PassByValueFn {
	return func(p testmoqs.Params) testmoqs.Results {
		m.moq.Scene.T.Helper()
		params := moqPassByValueFn_params{
			p: p,
		}

		var result1 testmoqs.Results
		if result := m.moq.Function(params); result != nil {
			result1 = result.result1
		}
		return result1
	}
}

func (m *moqPassByValueFn) onCall(p testmoqs.Params) *moqPassByValueFn_recorder {
	return &moqPassByValueFn_recorder{
		recorder: m.moq.OnCall(moqPassByValueFn_params{
			p: p,
		}),
	}
}

func (r *moqPassByValueFn_recorder) any() *moqPassByValueFn_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqPassByValueFn_anyParams{recorder: r}
}

func (a *moqPassByValueFn_anyParams) p() *moqPassByValueFn_recorder {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (r *moqPassByValueFn_recorder) seq() *moqPassByValueFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqPassByValueFn_recorder) noSeq() *moqPassByValueFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqPassByValueFn_recorder) returnResults(result1 testmoqs.Results) *moqPassByValueFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqPassByValueFn_results{
		result1: result1,
	})
	return r
}

func (r *moqPassByValueFn_recorder) andDo(fn moqPassByValueFn_doFn) *moqPassByValueFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqPassByValueFn_params) {
		fn(params.p)
	}, false) {
		return nil
	}
	return r
}

func (r *moqPassByValueFn_recorder) doReturnResults(fn moqPassByValueFn_doReturnFn) *moqPassByValueFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqPassByValueFn_params) *moqPassByValueFn_results {
		result1 := fn(params.p)
		return &moqPassByValueFn_results{
			result1: result1,
		}
	})
	return r
}

func (r *moqPassByValueFn_recorder) repeat(repeaters ...moq.Repeater) *moqPassByValueFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqPassByValueFn_adaptor) PrettyParams(params moqPassByValueFn_params) string {
	return fmt.Sprintf("PassByValueFn(%#v)", params.p)
}

func (a *moqPassByValueFn_adaptor) ParamsKey(params moqPassByValueFn_params, anyParams uint64) moqPassByValueFn_paramsKey {
	a.moq.moq.Scene.T.Helper()
	pUsed, pUsedHash := impl.ParamKey(
		params.p, 1, a.moq.runtime.parameterIndexing.p, anyParams)
	return moqPassByValueFn_paramsKey{
		params: struct{ p testmoqs.Params }{
			p: pUsed,
		},
		hashes: struct{ p hash.Hash }{
			p: pUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *moqPassByValueFn) Reset() {
	m.moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *moqPassByValueFn) AssertExpectationsMet() {
	m.moq.Scene.T.Helper()
	m.moq.AssertExpectationsMet()
}

// moqInterfaceParamFn holds the state of a moq of the InterfaceParamFn type
type moqInterfaceParamFn struct {
	moq *impl.Moq[
		*moqInterfaceParamFn_adaptor,
		moqInterfaceParamFn_params,
		moqInterfaceParamFn_paramsKey,
		moqInterfaceParamFn_results,
	]

	runtime moqInterfaceParamFn_runtime
}

// moqInterfaceParamFn_runtime holds runtime configuration for the
// InterfaceParamFn type
type moqInterfaceParamFn_runtime struct {
	parameterIndexing moqInterfaceParamFn_paramIndexing
}

// moqInterfaceParamFn_adaptor adapts moqInterfaceParamFn as needed by the
// runtime
type moqInterfaceParamFn_adaptor struct {
	moq *moqInterfaceParamFn
}

// moqInterfaceParamFn_params holds the params of the InterfaceParamFn type
type moqInterfaceParamFn_params struct{ w io.Writer }

// moqInterfaceParamFn_paramsKey holds the map key params of the
// InterfaceParamFn type
type moqInterfaceParamFn_paramsKey struct {
	params struct{ w io.Writer }
	hashes struct{ w hash.Hash }
}

// moqInterfaceParamFn_results holds the results of the InterfaceParamFn type
type moqInterfaceParamFn_results struct {
	sResult string
	err     error
}

// moqInterfaceParamFn_paramIndexing holds the parameter indexing runtime
// configuration for the InterfaceParamFn type
type moqInterfaceParamFn_paramIndexing struct {
	w moq.ParamIndexing
}

// moqInterfaceParamFn_doFn defines the type of function needed when calling
// andDo for the InterfaceParamFn type
type moqInterfaceParamFn_doFn func(w io.Writer)

// moqInterfaceParamFn_doReturnFn defines the type of function needed when
// calling doReturnResults for the InterfaceParamFn type
type moqInterfaceParamFn_doReturnFn func(w io.Writer) (sResult string, err error)

// moqInterfaceParamFn_recorder routes recorded function calls to the
// moqInterfaceParamFn moq
type moqInterfaceParamFn_recorder struct {
	recorder *impl.Recorder[
		*moqInterfaceParamFn_adaptor,
		moqInterfaceParamFn_params,
		moqInterfaceParamFn_paramsKey,
		moqInterfaceParamFn_results,
	]
}

// moqInterfaceParamFn_anyParams isolates the any params functions of the
// InterfaceParamFn type
type moqInterfaceParamFn_anyParams struct {
	recorder *moqInterfaceParamFn_recorder
}

// newMoqInterfaceParamFn creates a new moq of the InterfaceParamFn type
func newMoqInterfaceParamFn(scene *moq.Scene, config *moq.Config) *moqInterfaceParamFn {
	adaptor1 := &moqInterfaceParamFn_adaptor{}
	m := &moqInterfaceParamFn{
		moq: impl.NewMoq[
			*moqInterfaceParamFn_adaptor,
			moqInterfaceParamFn_params,
			moqInterfaceParamFn_paramsKey,
			moqInterfaceParamFn_results,
		](scene, adaptor1, config),

		runtime: moqInterfaceParamFn_runtime{parameterIndexing: moqInterfaceParamFn_paramIndexing{
			w: moq.ParamIndexByHash,
		}},
	}
	adaptor1.moq = m

	scene.AddMoq(m)
	return m
}

// mock returns the moq implementation of the InterfaceParamFn type
func (m *moqInterfaceParamFn) mock() testmoqs.InterfaceParamFn {
	return func(w io.Writer) (string, error) {
		m.moq.Scene.T.Helper()
		params := moqInterfaceParamFn_params{
			w: w,
		}

		var result1 string
		var result2 error
		if result := m.moq.Function(params); result != nil {
			result1 = result.sResult
			result2 = result.err
		}
		return result1, result2
	}
}

func (m *moqInterfaceParamFn) onCall(w io.Writer) *moqInterfaceParamFn_recorder {
	return &moqInterfaceParamFn_recorder{
		recorder: m.moq.OnCall(moqInterfaceParamFn_params{
			w: w,
		}),
	}
}

func (r *moqInterfaceParamFn_recorder) any() *moqInterfaceParamFn_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqInterfaceParamFn_anyParams{recorder: r}
}

func (a *moqInterfaceParamFn_anyParams) w() *moqInterfaceParamFn_recorder {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (r *moqInterfaceParamFn_recorder) seq() *moqInterfaceParamFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqInterfaceParamFn_recorder) noSeq() *moqInterfaceParamFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqInterfaceParamFn_recorder) returnResults(sResult string, err error) *moqInterfaceParamFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqInterfaceParamFn_results{
		sResult: sResult,
		err:     err,
	})
	return r
}

func (r *moqInterfaceParamFn_recorder) andDo(fn moqInterfaceParamFn_doFn) *moqInterfaceParamFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqInterfaceParamFn_params) {
		fn(params.w)
	}, false) {
		return nil
	}
	return r
}

func (r *moqInterfaceParamFn_recorder) doReturnResults(fn moqInterfaceParamFn_doReturnFn) *moqInterfaceParamFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqInterfaceParamFn_params) *moqInterfaceParamFn_results {
		sResult, err := fn(params.w)
		return &moqInterfaceParamFn_results{
			sResult: sResult,
			err:     err,
		}
	})
	return r
}

func (r *moqInterfaceParamFn_recorder) repeat(repeaters ...moq.Repeater) *moqInterfaceParamFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqInterfaceParamFn_adaptor) PrettyParams(params moqInterfaceParamFn_params) string {
	return fmt.Sprintf("InterfaceParamFn(%#v)", params.w)
}

func (a *moqInterfaceParamFn_adaptor) ParamsKey(params moqInterfaceParamFn_params, anyParams uint64) moqInterfaceParamFn_paramsKey {
	a.moq.moq.Scene.T.Helper()
	wUsed, wUsedHash := impl.ParamKey(
		params.w, 1, a.moq.runtime.parameterIndexing.w, anyParams)
	return moqInterfaceParamFn_paramsKey{
		params: struct{ w io.Writer }{
			w: wUsed,
		},
		hashes: struct{ w hash.Hash }{
			w: wUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *moqInterfaceParamFn) Reset() {
	m.moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *moqInterfaceParamFn) AssertExpectationsMet() {
	m.moq.Scene.T.Helper()
	m.moq.AssertExpectationsMet()
}

// moqInterfaceResultFn holds the state of a moq of the InterfaceResultFn type
type moqInterfaceResultFn struct {
	moq *impl.Moq[
		*moqInterfaceResultFn_adaptor,
		moqInterfaceResultFn_params,
		moqInterfaceResultFn_paramsKey,
		moqInterfaceResultFn_results,
	]

	runtime moqInterfaceResultFn_runtime
}

// moqInterfaceResultFn_runtime holds runtime configuration for the
// InterfaceResultFn type
type moqInterfaceResultFn_runtime struct {
	parameterIndexing moqInterfaceResultFn_paramIndexing
}

// moqInterfaceResultFn_adaptor adapts moqInterfaceResultFn as needed by the
// runtime
type moqInterfaceResultFn_adaptor struct {
	moq *moqInterfaceResultFn
}

// moqInterfaceResultFn_params holds the params of the InterfaceResultFn type
type moqInterfaceResultFn_params struct {
	sParam string
	bParam bool
}

// moqInterfaceResultFn_paramsKey holds the map key params of the
// InterfaceResultFn type
type moqInterfaceResultFn_paramsKey struct {
	params struct {
		sParam string
		bParam bool
	}
	hashes struct {
		sParam hash.Hash
		bParam hash.Hash
	}
}

// moqInterfaceResultFn_results holds the results of the InterfaceResultFn type
type moqInterfaceResultFn_results struct{ result1 io.Reader }

// moqInterfaceResultFn_paramIndexing holds the parameter indexing runtime
// configuration for the InterfaceResultFn type
type moqInterfaceResultFn_paramIndexing struct {
	sParam moq.ParamIndexing
	bParam moq.ParamIndexing
}

// moqInterfaceResultFn_doFn defines the type of function needed when calling
// andDo for the InterfaceResultFn type
type moqInterfaceResultFn_doFn func(sParam string, bParam bool)

// moqInterfaceResultFn_doReturnFn defines the type of function needed when
// calling doReturnResults for the InterfaceResultFn type
type moqInterfaceResultFn_doReturnFn func(sParam string, bParam bool) (r io.Reader)

// moqInterfaceResultFn_recorder routes recorded function calls to the
// moqInterfaceResultFn moq
type moqInterfaceResultFn_recorder struct {
	recorder *impl.Recorder[
		*moqInterfaceResultFn_adaptor,
		moqInterfaceResultFn_params,
		moqInterfaceResultFn_paramsKey,
		moqInterfaceResultFn_results,
	]
}

// moqInterfaceResultFn_anyParams isolates the any params functions of the
// InterfaceResultFn type
type moqInterfaceResultFn_anyParams struct {
	recorder *moqInterfaceResultFn_recorder
}

// newMoqInterfaceResultFn creates a new moq of the InterfaceResultFn type
func newMoqInterfaceResultFn(scene *moq.Scene, config *moq.Config) *moqInterfaceResultFn {
	adaptor1 := &moqInterfaceResultFn_adaptor{}
	m := &moqInterfaceResultFn{
		moq: impl.NewMoq[
			*moqInterfaceResultFn_adaptor,
			moqInterfaceResultFn_params,
			moqInterfaceResultFn_paramsKey,
			moqInterfaceResultFn_results,
		](scene, adaptor1, config),

		runtime: moqInterfaceResultFn_runtime{parameterIndexing: moqInterfaceResultFn_paramIndexing{
			sParam: moq.ParamIndexByValue,
			bParam: moq.ParamIndexByValue,
		}},
	}
	adaptor1.moq = m

	scene.AddMoq(m)
	return m
}

// mock returns the moq implementation of the InterfaceResultFn type
func (m *moqInterfaceResultFn) mock() testmoqs.InterfaceResultFn {
	return func(sParam string, bParam bool) io.Reader {
		m.moq.Scene.T.Helper()
		params := moqInterfaceResultFn_params{
			sParam: sParam,
			bParam: bParam,
		}

		var result1 io.Reader
		if result := m.moq.Function(params); result != nil {
			result1 = result.result1
		}
		return result1
	}
}

func (m *moqInterfaceResultFn) onCall(sParam string, bParam bool) *moqInterfaceResultFn_recorder {
	return &moqInterfaceResultFn_recorder{
		recorder: m.moq.OnCall(moqInterfaceResultFn_params{
			sParam: sParam,
			bParam: bParam,
		}),
	}
}

func (r *moqInterfaceResultFn_recorder) any() *moqInterfaceResultFn_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqInterfaceResultFn_anyParams{recorder: r}
}

func (a *moqInterfaceResultFn_anyParams) sParam() *moqInterfaceResultFn_recorder {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (a *moqInterfaceResultFn_anyParams) bParam() *moqInterfaceResultFn_recorder {
	a.recorder.recorder.AnyParam(2)
	return a.recorder
}

func (r *moqInterfaceResultFn_recorder) seq() *moqInterfaceResultFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqInterfaceResultFn_recorder) noSeq() *moqInterfaceResultFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqInterfaceResultFn_recorder) returnResults(result1 io.Reader) *moqInterfaceResultFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqInterfaceResultFn_results{
		result1: result1,
	})
	return r
}

func (r *moqInterfaceResultFn_recorder) andDo(fn moqInterfaceResultFn_doFn) *moqInterfaceResultFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqInterfaceResultFn_params) {
		fn(params.sParam, params.bParam)
	}, false) {
		return nil
	}
	return r
}

func (r *moqInterfaceResultFn_recorder) doReturnResults(fn moqInterfaceResultFn_doReturnFn) *moqInterfaceResultFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqInterfaceResultFn_params) *moqInterfaceResultFn_results {
		result1 := fn(params.sParam, params.bParam)
		return &moqInterfaceResultFn_results{
			result1: result1,
		}
	})
	return r
}

func (r *moqInterfaceResultFn_recorder) repeat(repeaters ...moq.Repeater) *moqInterfaceResultFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqInterfaceResultFn_adaptor) PrettyParams(params moqInterfaceResultFn_params) string {
	return fmt.Sprintf("InterfaceResultFn(%#v, %#v)", params.sParam, params.bParam)
}

func (a *moqInterfaceResultFn_adaptor) ParamsKey(params moqInterfaceResultFn_params, anyParams uint64) moqInterfaceResultFn_paramsKey {
	a.moq.moq.Scene.T.Helper()
	sParamUsed, sParamUsedHash := impl.ParamKey(
		params.sParam, 1, a.moq.runtime.parameterIndexing.sParam, anyParams)
	bParamUsed, bParamUsedHash := impl.ParamKey(
		params.bParam, 2, a.moq.runtime.parameterIndexing.bParam, anyParams)
	return moqInterfaceResultFn_paramsKey{
		params: struct {
			sParam string
			bParam bool
		}{
			sParam: sParamUsed,
			bParam: bParamUsed,
		},
		hashes: struct {
			sParam hash.Hash
			bParam hash.Hash
		}{
			sParam: sParamUsedHash,
			bParam: bParamUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *moqInterfaceResultFn) Reset() {
	m.moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *moqInterfaceResultFn) AssertExpectationsMet() {
	m.moq.Scene.T.Helper()
	m.moq.AssertExpectationsMet()
}

// moqGenericParamsFn holds the state of a moq of the GenericParamsFn type
type moqGenericParamsFn[S, B any] struct {
	moq *impl.Moq[
		*moqGenericParamsFn_adaptor[S, B],
		moqGenericParamsFn_params[S, B],
		moqGenericParamsFn_paramsKey[S, B],
		moqGenericParamsFn_results[S, B]]

	runtime moqGenericParamsFn_runtime
}

// moqGenericParamsFn_runtime holds runtime configuration for the
// GenericParamsFn type
type moqGenericParamsFn_runtime struct {
	parameterIndexing moqGenericParamsFn_paramIndexing
}

// moqGenericParamsFn_adaptor adapts moqGenericParamsFn as needed by the
// runtime
type moqGenericParamsFn_adaptor[S, B any] struct {
	moq *moqGenericParamsFn[S, B]
}

// moqGenericParamsFn_params holds the params of the GenericParamsFn type
type moqGenericParamsFn_params[S, B any] struct {
	param1 S
	param2 B
}

// moqGenericParamsFn_paramsKey holds the map key params of the GenericParamsFn
// type
type moqGenericParamsFn_paramsKey[S, B any] struct {
	params struct{}
	hashes struct {
		param1 hash.Hash
		param2 hash.Hash
	}
}

// moqGenericParamsFn_results holds the results of the GenericParamsFn type
type moqGenericParamsFn_results[S, B any] struct {
	result1 string
	result2 error
}

// moqGenericParamsFn_paramIndexing holds the parameter indexing runtime
// configuration for the GenericParamsFn type
type moqGenericParamsFn_paramIndexing struct {
	param1 moq.ParamIndexing
	param2 moq.ParamIndexing
}

// moqGenericParamsFn_doFn defines the type of function needed when calling
// andDo for the GenericParamsFn type
type moqGenericParamsFn_doFn[S, B any] func(S, B)

// moqGenericParamsFn_doReturnFn defines the type of function needed when
// calling doReturnResults for the GenericParamsFn type
type moqGenericParamsFn_doReturnFn[S, B any] func(S, B) (string, error)

// moqGenericParamsFn_recorder routes recorded function calls to the
// moqGenericParamsFn moq
type moqGenericParamsFn_recorder[S, B any] struct {
	recorder *impl.Recorder[
		*moqGenericParamsFn_adaptor[S, B],
		moqGenericParamsFn_params[S, B],
		moqGenericParamsFn_paramsKey[S, B],
		moqGenericParamsFn_results[S, B]]
}

// moqGenericParamsFn_anyParams isolates the any params functions of the
// GenericParamsFn type
type moqGenericParamsFn_anyParams[S, B any] struct {
	recorder *moqGenericParamsFn_recorder[S, B]
}

// newMoqGenericParamsFn creates a new moq of the GenericParamsFn type
func newMoqGenericParamsFn[S, B any](scene *moq.Scene, config *moq.Config) *moqGenericParamsFn[S, B] {
	adaptor1 := &moqGenericParamsFn_adaptor[S, B]{}
	m := &moqGenericParamsFn[S, B]{
		moq: impl.NewMoq[
			*moqGenericParamsFn_adaptor[S, B],
			moqGenericParamsFn_params[S, B],
			moqGenericParamsFn_paramsKey[S, B],
			moqGenericParamsFn_results[S, B]](scene, adaptor1, config),

		runtime: moqGenericParamsFn_runtime{parameterIndexing: moqGenericParamsFn_paramIndexing{
			param1: moq.ParamIndexByHash,
			param2: moq.ParamIndexByHash,
		}},
	}
	adaptor1.moq = m

	scene.AddMoq(m)
	return m
}

// mock returns the moq implementation of the GenericParamsFn type
func (m *moqGenericParamsFn[S, B]) mock() testmoqs.GenericParamsFn[S, B] {
	return func(param1 S, param2 B) (string, error) {
		m.moq.Scene.T.Helper()
		params := moqGenericParamsFn_params[S, B]{
			param1: param1,
			param2: param2,
		}

		var result1 string
		var result2 error
		if result := m.moq.Function(params); result != nil {
			result1 = result.result1
			result2 = result.result2
		}
		return result1, result2
	}
}

func (m *moqGenericParamsFn[S, B]) onCall(param1 S, param2 B) *moqGenericParamsFn_recorder[S, B] {
	return &moqGenericParamsFn_recorder[S, B]{
		recorder: m.moq.OnCall(moqGenericParamsFn_params[S, B]{
			param1: param1,
			param2: param2,
		}),
	}
}

func (r *moqGenericParamsFn_recorder[S, B]) any() *moqGenericParamsFn_anyParams[S, B] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqGenericParamsFn_anyParams[S, B]{recorder: r}
}

func (a *moqGenericParamsFn_anyParams[S, B]) param1() *moqGenericParamsFn_recorder[S, B] {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (a *moqGenericParamsFn_anyParams[S, B]) param2() *moqGenericParamsFn_recorder[S, B] {
	a.recorder.recorder.AnyParam(2)
	return a.recorder
}

func (r *moqGenericParamsFn_recorder[S, B]) seq() *moqGenericParamsFn_recorder[S, B] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqGenericParamsFn_recorder[S, B]) noSeq() *moqGenericParamsFn_recorder[S, B] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqGenericParamsFn_recorder[S, B]) returnResults(result1 string, result2 error) *moqGenericParamsFn_recorder[S, B] {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqGenericParamsFn_results[S, B]{
		result1: result1,
		result2: result2,
	})
	return r
}

func (r *moqGenericParamsFn_recorder[S, B]) andDo(fn moqGenericParamsFn_doFn[S, B]) *moqGenericParamsFn_recorder[S, B] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqGenericParamsFn_params[S, B]) {
		fn(params.param1, params.param2)
	}, false) {
		return nil
	}
	return r
}

func (r *moqGenericParamsFn_recorder[S, B]) doReturnResults(fn moqGenericParamsFn_doReturnFn[S, B]) *moqGenericParamsFn_recorder[S, B] {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqGenericParamsFn_params[S, B]) *moqGenericParamsFn_results[S, B] {
		result1, result2 := fn(params.param1, params.param2)
		return &moqGenericParamsFn_results[S, B]{
			result1: result1,
			result2: result2,
		}
	})
	return r
}

func (r *moqGenericParamsFn_recorder[S, B]) repeat(repeaters ...moq.Repeater) *moqGenericParamsFn_recorder[S, B] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqGenericParamsFn_adaptor[S, B]) PrettyParams(params moqGenericParamsFn_params[S, B]) string {
	return fmt.Sprintf("GenericParamsFn(%#v, %#v)", params.param1, params.param2)
}

func (a *moqGenericParamsFn_adaptor[S, B]) ParamsKey(params moqGenericParamsFn_params[S, B], anyParams uint64) moqGenericParamsFn_paramsKey[S, B] {
	a.moq.moq.Scene.T.Helper()
	param1UsedHash := impl.HashOnlyParamKey(a.moq.moq.Scene.T,
		params.param1, "param1", 1, a.moq.runtime.parameterIndexing.param1, anyParams)
	param2UsedHash := impl.HashOnlyParamKey(a.moq.moq.Scene.T,
		params.param2, "param2", 2, a.moq.runtime.parameterIndexing.param2, anyParams)
	return moqGenericParamsFn_paramsKey[S, B]{
		params: struct{}{},
		hashes: struct {
			param1 hash.Hash
			param2 hash.Hash
		}{
			param1: param1UsedHash,
			param2: param2UsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *moqGenericParamsFn[S, B]) Reset() {
	m.moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *moqGenericParamsFn[S, B]) AssertExpectationsMet() {
	m.moq.Scene.T.Helper()
	m.moq.AssertExpectationsMet()
}

// moqPartialGenericParamsFn holds the state of a moq of the
// PartialGenericParamsFn type
type moqPartialGenericParamsFn[S any] struct {
	moq *impl.Moq[
		*moqPartialGenericParamsFn_adaptor[S],
		moqPartialGenericParamsFn_params[S],
		moqPartialGenericParamsFn_paramsKey[S],
		moqPartialGenericParamsFn_results[S]]

	runtime moqPartialGenericParamsFn_runtime
}

// moqPartialGenericParamsFn_runtime holds runtime configuration for the
// PartialGenericParamsFn type
type moqPartialGenericParamsFn_runtime struct {
	parameterIndexing moqPartialGenericParamsFn_paramIndexing
}

// moqPartialGenericParamsFn_adaptor adapts moqPartialGenericParamsFn as needed
// by the runtime
type moqPartialGenericParamsFn_adaptor[S any] struct {
	moq *moqPartialGenericParamsFn[S]
}

// moqPartialGenericParamsFn_params holds the params of the
// PartialGenericParamsFn type
type moqPartialGenericParamsFn_params[S any] struct {
	param1 S
	param2 bool
}

// moqPartialGenericParamsFn_paramsKey holds the map key params of the
// PartialGenericParamsFn type
type moqPartialGenericParamsFn_paramsKey[S any] struct {
	params struct{ param2 bool }
	hashes struct {
		param1 hash.Hash
		param2 hash.Hash
	}
}

// moqPartialGenericParamsFn_results holds the results of the
// PartialGenericParamsFn type
type moqPartialGenericParamsFn_results[S any] struct {
	result1 string
	result2 error
}

// moqPartialGenericParamsFn_paramIndexing holds the parameter indexing runtime
// configuration for the PartialGenericParamsFn type
type moqPartialGenericParamsFn_paramIndexing struct {
	param1 moq.ParamIndexing
	param2 moq.ParamIndexing
}

// moqPartialGenericParamsFn_doFn defines the type of function needed when
// calling andDo for the PartialGenericParamsFn type
type moqPartialGenericParamsFn_doFn[S any] func(S, bool)

// moqPartialGenericParamsFn_doReturnFn defines the type of function needed
// when calling doReturnResults for the PartialGenericParamsFn type
type moqPartialGenericParamsFn_doReturnFn[S any] func(S, bool) (string, error)

// moqPartialGenericParamsFn_recorder routes recorded function calls to the
// moqPartialGenericParamsFn moq
type moqPartialGenericParamsFn_recorder[S any] struct {
	recorder *impl.Recorder[
		*moqPartialGenericParamsFn_adaptor[S],
		moqPartialGenericParamsFn_params[S],
		moqPartialGenericParamsFn_paramsKey[S],
		moqPartialGenericParamsFn_results[S]]
}

// moqPartialGenericParamsFn_anyParams isolates the any params functions of the
// PartialGenericParamsFn type
type moqPartialGenericParamsFn_anyParams[S any] struct {
	recorder *moqPartialGenericParamsFn_recorder[S]
}

// newMoqPartialGenericParamsFn creates a new moq of the PartialGenericParamsFn
// type
func newMoqPartialGenericParamsFn[S any](scene *moq.Scene, config *moq.Config) *moqPartialGenericParamsFn[S] {
	adaptor1 := &moqPartialGenericParamsFn_adaptor[S]{}
	m := &moqPartialGenericParamsFn[S]{
		moq: impl.NewMoq[
			*moqPartialGenericParamsFn_adaptor[S],
			moqPartialGenericParamsFn_params[S],
			moqPartialGenericParamsFn_paramsKey[S],
			moqPartialGenericParamsFn_results[S]](scene, adaptor1, config),

		runtime: moqPartialGenericParamsFn_runtime{parameterIndexing: moqPartialGenericParamsFn_paramIndexing{
			param1: moq.ParamIndexByHash,
			param2: moq.ParamIndexByValue,
		}},
	}
	adaptor1.moq = m

	scene.AddMoq(m)
	return m
}

// mock returns the moq implementation of the PartialGenericParamsFn type
func (m *moqPartialGenericParamsFn[S]) mock() testmoqs.PartialGenericParamsFn[S] {
	return func(param1 S, param2 bool) (string, error) {
		m.moq.Scene.T.Helper()
		params := moqPartialGenericParamsFn_params[S]{
			param1: param1,
			param2: param2,
		}

		var result1 string
		var result2 error
		if result := m.moq.Function(params); result != nil {
			result1 = result.result1
			result2 = result.result2
		}
		return result1, result2
	}
}

func (m *moqPartialGenericParamsFn[S]) onCall(param1 S, param2 bool) *moqPartialGenericParamsFn_recorder[S] {
	return &moqPartialGenericParamsFn_recorder[S]{
		recorder: m.moq.OnCall(moqPartialGenericParamsFn_params[S]{
			param1: param1,
			param2: param2,
		}),
	}
}

func (r *moqPartialGenericParamsFn_recorder[S]) any() *moqPartialGenericParamsFn_anyParams[S] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqPartialGenericParamsFn_anyParams[S]{recorder: r}
}

func (a *moqPartialGenericParamsFn_anyParams[S]) param1() *moqPartialGenericParamsFn_recorder[S] {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (a *moqPartialGenericParamsFn_anyParams[S]) param2() *moqPartialGenericParamsFn_recorder[S] {
	a.recorder.recorder.AnyParam(2)
	return a.recorder
}

func (r *moqPartialGenericParamsFn_recorder[S]) seq() *moqPartialGenericParamsFn_recorder[S] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqPartialGenericParamsFn_recorder[S]) noSeq() *moqPartialGenericParamsFn_recorder[S] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqPartialGenericParamsFn_recorder[S]) returnResults(result1 string, result2 error) *moqPartialGenericParamsFn_recorder[S] {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqPartialGenericParamsFn_results[S]{
		result1: result1,
		result2: result2,
	})
	return r
}

func (r *moqPartialGenericParamsFn_recorder[S]) andDo(fn moqPartialGenericParamsFn_doFn[S]) *moqPartialGenericParamsFn_recorder[S] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqPartialGenericParamsFn_params[S]) {
		fn(params.param1, params.param2)
	}, false) {
		return nil
	}
	return r
}

func (r *moqPartialGenericParamsFn_recorder[S]) doReturnResults(fn moqPartialGenericParamsFn_doReturnFn[S]) *moqPartialGenericParamsFn_recorder[S] {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqPartialGenericParamsFn_params[S]) *moqPartialGenericParamsFn_results[S] {
		result1, result2 := fn(params.param1, params.param2)
		return &moqPartialGenericParamsFn_results[S]{
			result1: result1,
			result2: result2,
		}
	})
	return r
}

func (r *moqPartialGenericParamsFn_recorder[S]) repeat(repeaters ...moq.Repeater) *moqPartialGenericParamsFn_recorder[S] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqPartialGenericParamsFn_adaptor[S]) PrettyParams(params moqPartialGenericParamsFn_params[S]) string {
	return fmt.Sprintf("PartialGenericParamsFn(%#v, %#v)", params.param1, params.param2)
}

func (a *moqPartialGenericParamsFn_adaptor[S]) ParamsKey(params moqPartialGenericParamsFn_params[S], anyParams uint64) moqPartialGenericParamsFn_paramsKey[S] {
	a.moq.moq.Scene.T.Helper()
	param1UsedHash := impl.HashOnlyParamKey(a.moq.moq.Scene.T,
		params.param1, "param1", 1, a.moq.runtime.parameterIndexing.param1, anyParams)
	param2Used, param2UsedHash := impl.ParamKey(
		params.param2, 2, a.moq.runtime.parameterIndexing.param2, anyParams)
	return moqPartialGenericParamsFn_paramsKey[S]{
		params: struct{ param2 bool }{
			param2: param2Used,
		},
		hashes: struct {
			param1 hash.Hash
			param2 hash.Hash
		}{
			param1: param1UsedHash,
			param2: param2UsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *moqPartialGenericParamsFn[S]) Reset() {
	m.moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *moqPartialGenericParamsFn[S]) AssertExpectationsMet() {
	m.moq.Scene.T.Helper()
	m.moq.AssertExpectationsMet()
}

// moqGenericResultsFn holds the state of a moq of the GenericResultsFn type
type moqGenericResultsFn[S ~string, E error] struct {
	moq *impl.Moq[
		*moqGenericResultsFn_adaptor[S, E],
		moqGenericResultsFn_params[S, E],
		moqGenericResultsFn_paramsKey[S, E],
		moqGenericResultsFn_results[S, E]]

	runtime moqGenericResultsFn_runtime
}

// moqGenericResultsFn_runtime holds runtime configuration for the
// GenericResultsFn type
type moqGenericResultsFn_runtime struct {
	parameterIndexing moqGenericResultsFn_paramIndexing
}

// moqGenericResultsFn_adaptor adapts moqGenericResultsFn as needed by the
// runtime
type moqGenericResultsFn_adaptor[S ~string, E error] struct {
	moq *moqGenericResultsFn[S, E]
}

// moqGenericResultsFn_params holds the params of the GenericResultsFn type
type moqGenericResultsFn_params[S ~string, E error] struct {
	param1 string
	param2 bool
}

// moqGenericResultsFn_paramsKey holds the map key params of the
// GenericResultsFn type
type moqGenericResultsFn_paramsKey[S ~string, E error] struct {
	params struct {
		param1 string
		param2 bool
	}
	hashes struct {
		param1 hash.Hash
		param2 hash.Hash
	}
}

// moqGenericResultsFn_results holds the results of the GenericResultsFn type
type moqGenericResultsFn_results[S ~string, E error] struct {
	result1 S
	result2 E
}

// moqGenericResultsFn_paramIndexing holds the parameter indexing runtime
// configuration for the GenericResultsFn type
type moqGenericResultsFn_paramIndexing struct {
	param1 moq.ParamIndexing
	param2 moq.ParamIndexing
}

// moqGenericResultsFn_doFn defines the type of function needed when calling
// andDo for the GenericResultsFn type
type moqGenericResultsFn_doFn[S ~string, E error] func(string, bool)

// moqGenericResultsFn_doReturnFn defines the type of function needed when
// calling doReturnResults for the GenericResultsFn type
type moqGenericResultsFn_doReturnFn[S ~string, E error] func(string, bool) (S, E)

// moqGenericResultsFn_recorder routes recorded function calls to the
// moqGenericResultsFn moq
type moqGenericResultsFn_recorder[S ~string, E error] struct {
	recorder *impl.Recorder[
		*moqGenericResultsFn_adaptor[S, E],
		moqGenericResultsFn_params[S, E],
		moqGenericResultsFn_paramsKey[S, E],
		moqGenericResultsFn_results[S, E]]
}

// moqGenericResultsFn_anyParams isolates the any params functions of the
// GenericResultsFn type
type moqGenericResultsFn_anyParams[S ~string, E error] struct {
	recorder *moqGenericResultsFn_recorder[S, E]
}

// newMoqGenericResultsFn creates a new moq of the GenericResultsFn type
func newMoqGenericResultsFn[S ~string, E error](scene *moq.Scene, config *moq.Config) *moqGenericResultsFn[S, E] {
	adaptor1 := &moqGenericResultsFn_adaptor[S, E]{}
	m := &moqGenericResultsFn[S, E]{
		moq: impl.NewMoq[
			*moqGenericResultsFn_adaptor[S, E],
			moqGenericResultsFn_params[S, E],
			moqGenericResultsFn_paramsKey[S, E],
			moqGenericResultsFn_results[S, E]](scene, adaptor1, config),

		runtime: moqGenericResultsFn_runtime{parameterIndexing: moqGenericResultsFn_paramIndexing{
			param1: moq.ParamIndexByValue,
			param2: moq.ParamIndexByValue,
		}},
	}
	adaptor1.moq = m

	scene.AddMoq(m)
	return m
}

// mock returns the moq implementation of the GenericResultsFn type
func (m *moqGenericResultsFn[S, E]) mock() testmoqs.GenericResultsFn[S, E] {
	return func(param1 string, param2 bool) (S, E) {
		m.moq.Scene.T.Helper()
		params := moqGenericResultsFn_params[S, E]{
			param1: param1,
			param2: param2,
		}

		var result1 S
		var result2 E
		if result := m.moq.Function(params); result != nil {
			result1 = result.result1
			result2 = result.result2
		}
		return result1, result2
	}
}

func (m *moqGenericResultsFn[S, E]) onCall(param1 string, param2 bool) *moqGenericResultsFn_recorder[S, E] {
	return &moqGenericResultsFn_recorder[S, E]{
		recorder: m.moq.OnCall(moqGenericResultsFn_params[S, E]{
			param1: param1,
			param2: param2,
		}),
	}
}

func (r *moqGenericResultsFn_recorder[S, E]) any() *moqGenericResultsFn_anyParams[S, E] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqGenericResultsFn_anyParams[S, E]{recorder: r}
}

func (a *moqGenericResultsFn_anyParams[S, E]) param1() *moqGenericResultsFn_recorder[S, E] {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (a *moqGenericResultsFn_anyParams[S, E]) param2() *moqGenericResultsFn_recorder[S, E] {
	a.recorder.recorder.AnyParam(2)
	return a.recorder
}

func (r *moqGenericResultsFn_recorder[S, E]) seq() *moqGenericResultsFn_recorder[S, E] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqGenericResultsFn_recorder[S, E]) noSeq() *moqGenericResultsFn_recorder[S, E] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqGenericResultsFn_recorder[S, E]) returnResults(result1 S, result2 E) *moqGenericResultsFn_recorder[S, E] {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqGenericResultsFn_results[S, E]{
		result1: result1,
		result2: result2,
	})
	return r
}

func (r *moqGenericResultsFn_recorder[S, E]) andDo(fn moqGenericResultsFn_doFn[S, E]) *moqGenericResultsFn_recorder[S, E] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqGenericResultsFn_params[S, E]) {
		fn(params.param1, params.param2)
	}, false) {
		return nil
	}
	return r
}

func (r *moqGenericResultsFn_recorder[S, E]) doReturnResults(fn moqGenericResultsFn_doReturnFn[S, E]) *moqGenericResultsFn_recorder[S, E] {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqGenericResultsFn_params[S, E]) *moqGenericResultsFn_results[S, E] {
		result1, result2 := fn(params.param1, params.param2)
		return &moqGenericResultsFn_results[S, E]{
			result1: result1,
			result2: result2,
		}
	})
	return r
}

func (r *moqGenericResultsFn_recorder[S, E]) repeat(repeaters ...moq.Repeater) *moqGenericResultsFn_recorder[S, E] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqGenericResultsFn_adaptor[S, E]) PrettyParams(params moqGenericResultsFn_params[S, E]) string {
	return fmt.Sprintf("GenericResultsFn(%#v, %#v)", params.param1, params.param2)
}

func (a *moqGenericResultsFn_adaptor[S, E]) ParamsKey(params moqGenericResultsFn_params[S, E], anyParams uint64) moqGenericResultsFn_paramsKey[S, E] {
	a.moq.moq.Scene.T.Helper()
	param1Used, param1UsedHash := impl.ParamKey(
		params.param1, 1, a.moq.runtime.parameterIndexing.param1, anyParams)
	param2Used, param2UsedHash := impl.ParamKey(
		params.param2, 2, a.moq.runtime.parameterIndexing.param2, anyParams)
	return moqGenericResultsFn_paramsKey[S, E]{
		params: struct {
			param1 string
			param2 bool
		}{
			param1: param1Used,
			param2: param2Used,
		},
		hashes: struct {
			param1 hash.Hash
			param2 hash.Hash
		}{
			param1: param1UsedHash,
			param2: param2UsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *moqGenericResultsFn[S, E]) Reset() {
	m.moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *moqGenericResultsFn[S, E]) AssertExpectationsMet() {
	m.moq.Scene.T.Helper()
	m.moq.AssertExpectationsMet()
}

// moqPartialGenericResultsFn holds the state of a moq of the
// PartialGenericResultsFn type
type moqPartialGenericResultsFn[S ~string] struct {
	moq *impl.Moq[
		*moqPartialGenericResultsFn_adaptor[S],
		moqPartialGenericResultsFn_params[S],
		moqPartialGenericResultsFn_paramsKey[S],
		moqPartialGenericResultsFn_results[S]]

	runtime moqPartialGenericResultsFn_runtime
}

// moqPartialGenericResultsFn_runtime holds runtime configuration for the
// PartialGenericResultsFn type
type moqPartialGenericResultsFn_runtime struct {
	parameterIndexing moqPartialGenericResultsFn_paramIndexing
}

// moqPartialGenericResultsFn_adaptor adapts moqPartialGenericResultsFn as
// needed by the runtime
type moqPartialGenericResultsFn_adaptor[S ~string] struct {
	moq *moqPartialGenericResultsFn[S]
}

// moqPartialGenericResultsFn_params holds the params of the
// PartialGenericResultsFn type
type moqPartialGenericResultsFn_params[S ~string] struct {
	param1 string
	param2 bool
}

// moqPartialGenericResultsFn_paramsKey holds the map key params of the
// PartialGenericResultsFn type
type moqPartialGenericResultsFn_paramsKey[S ~string] struct {
	params struct {
		param1 string
		param2 bool
	}
	hashes struct {
		param1 hash.Hash
		param2 hash.Hash
	}
}

// moqPartialGenericResultsFn_results holds the results of the
// PartialGenericResultsFn type
type moqPartialGenericResultsFn_results[S ~string] struct {
	result1 S
	result2 error
}

// moqPartialGenericResultsFn_paramIndexing holds the parameter indexing
// runtime configuration for the PartialGenericResultsFn type
type moqPartialGenericResultsFn_paramIndexing struct {
	param1 moq.ParamIndexing
	param2 moq.ParamIndexing
}

// moqPartialGenericResultsFn_doFn defines the type of function needed when
// calling andDo for the PartialGenericResultsFn type
type moqPartialGenericResultsFn_doFn[S ~string] func(string, bool)

// moqPartialGenericResultsFn_doReturnFn defines the type of function needed
// when calling doReturnResults for the PartialGenericResultsFn type
type moqPartialGenericResultsFn_doReturnFn[S ~string] func(string, bool) (S, error)

// moqPartialGenericResultsFn_recorder routes recorded function calls to the
// moqPartialGenericResultsFn moq
type moqPartialGenericResultsFn_recorder[S ~string] struct {
	recorder *impl.Recorder[
		*moqPartialGenericResultsFn_adaptor[S],
		moqPartialGenericResultsFn_params[S],
		moqPartialGenericResultsFn_paramsKey[S],
		moqPartialGenericResultsFn_results[S]]
}

// moqPartialGenericResultsFn_anyParams isolates the any params functions of
// the PartialGenericResultsFn type
type moqPartialGenericResultsFn_anyParams[S ~string] struct {
	recorder *moqPartialGenericResultsFn_recorder[S]
}

// newMoqPartialGenericResultsFn creates a new moq of the
// PartialGenericResultsFn type
func newMoqPartialGenericResultsFn[S ~string](scene *moq.Scene, config *moq.Config) *moqPartialGenericResultsFn[S] {
	adaptor1 := &moqPartialGenericResultsFn_adaptor[S]{}
	m := &moqPartialGenericResultsFn[S]{
		moq: impl.NewMoq[
			*moqPartialGenericResultsFn_adaptor[S],
			moqPartialGenericResultsFn_params[S],
			moqPartialGenericResultsFn_paramsKey[S],
			moqPartialGenericResultsFn_results[S]](scene, adaptor1, config),

		runtime: moqPartialGenericResultsFn_runtime{parameterIndexing: moqPartialGenericResultsFn_paramIndexing{
			param1: moq.ParamIndexByValue,
			param2: moq.ParamIndexByValue,
		}},
	}
	adaptor1.moq = m

	scene.AddMoq(m)
	return m
}

// mock returns the moq implementation of the PartialGenericResultsFn type
func (m *moqPartialGenericResultsFn[S]) mock() testmoqs.PartialGenericResultsFn[S] {
	return func(param1 string, param2 bool) (S, error) {
		m.moq.Scene.T.Helper()
		params := moqPartialGenericResultsFn_params[S]{
			param1: param1,
			param2: param2,
		}

		var result1 S
		var result2 error
		if result := m.moq.Function(params); result != nil {
			result1 = result.result1
			result2 = result.result2
		}
		return result1, result2
	}
}

func (m *moqPartialGenericResultsFn[S]) onCall(param1 string, param2 bool) *moqPartialGenericResultsFn_recorder[S] {
	return &moqPartialGenericResultsFn_recorder[S]{
		recorder: m.moq.OnCall(moqPartialGenericResultsFn_params[S]{
			param1: param1,
			param2: param2,
		}),
	}
}

func (r *moqPartialGenericResultsFn_recorder[S]) any() *moqPartialGenericResultsFn_anyParams[S] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqPartialGenericResultsFn_anyParams[S]{recorder: r}
}

func (a *moqPartialGenericResultsFn_anyParams[S]) param1() *moqPartialGenericResultsFn_recorder[S] {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (a *moqPartialGenericResultsFn_anyParams[S]) param2() *moqPartialGenericResultsFn_recorder[S] {
	a.recorder.recorder.AnyParam(2)
	return a.recorder
}

func (r *moqPartialGenericResultsFn_recorder[S]) seq() *moqPartialGenericResultsFn_recorder[S] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqPartialGenericResultsFn_recorder[S]) noSeq() *moqPartialGenericResultsFn_recorder[S] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqPartialGenericResultsFn_recorder[S]) returnResults(result1 S, result2 error) *moqPartialGenericResultsFn_recorder[S] {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqPartialGenericResultsFn_results[S]{
		result1: result1,
		result2: result2,
	})
	return r
}

func (r *moqPartialGenericResultsFn_recorder[S]) andDo(fn moqPartialGenericResultsFn_doFn[S]) *moqPartialGenericResultsFn_recorder[S] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqPartialGenericResultsFn_params[S]) {
		fn(params.param1, params.param2)
	}, false) {
		return nil
	}
	return r
}

func (r *moqPartialGenericResultsFn_recorder[S]) doReturnResults(fn moqPartialGenericResultsFn_doReturnFn[S]) *moqPartialGenericResultsFn_recorder[S] {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqPartialGenericResultsFn_params[S]) *moqPartialGenericResultsFn_results[S] {
		result1, result2 := fn(params.param1, params.param2)
		return &moqPartialGenericResultsFn_results[S]{
			result1: result1,
			result2: result2,
		}
	})
	return r
}

func (r *moqPartialGenericResultsFn_recorder[S]) repeat(repeaters ...moq.Repeater) *moqPartialGenericResultsFn_recorder[S] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqPartialGenericResultsFn_adaptor[S]) PrettyParams(params moqPartialGenericResultsFn_params[S]) string {
	return fmt.Sprintf("PartialGenericResultsFn(%#v, %#v)", params.param1, params.param2)
}

func (a *moqPartialGenericResultsFn_adaptor[S]) ParamsKey(params moqPartialGenericResultsFn_params[S], anyParams uint64) moqPartialGenericResultsFn_paramsKey[S] {
	a.moq.moq.Scene.T.Helper()
	param1Used, param1UsedHash := impl.ParamKey(
		params.param1, 1, a.moq.runtime.parameterIndexing.param1, anyParams)
	param2Used, param2UsedHash := impl.ParamKey(
		params.param2, 2, a.moq.runtime.parameterIndexing.param2, anyParams)
	return moqPartialGenericResultsFn_paramsKey[S]{
		params: struct {
			param1 string
			param2 bool
		}{
			param1: param1Used,
			param2: param2Used,
		},
		hashes: struct {
			param1 hash.Hash
			param2 hash.Hash
		}{
			param1: param1UsedHash,
			param2: param2UsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *moqPartialGenericResultsFn[S]) Reset() {
	m.moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *moqPartialGenericResultsFn[S]) AssertExpectationsMet() {
	m.moq.Scene.T.Helper()
	m.moq.AssertExpectationsMet()
}

// moqGenericInterfaceParamFn holds the state of a moq of the
// GenericInterfaceParamFn type
type moqGenericInterfaceParamFn[W testmoqs.MyWriter] struct {
	moq *impl.Moq[
		*moqGenericInterfaceParamFn_adaptor[W],
		moqGenericInterfaceParamFn_params[W],
		moqGenericInterfaceParamFn_paramsKey[W],
		moqGenericInterfaceParamFn_results[W]]

	runtime moqGenericInterfaceParamFn_runtime
}

// moqGenericInterfaceParamFn_runtime holds runtime configuration for the
// GenericInterfaceParamFn type
type moqGenericInterfaceParamFn_runtime struct {
	parameterIndexing moqGenericInterfaceParamFn_paramIndexing
}

// moqGenericInterfaceParamFn_adaptor adapts moqGenericInterfaceParamFn as
// needed by the runtime
type moqGenericInterfaceParamFn_adaptor[W testmoqs.MyWriter] struct {
	moq *moqGenericInterfaceParamFn[W]
}

// moqGenericInterfaceParamFn_params holds the params of the
// GenericInterfaceParamFn type
type moqGenericInterfaceParamFn_params[W testmoqs.MyWriter] struct{ w W }

// moqGenericInterfaceParamFn_paramsKey holds the map key params of the
// GenericInterfaceParamFn type
type moqGenericInterfaceParamFn_paramsKey[W testmoqs.MyWriter] struct {
	params struct{}
	hashes struct{ w hash.Hash }
}

// moqGenericInterfaceParamFn_results holds the results of the
// GenericInterfaceParamFn type
type moqGenericInterfaceParamFn_results[W testmoqs.MyWriter] struct {
	sResult string
	err     error
}

// moqGenericInterfaceParamFn_paramIndexing holds the parameter indexing
// runtime configuration for the GenericInterfaceParamFn type
type moqGenericInterfaceParamFn_paramIndexing struct {
	w moq.ParamIndexing
}

// moqGenericInterfaceParamFn_doFn defines the type of function needed when
// calling andDo for the GenericInterfaceParamFn type
type moqGenericInterfaceParamFn_doFn[W testmoqs.MyWriter] func(w W)

// moqGenericInterfaceParamFn_doReturnFn defines the type of function needed
// when calling doReturnResults for the GenericInterfaceParamFn type
type moqGenericInterfaceParamFn_doReturnFn[W testmoqs.MyWriter] func(w W) (sResult string, err error)

// moqGenericInterfaceParamFn_recorder routes recorded function calls to the
// moqGenericInterfaceParamFn moq
type moqGenericInterfaceParamFn_recorder[W testmoqs.MyWriter] struct {
	recorder *impl.Recorder[
		*moqGenericInterfaceParamFn_adaptor[W],
		moqGenericInterfaceParamFn_params[W],
		moqGenericInterfaceParamFn_paramsKey[W],
		moqGenericInterfaceParamFn_results[W]]
}

// moqGenericInterfaceParamFn_anyParams isolates the any params functions of
// the GenericInterfaceParamFn type
type moqGenericInterfaceParamFn_anyParams[W testmoqs.MyWriter] struct {
	recorder *moqGenericInterfaceParamFn_recorder[W]
}

// newMoqGenericInterfaceParamFn creates a new moq of the
// GenericInterfaceParamFn type
func newMoqGenericInterfaceParamFn[W testmoqs.MyWriter](scene *moq.Scene, config *moq.Config) *moqGenericInterfaceParamFn[W] {
	adaptor1 := &moqGenericInterfaceParamFn_adaptor[W]{}
	m := &moqGenericInterfaceParamFn[W]{
		moq: impl.NewMoq[
			*moqGenericInterfaceParamFn_adaptor[W],
			moqGenericInterfaceParamFn_params[W],
			moqGenericInterfaceParamFn_paramsKey[W],
			moqGenericInterfaceParamFn_results[W]](scene, adaptor1, config),

		runtime: moqGenericInterfaceParamFn_runtime{parameterIndexing: moqGenericInterfaceParamFn_paramIndexing{
			w: moq.ParamIndexByHash,
		}},
	}
	adaptor1.moq = m

	scene.AddMoq(m)
	return m
}

// mock returns the moq implementation of the GenericInterfaceParamFn type
func (m *moqGenericInterfaceParamFn[W]) mock() testmoqs.GenericInterfaceParamFn[W] {
	return func(w W) (string, error) {
		m.moq.Scene.T.Helper()
		params := moqGenericInterfaceParamFn_params[W]{
			w: w,
		}

		var result1 string
		var result2 error
		if result := m.moq.Function(params); result != nil {
			result1 = result.sResult
			result2 = result.err
		}
		return result1, result2
	}
}

func (m *moqGenericInterfaceParamFn[W]) onCall(w W) *moqGenericInterfaceParamFn_recorder[W] {
	return &moqGenericInterfaceParamFn_recorder[W]{
		recorder: m.moq.OnCall(moqGenericInterfaceParamFn_params[W]{
			w: w,
		}),
	}
}

func (r *moqGenericInterfaceParamFn_recorder[W]) any() *moqGenericInterfaceParamFn_anyParams[W] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqGenericInterfaceParamFn_anyParams[W]{recorder: r}
}

func (a *moqGenericInterfaceParamFn_anyParams[W]) w() *moqGenericInterfaceParamFn_recorder[W] {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (r *moqGenericInterfaceParamFn_recorder[W]) seq() *moqGenericInterfaceParamFn_recorder[W] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqGenericInterfaceParamFn_recorder[W]) noSeq() *moqGenericInterfaceParamFn_recorder[W] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqGenericInterfaceParamFn_recorder[W]) returnResults(sResult string, err error) *moqGenericInterfaceParamFn_recorder[W] {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqGenericInterfaceParamFn_results[W]{
		sResult: sResult,
		err:     err,
	})
	return r
}

func (r *moqGenericInterfaceParamFn_recorder[W]) andDo(fn moqGenericInterfaceParamFn_doFn[W]) *moqGenericInterfaceParamFn_recorder[W] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqGenericInterfaceParamFn_params[W]) {
		fn(params.w)
	}, false) {
		return nil
	}
	return r
}

func (r *moqGenericInterfaceParamFn_recorder[W]) doReturnResults(fn moqGenericInterfaceParamFn_doReturnFn[W]) *moqGenericInterfaceParamFn_recorder[W] {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqGenericInterfaceParamFn_params[W]) *moqGenericInterfaceParamFn_results[W] {
		sResult, err := fn(params.w)
		return &moqGenericInterfaceParamFn_results[W]{
			sResult: sResult,
			err:     err,
		}
	})
	return r
}

func (r *moqGenericInterfaceParamFn_recorder[W]) repeat(repeaters ...moq.Repeater) *moqGenericInterfaceParamFn_recorder[W] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqGenericInterfaceParamFn_adaptor[W]) PrettyParams(params moqGenericInterfaceParamFn_params[W]) string {
	return fmt.Sprintf("GenericInterfaceParamFn(%#v)", params.w)
}

func (a *moqGenericInterfaceParamFn_adaptor[W]) ParamsKey(params moqGenericInterfaceParamFn_params[W], anyParams uint64) moqGenericInterfaceParamFn_paramsKey[W] {
	a.moq.moq.Scene.T.Helper()
	wUsedHash := impl.HashOnlyParamKey(a.moq.moq.Scene.T,
		params.w, "w", 1, a.moq.runtime.parameterIndexing.w, anyParams)
	return moqGenericInterfaceParamFn_paramsKey[W]{
		params: struct{}{},
		hashes: struct{ w hash.Hash }{
			w: wUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *moqGenericInterfaceParamFn[W]) Reset() {
	m.moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *moqGenericInterfaceParamFn[W]) AssertExpectationsMet() {
	m.moq.Scene.T.Helper()
	m.moq.AssertExpectationsMet()
}

// moqGenericInterfaceResultFn holds the state of a moq of the
// GenericInterfaceResultFn type
type moqGenericInterfaceResultFn[R testmoqs.MyReader] struct {
	moq *impl.Moq[
		*moqGenericInterfaceResultFn_adaptor[R],
		moqGenericInterfaceResultFn_params[R],
		moqGenericInterfaceResultFn_paramsKey[R],
		moqGenericInterfaceResultFn_results[R]]

	runtime moqGenericInterfaceResultFn_runtime
}

// moqGenericInterfaceResultFn_runtime holds runtime configuration for the
// GenericInterfaceResultFn type
type moqGenericInterfaceResultFn_runtime struct {
	parameterIndexing moqGenericInterfaceResultFn_paramIndexing
}

// moqGenericInterfaceResultFn_adaptor adapts moqGenericInterfaceResultFn as
// needed by the runtime
type moqGenericInterfaceResultFn_adaptor[R testmoqs.MyReader] struct {
	moq *moqGenericInterfaceResultFn[R]
}

// moqGenericInterfaceResultFn_params holds the params of the
// GenericInterfaceResultFn type
type moqGenericInterfaceResultFn_params[R testmoqs.MyReader] struct {
	sParam string
	bParam bool
}

// moqGenericInterfaceResultFn_paramsKey holds the map key params of the
// GenericInterfaceResultFn type
type moqGenericInterfaceResultFn_paramsKey[R testmoqs.MyReader] struct {
	params struct {
		sParam string
		bParam bool
	}
	hashes struct {
		sParam hash.Hash
		bParam hash.Hash
	}
}

// moqGenericInterfaceResultFn_results holds the results of the
// GenericInterfaceResultFn type
type moqGenericInterfaceResultFn_results[R testmoqs.MyReader] struct{ result1 R }

// moqGenericInterfaceResultFn_paramIndexing holds the parameter indexing
// runtime configuration for the GenericInterfaceResultFn type
type moqGenericInterfaceResultFn_paramIndexing struct {
	sParam moq.ParamIndexing
	bParam moq.ParamIndexing
}

// moqGenericInterfaceResultFn_doFn defines the type of function needed when
// calling andDo for the GenericInterfaceResultFn type
type moqGenericInterfaceResultFn_doFn[R testmoqs.MyReader] func(sParam string, bParam bool)

// moqGenericInterfaceResultFn_doReturnFn defines the type of function needed
// when calling doReturnResults for the GenericInterfaceResultFn type
type moqGenericInterfaceResultFn_doReturnFn[R testmoqs.MyReader] func(sParam string, bParam bool) (r R)

// moqGenericInterfaceResultFn_recorder routes recorded function calls to the
// moqGenericInterfaceResultFn moq
type moqGenericInterfaceResultFn_recorder[R testmoqs.MyReader] struct {
	recorder *impl.Recorder[
		*moqGenericInterfaceResultFn_adaptor[R],
		moqGenericInterfaceResultFn_params[R],
		moqGenericInterfaceResultFn_paramsKey[R],
		moqGenericInterfaceResultFn_results[R]]
}

// moqGenericInterfaceResultFn_anyParams isolates the any params functions of
// the GenericInterfaceResultFn type
type moqGenericInterfaceResultFn_anyParams[R testmoqs.MyReader] struct {
	recorder *moqGenericInterfaceResultFn_recorder[R]
}

// newMoqGenericInterfaceResultFn creates a new moq of the
// GenericInterfaceResultFn type
func newMoqGenericInterfaceResultFn[R testmoqs.MyReader](scene *moq.Scene, config *moq.Config) *moqGenericInterfaceResultFn[R] {
	adaptor1 := &moqGenericInterfaceResultFn_adaptor[R]{}
	m := &moqGenericInterfaceResultFn[R]{
		moq: impl.NewMoq[
			*moqGenericInterfaceResultFn_adaptor[R],
			moqGenericInterfaceResultFn_params[R],
			moqGenericInterfaceResultFn_paramsKey[R],
			moqGenericInterfaceResultFn_results[R]](scene, adaptor1, config),

		runtime: moqGenericInterfaceResultFn_runtime{parameterIndexing: moqGenericInterfaceResultFn_paramIndexing{
			sParam: moq.ParamIndexByValue,
			bParam: moq.ParamIndexByValue,
		}},
	}
	adaptor1.moq = m

	scene.AddMoq(m)
	return m
}

// mock returns the moq implementation of the GenericInterfaceResultFn type
func (m *moqGenericInterfaceResultFn[R]) mock() testmoqs.GenericInterfaceResultFn[R] {
	return func(sParam string, bParam bool) R {
		m.moq.Scene.T.Helper()
		params := moqGenericInterfaceResultFn_params[R]{
			sParam: sParam,
			bParam: bParam,
		}

		var result1 R
		if result := m.moq.Function(params); result != nil {
			result1 = result.result1
		}
		return result1
	}
}

func (m *moqGenericInterfaceResultFn[R]) onCall(sParam string, bParam bool) *moqGenericInterfaceResultFn_recorder[R] {
	return &moqGenericInterfaceResultFn_recorder[R]{
		recorder: m.moq.OnCall(moqGenericInterfaceResultFn_params[R]{
			sParam: sParam,
			bParam: bParam,
		}),
	}
}

func (r *moqGenericInterfaceResultFn_recorder[R]) any() *moqGenericInterfaceResultFn_anyParams[R] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqGenericInterfaceResultFn_anyParams[R]{recorder: r}
}

func (a *moqGenericInterfaceResultFn_anyParams[R]) sParam() *moqGenericInterfaceResultFn_recorder[R] {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (a *moqGenericInterfaceResultFn_anyParams[R]) bParam() *moqGenericInterfaceResultFn_recorder[R] {
	a.recorder.recorder.AnyParam(2)
	return a.recorder
}

func (r *moqGenericInterfaceResultFn_recorder[R]) seq() *moqGenericInterfaceResultFn_recorder[R] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqGenericInterfaceResultFn_recorder[R]) noSeq() *moqGenericInterfaceResultFn_recorder[R] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqGenericInterfaceResultFn_recorder[R]) returnResults(result1 R) *moqGenericInterfaceResultFn_recorder[R] {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqGenericInterfaceResultFn_results[R]{
		result1: result1,
	})
	return r
}

func (r *moqGenericInterfaceResultFn_recorder[R]) andDo(fn moqGenericInterfaceResultFn_doFn[R]) *moqGenericInterfaceResultFn_recorder[R] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqGenericInterfaceResultFn_params[R]) {
		fn(params.sParam, params.bParam)
	}, false) {
		return nil
	}
	return r
}

func (r *moqGenericInterfaceResultFn_recorder[R]) doReturnResults(fn moqGenericInterfaceResultFn_doReturnFn[R]) *moqGenericInterfaceResultFn_recorder[R] {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqGenericInterfaceResultFn_params[R]) *moqGenericInterfaceResultFn_results[R] {
		result1 := fn(params.sParam, params.bParam)
		return &moqGenericInterfaceResultFn_results[R]{
			result1: result1,
		}
	})
	return r
}

func (r *moqGenericInterfaceResultFn_recorder[R]) repeat(repeaters ...moq.Repeater) *moqGenericInterfaceResultFn_recorder[R] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqGenericInterfaceResultFn_adaptor[R]) PrettyParams(params moqGenericInterfaceResultFn_params[R]) string {
	return fmt.Sprintf("GenericInterfaceResultFn(%#v, %#v)", params.sParam, params.bParam)
}

func (a *moqGenericInterfaceResultFn_adaptor[R]) ParamsKey(params moqGenericInterfaceResultFn_params[R], anyParams uint64) moqGenericInterfaceResultFn_paramsKey[R] {
	a.moq.moq.Scene.T.Helper()
	sParamUsed, sParamUsedHash := impl.ParamKey(
		params.sParam, 1, a.moq.runtime.parameterIndexing.sParam, anyParams)
	bParamUsed, bParamUsedHash := impl.ParamKey(
		params.bParam, 2, a.moq.runtime.parameterIndexing.bParam, anyParams)
	return moqGenericInterfaceResultFn_paramsKey[R]{
		params: struct {
			sParam string
			bParam bool
		}{
			sParam: sParamUsed,
			bParam: bParamUsed,
		},
		hashes: struct {
			sParam hash.Hash
			bParam hash.Hash
		}{
			sParam: sParamUsedHash,
			bParam: bParamUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *moqGenericInterfaceResultFn[R]) Reset() {
	m.moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *moqGenericInterfaceResultFn[R]) AssertExpectationsMet() {
	m.moq.Scene.T.Helper()
	m.moq.AssertExpectationsMet()
}

// moqGenericParamsResultsFn holds the state of a moq of the
// GenericParamsResultsFn type
type moqGenericParamsResultsFn[S, B any, E error] struct {
	moq *impl.Moq[
		*moqGenericParamsResultsFn_adaptor[S, B, E],
		moqGenericParamsResultsFn_params[S, B, E],
		moqGenericParamsResultsFn_paramsKey[S, B, E],
		moqGenericParamsResultsFn_results[S, B, E]]

	runtime moqGenericParamsResultsFn_runtime
}

// moqGenericParamsResultsFn_runtime holds runtime configuration for the
// GenericParamsResultsFn type
type moqGenericParamsResultsFn_runtime struct {
	parameterIndexing moqGenericParamsResultsFn_paramIndexing
}

// moqGenericParamsResultsFn_adaptor adapts moqGenericParamsResultsFn as needed
// by the runtime
type moqGenericParamsResultsFn_adaptor[S, B any, E error] struct {
	moq *moqGenericParamsResultsFn[S, B, E]
}

// moqGenericParamsResultsFn_params holds the params of the
// GenericParamsResultsFn type
type moqGenericParamsResultsFn_params[S, B any, E error] struct {
	sParam testmoqs.Container[S]
	bParam testmoqs.Container[B]
}

// moqGenericParamsResultsFn_paramsKey holds the map key params of the
// GenericParamsResultsFn type
type moqGenericParamsResultsFn_paramsKey[S, B any, E error] struct {
	params struct{}
	hashes struct {
		sParam hash.Hash
		bParam hash.Hash
	}
}

// moqGenericParamsResultsFn_results holds the results of the
// GenericParamsResultsFn type
type moqGenericParamsResultsFn_results[S, B any, E error] struct {
	sResult testmoqs.Container[S]
	err     testmoqs.Container[E]
}

// moqGenericParamsResultsFn_paramIndexing holds the parameter indexing runtime
// configuration for the GenericParamsResultsFn type
type moqGenericParamsResultsFn_paramIndexing struct {
	sParam moq.ParamIndexing
	bParam moq.ParamIndexing
}

// moqGenericParamsResultsFn_doFn defines the type of function needed when
// calling andDo for the GenericParamsResultsFn type
type moqGenericParamsResultsFn_doFn[S, B any, E error] func(
	sParam testmoqs.Container[S],
	bParam testmoqs.Container[B],
)

// moqGenericParamsResultsFn_doReturnFn defines the type of function needed
// when calling doReturnResults for the GenericParamsResultsFn type
type moqGenericParamsResultsFn_doReturnFn[S, B any, E error] func(
	sParam testmoqs.Container[S],
	bParam testmoqs.Container[B],
) (sResult testmoqs.Container[S], err testmoqs.Container[E])

// moqGenericParamsResultsFn_recorder routes recorded function calls to the
// moqGenericParamsResultsFn moq
type moqGenericParamsResultsFn_recorder[S, B any, E error] struct {
	recorder *impl.Recorder[
		*moqGenericParamsResultsFn_adaptor[S, B, E],
		moqGenericParamsResultsFn_params[S, B, E],
		moqGenericParamsResultsFn_paramsKey[S, B, E],
		moqGenericParamsResultsFn_results[S, B, E]]
}

// moqGenericParamsResultsFn_anyParams isolates the any params functions of the
// GenericParamsResultsFn type
type moqGenericParamsResultsFn_anyParams[S, B any, E error] struct {
	recorder *moqGenericParamsResultsFn_recorder[S, B, E]
}

// newMoqGenericParamsResultsFn creates a new moq of the GenericParamsResultsFn
// type
func newMoqGenericParamsResultsFn[S, B any, E error](scene *moq.Scene, config *moq.Config) *moqGenericParamsResultsFn[S, B, E] {
	adaptor1 := &moqGenericParamsResultsFn_adaptor[S, B, E]{}
	m := &moqGenericParamsResultsFn[S, B, E]{
		moq: impl.NewMoq[
			*moqGenericParamsResultsFn_adaptor[S, B, E],
			moqGenericParamsResultsFn_params[S, B, E],
			moqGenericParamsResultsFn_paramsKey[S, B, E],
			moqGenericParamsResultsFn_results[S, B, E]](scene, adaptor1, config),

		runtime: moqGenericParamsResultsFn_runtime{parameterIndexing: moqGenericParamsResultsFn_paramIndexing{
			sParam: moq.ParamIndexByHash,
			bParam: moq.ParamIndexByHash,
		}},
	}
	adaptor1.moq = m

	scene.AddMoq(m)
	return m
}

// mock returns the moq implementation of the GenericParamsResultsFn type
func (m *moqGenericParamsResultsFn[S, B, E]) mock() testmoqs.GenericParamsResultsFn[S, B, E] {
	return func(
		sParam testmoqs.Container[S],
		bParam testmoqs.Container[B],
	) (testmoqs.Container[S], testmoqs.Container[E]) {
		m.moq.Scene.T.Helper()
		params := moqGenericParamsResultsFn_params[S, B, E]{
			sParam: sParam,
			bParam: bParam,
		}

		var result1 testmoqs.Container[S]
		var result2 testmoqs.Container[E]
		if result := m.moq.Function(params); result != nil {
			result1 = result.sResult
			result2 = result.err
		}
		return result1, result2
	}
}

func (m *moqGenericParamsResultsFn[S, B, E]) onCall(
	sParam testmoqs.Container[S],
	bParam testmoqs.Container[B],
) *moqGenericParamsResultsFn_recorder[S, B, E] {
	return &moqGenericParamsResultsFn_recorder[S, B, E]{
		recorder: m.moq.OnCall(moqGenericParamsResultsFn_params[S, B, E]{
			sParam: sParam,
			bParam: bParam,
		}),
	}
}

func (r *moqGenericParamsResultsFn_recorder[S, B, E]) any() *moqGenericParamsResultsFn_anyParams[S, B, E] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqGenericParamsResultsFn_anyParams[S, B, E]{recorder: r}
}

func (a *moqGenericParamsResultsFn_anyParams[S, B, E]) sParam() *moqGenericParamsResultsFn_recorder[S, B, E] {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (a *moqGenericParamsResultsFn_anyParams[S, B, E]) bParam() *moqGenericParamsResultsFn_recorder[S, B, E] {
	a.recorder.recorder.AnyParam(2)
	return a.recorder
}

func (r *moqGenericParamsResultsFn_recorder[S, B, E]) seq() *moqGenericParamsResultsFn_recorder[S, B, E] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqGenericParamsResultsFn_recorder[S, B, E]) noSeq() *moqGenericParamsResultsFn_recorder[S, B, E] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqGenericParamsResultsFn_recorder[S, B, E]) returnResults(sResult testmoqs.Container[S], err testmoqs.Container[E]) *moqGenericParamsResultsFn_recorder[S, B, E] {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqGenericParamsResultsFn_results[S, B, E]{
		sResult: sResult,
		err:     err,
	})
	return r
}

func (r *moqGenericParamsResultsFn_recorder[S, B, E]) andDo(fn moqGenericParamsResultsFn_doFn[S, B, E]) *moqGenericParamsResultsFn_recorder[S, B, E] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqGenericParamsResultsFn_params[S, B, E]) {
		fn(params.sParam, params.bParam)
	}, false) {
		return nil
	}
	return r
}

func (r *moqGenericParamsResultsFn_recorder[S, B, E]) doReturnResults(fn moqGenericParamsResultsFn_doReturnFn[S, B, E]) *moqGenericParamsResultsFn_recorder[S, B, E] {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqGenericParamsResultsFn_params[S, B, E]) *moqGenericParamsResultsFn_results[S, B, E] {
		sResult, err := fn(params.sParam, params.bParam)
		return &moqGenericParamsResultsFn_results[S, B, E]{
			sResult: sResult,
			err:     err,
		}
	})
	return r
}

func (r *moqGenericParamsResultsFn_recorder[S, B, E]) repeat(repeaters ...moq.Repeater) *moqGenericParamsResultsFn_recorder[S, B, E] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqGenericParamsResultsFn_adaptor[S, B, E]) PrettyParams(params moqGenericParamsResultsFn_params[S, B, E]) string {
	return fmt.Sprintf("GenericParamsResultsFn(%#v, %#v)", params.sParam, params.bParam)
}

func (a *moqGenericParamsResultsFn_adaptor[S, B, E]) ParamsKey(params moqGenericParamsResultsFn_params[S, B, E], anyParams uint64) moqGenericParamsResultsFn_paramsKey[S, B, E] {
	a.moq.moq.Scene.T.Helper()
	sParamUsedHash := impl.HashOnlyParamKey(a.moq.moq.Scene.T,
		params.sParam, "sParam", 1, a.moq.runtime.parameterIndexing.sParam, anyParams)
	bParamUsedHash := impl.HashOnlyParamKey(a.moq.moq.Scene.T,
		params.bParam, "bParam", 2, a.moq.runtime.parameterIndexing.bParam, anyParams)
	return moqGenericParamsResultsFn_paramsKey[S, B, E]{
		params: struct{}{},
		hashes: struct {
			sParam hash.Hash
			bParam hash.Hash
		}{
			sParam: sParamUsedHash,
			bParam: bParamUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *moqGenericParamsResultsFn[S, B, E]) Reset() {
	m.moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *moqGenericParamsResultsFn[S, B, E]) AssertExpectationsMet() {
	m.moq.Scene.T.Helper()
	m.moq.AssertExpectationsMet()
}

// The following type assertion assures that testmoqs.Usual is mocked
// completely
var _ testmoqs.Usual = (*moqUsual_mock)(nil)

// moqUsual holds the state of a moq of the Usual type
type moqUsual struct {
	moq *moqUsual_mock

	moq_Usual *impl.Moq[
		*moqUsual_Usual_adaptor,
		moqUsual_Usual_params,
		moqUsual_Usual_paramsKey,
		moqUsual_Usual_results,
	]
	moq_NoNames *impl.Moq[
		*moqUsual_NoNames_adaptor,
		moqUsual_NoNames_params,
		moqUsual_NoNames_paramsKey,
		moqUsual_NoNames_results,
	]
	moq_NoResults *impl.Moq[
		*moqUsual_NoResults_adaptor,
		moqUsual_NoResults_params,
		moqUsual_NoResults_paramsKey,
		moqUsual_NoResults_results,
	]
	moq_NoParams *impl.Moq[
		*moqUsual_NoParams_adaptor,
		moqUsual_NoParams_params,
		moqUsual_NoParams_paramsKey,
		moqUsual_NoParams_results,
	]
	moq_Nothing *impl.Moq[
		*moqUsual_Nothing_adaptor,
		moqUsual_Nothing_params,
		moqUsual_Nothing_paramsKey,
		moqUsual_Nothing_results,
	]
	moq_Variadic *impl.Moq[
		*moqUsual_Variadic_adaptor,
		moqUsual_Variadic_params,
		moqUsual_Variadic_paramsKey,
		moqUsual_Variadic_results,
	]
	moq_RepeatedIds *impl.Moq[
		*moqUsual_RepeatedIds_adaptor,
		moqUsual_RepeatedIds_params,
		moqUsual_RepeatedIds_paramsKey,
		moqUsual_RepeatedIds_results,
	]
	moq_Times *impl.Moq[
		*moqUsual_Times_adaptor,
		moqUsual_Times_params,
		moqUsual_Times_paramsKey,
		moqUsual_Times_results,
	]
	moq_DifficultParamNames *impl.Moq[
		*moqUsual_DifficultParamNames_adaptor,
		moqUsual_DifficultParamNames_params,
		moqUsual_DifficultParamNames_paramsKey,
		moqUsual_DifficultParamNames_results,
	]
	moq_DifficultResultNames *impl.Moq[
		*moqUsual_DifficultResultNames_adaptor,
		moqUsual_DifficultResultNames_params,
		moqUsual_DifficultResultNames_paramsKey,
		moqUsual_DifficultResultNames_results,
	]
	moq_PassByArray *impl.Moq[
		*moqUsual_PassByArray_adaptor,
		moqUsual_PassByArray_params,
		moqUsual_PassByArray_paramsKey,
		moqUsual_PassByArray_results,
	]
	moq_PassByChan *impl.Moq[
		*moqUsual_PassByChan_adaptor,
		moqUsual_PassByChan_params,
		moqUsual_PassByChan_paramsKey,
		moqUsual_PassByChan_results,
	]
	moq_PassByEllipsis *impl.Moq[
		*moqUsual_PassByEllipsis_adaptor,
		moqUsual_PassByEllipsis_params,
		moqUsual_PassByEllipsis_paramsKey,
		moqUsual_PassByEllipsis_results,
	]
	moq_PassByMap *impl.Moq[
		*moqUsual_PassByMap_adaptor,
		moqUsual_PassByMap_params,
		moqUsual_PassByMap_paramsKey,
		moqUsual_PassByMap_results,
	]
	moq_PassByReference *impl.Moq[
		*moqUsual_PassByReference_adaptor,
		moqUsual_PassByReference_params,
		moqUsual_PassByReference_paramsKey,
		moqUsual_PassByReference_results,
	]
	moq_PassBySlice *impl.Moq[
		*moqUsual_PassBySlice_adaptor,
		moqUsual_PassBySlice_params,
		moqUsual_PassBySlice_paramsKey,
		moqUsual_PassBySlice_results,
	]
	moq_PassByValue *impl.Moq[
		*moqUsual_PassByValue_adaptor,
		moqUsual_PassByValue_params,
		moqUsual_PassByValue_paramsKey,
		moqUsual_PassByValue_results,
	]
	moq_InterfaceParam *impl.Moq[
		*moqUsual_InterfaceParam_adaptor,
		moqUsual_InterfaceParam_params,
		moqUsual_InterfaceParam_paramsKey,
		moqUsual_InterfaceParam_results,
	]
	moq_InterfaceResult *impl.Moq[
		*moqUsual_InterfaceResult_adaptor,
		moqUsual_InterfaceResult_params,
		moqUsual_InterfaceResult_paramsKey,
		moqUsual_InterfaceResult_results,
	]
	moq_FnParam *impl.Moq[
		*moqUsual_FnParam_adaptor,
		moqUsual_FnParam_params,
		moqUsual_FnParam_paramsKey,
		moqUsual_FnParam_results,
	]
	moq_Other *impl.Moq[
		*moqUsual_Other_adaptor,
		moqUsual_Other_params,
		moqUsual_Other_paramsKey,
		moqUsual_Other_results,
	]

	runtime moqUsual_runtime
}

// moqUsual_mock isolates the mock interface of the Usual type
type moqUsual_mock struct {
	moq *moqUsual
}

// moqUsual_recorder isolates the recorder interface of the Usual type
type moqUsual_recorder struct {
	moq *moqUsual
}

// moqUsual_runtime holds runtime configuration for the Usual type
type moqUsual_runtime struct {
	parameterIndexing struct {
		Usual                moqUsual_Usual_paramIndexing
		NoNames              moqUsual_NoNames_paramIndexing
		NoResults            moqUsual_NoResults_paramIndexing
		NoParams             moqUsual_NoParams_paramIndexing
		Nothing              moqUsual_Nothing_paramIndexing
		Variadic             moqUsual_Variadic_paramIndexing
		RepeatedIds          moqUsual_RepeatedIds_paramIndexing
		Times                moqUsual_Times_paramIndexing
		DifficultParamNames  moqUsual_DifficultParamNames_paramIndexing
		DifficultResultNames moqUsual_DifficultResultNames_paramIndexing
		PassByArray          moqUsual_PassByArray_paramIndexing
		PassByChan           moqUsual_PassByChan_paramIndexing
		PassByEllipsis       moqUsual_PassByEllipsis_paramIndexing
		PassByMap            moqUsual_PassByMap_paramIndexing
		PassByReference      moqUsual_PassByReference_paramIndexing
		PassBySlice          moqUsual_PassBySlice_paramIndexing
		PassByValue          moqUsual_PassByValue_paramIndexing
		InterfaceParam       moqUsual_InterfaceParam_paramIndexing
		InterfaceResult      moqUsual_InterfaceResult_paramIndexing
		FnParam              moqUsual_FnParam_paramIndexing
		Other                moqUsual_Other_paramIndexing
	}
}

// moqUsual_Usual_adaptor adapts moqUsual as needed by the runtime
type moqUsual_Usual_adaptor struct {
	moq *moqUsual
}

// moqUsual_Usual_params holds the params of the Usual type
type moqUsual_Usual_params struct {
	sParam string
	bParam bool
}

// moqUsual_Usual_paramsKey holds the map key params of the Usual type
type moqUsual_Usual_paramsKey struct {
	params struct {
		sParam string
		bParam bool
	}
	hashes struct {
		sParam hash.Hash
		bParam hash.Hash
	}
}

// moqUsual_Usual_results holds the results of the Usual type
type moqUsual_Usual_results struct {
	sResult string
	err     error
}

// moqUsual_Usual_paramIndexing holds the parameter indexing runtime
// configuration for the Usual type
type moqUsual_Usual_paramIndexing struct {
	sParam moq.ParamIndexing
	bParam moq.ParamIndexing
}

// moqUsual_Usual_doFn defines the type of function needed when calling andDo
// for the Usual type
type moqUsual_Usual_doFn func(sParam string, bParam bool)

// moqUsual_Usual_doReturnFn defines the type of function needed when calling
// doReturnResults for the Usual type
type moqUsual_Usual_doReturnFn func(sParam string, bParam bool) (sResult string, err error)

// moqUsual_Usual_recorder routes recorded function calls to the moqUsual moq
type moqUsual_Usual_recorder struct {
	recorder *impl.Recorder[
		*moqUsual_Usual_adaptor,
		moqUsual_Usual_params,
		moqUsual_Usual_paramsKey,
		moqUsual_Usual_results,
	]
}

// moqUsual_Usual_anyParams isolates the any params functions of the Usual type
type moqUsual_Usual_anyParams struct {
	recorder *moqUsual_Usual_recorder
}

// moqUsual_NoNames_adaptor adapts moqUsual as needed by the runtime
type moqUsual_NoNames_adaptor struct {
	moq *moqUsual
}

// moqUsual_NoNames_params holds the params of the Usual type
type moqUsual_NoNames_params struct {
	param1 string
	param2 bool
}

// moqUsual_NoNames_paramsKey holds the map key params of the Usual type
type moqUsual_NoNames_paramsKey struct {
	params struct {
		param1 string
		param2 bool
	}
	hashes struct {
		param1 hash.Hash
		param2 hash.Hash
	}
}

// moqUsual_NoNames_results holds the results of the Usual type
type moqUsual_NoNames_results struct {
	result1 string
	result2 error
}

// moqUsual_NoNames_paramIndexing holds the parameter indexing runtime
// configuration for the Usual type
type moqUsual_NoNames_paramIndexing struct {
	param1 moq.ParamIndexing
	param2 moq.ParamIndexing
}

// moqUsual_NoNames_doFn defines the type of function needed when calling andDo
// for the Usual type
type moqUsual_NoNames_doFn func(string, bool)

// moqUsual_NoNames_doReturnFn defines the type of function needed when calling
// doReturnResults for the Usual type
type moqUsual_NoNames_doReturnFn func(string, bool) (string, error)

// moqUsual_NoNames_recorder routes recorded function calls to the moqUsual moq
type moqUsual_NoNames_recorder struct {
	recorder *impl.Recorder[
		*moqUsual_NoNames_adaptor,
		moqUsual_NoNames_params,
		moqUsual_NoNames_paramsKey,
		moqUsual_NoNames_results,
	]
}

// moqUsual_NoNames_anyParams isolates the any params functions of the Usual
// type
type moqUsual_NoNames_anyParams struct {
	recorder *moqUsual_NoNames_recorder
}

// moqUsual_NoResults_adaptor adapts moqUsual as needed by the runtime
type moqUsual_NoResults_adaptor struct {
	moq *moqUsual
}

// moqUsual_NoResults_params holds the params of the Usual type
type moqUsual_NoResults_params struct {
	sParam string
	bParam bool
}

// moqUsual_NoResults_paramsKey holds the map key params of the Usual type
type moqUsual_NoResults_paramsKey struct {
	params struct {
		sParam string
		bParam bool
	}
	hashes struct {
		sParam hash.Hash
		bParam hash.Hash
	}
}

// moqUsual_NoResults_results holds the results of the Usual type
type moqUsual_NoResults_results struct{}

// moqUsual_NoResults_paramIndexing holds the parameter indexing runtime
// configuration for the Usual type
type moqUsual_NoResults_paramIndexing struct {
	sParam moq.ParamIndexing
	bParam moq.ParamIndexing
}

// moqUsual_NoResults_doFn defines the type of function needed when calling
// andDo for the Usual type
type moqUsual_NoResults_doFn func(sParam string, bParam bool)

// moqUsual_NoResults_doReturnFn defines the type of function needed when
// calling doReturnResults for the Usual type
type moqUsual_NoResults_doReturnFn func(sParam string, bParam bool)

// moqUsual_NoResults_recorder routes recorded function calls to the moqUsual
// moq
type moqUsual_NoResults_recorder struct {
	recorder *impl.Recorder[
		*moqUsual_NoResults_adaptor,
		moqUsual_NoResults_params,
		moqUsual_NoResults_paramsKey,
		moqUsual_NoResults_results,
	]
}

// moqUsual_NoResults_anyParams isolates the any params functions of the Usual
// type
type moqUsual_NoResults_anyParams struct {
	recorder *moqUsual_NoResults_recorder
}

// moqUsual_NoParams_adaptor adapts moqUsual as needed by the runtime
type moqUsual_NoParams_adaptor struct {
	moq *moqUsual
}

// moqUsual_NoParams_params holds the params of the Usual type
type moqUsual_NoParams_params struct{}

// moqUsual_NoParams_paramsKey holds the map key params of the Usual type
type moqUsual_NoParams_paramsKey struct {
	params struct{}
	hashes struct{}
}

// moqUsual_NoParams_results holds the results of the Usual type
type moqUsual_NoParams_results struct {
	sResult string
	err     error
}

// moqUsual_NoParams_paramIndexing holds the parameter indexing runtime
// configuration for the Usual type
type moqUsual_NoParams_paramIndexing struct{}

// moqUsual_NoParams_doFn defines the type of function needed when calling
// andDo for the Usual type
type moqUsual_NoParams_doFn func()

// moqUsual_NoParams_doReturnFn defines the type of function needed when
// calling doReturnResults for the Usual type
type moqUsual_NoParams_doReturnFn func() (sResult string, err error)

// moqUsual_NoParams_recorder routes recorded function calls to the moqUsual
// moq
type moqUsual_NoParams_recorder struct {
	recorder *impl.Recorder[
		*moqUsual_NoParams_adaptor,
		moqUsual_NoParams_params,
		moqUsual_NoParams_paramsKey,
		moqUsual_NoParams_results,
	]
}

// moqUsual_NoParams_anyParams isolates the any params functions of the Usual
// type
type moqUsual_NoParams_anyParams struct {
	recorder *moqUsual_NoParams_recorder
}

// moqUsual_Nothing_adaptor adapts moqUsual as needed by the runtime
type moqUsual_Nothing_adaptor struct {
	moq *moqUsual
}

// moqUsual_Nothing_params holds the params of the Usual type
type moqUsual_Nothing_params struct{}

// moqUsual_Nothing_paramsKey holds the map key params of the Usual type
type moqUsual_Nothing_paramsKey struct {
	params struct{}
	hashes struct{}
}

// moqUsual_Nothing_results holds the results of the Usual type
type moqUsual_Nothing_results struct{}

// moqUsual_Nothing_paramIndexing holds the parameter indexing runtime
// configuration for the Usual type
type moqUsual_Nothing_paramIndexing struct{}

// moqUsual_Nothing_doFn defines the type of function needed when calling andDo
// for the Usual type
type moqUsual_Nothing_doFn func()

// moqUsual_Nothing_doReturnFn defines the type of function needed when calling
// doReturnResults for the Usual type
type moqUsual_Nothing_doReturnFn func()

// moqUsual_Nothing_recorder routes recorded function calls to the moqUsual moq
type moqUsual_Nothing_recorder struct {
	recorder *impl.Recorder[
		*moqUsual_Nothing_adaptor,
		moqUsual_Nothing_params,
		moqUsual_Nothing_paramsKey,
		moqUsual_Nothing_results,
	]
}

// moqUsual_Nothing_anyParams isolates the any params functions of the Usual
// type
type moqUsual_Nothing_anyParams struct {
	recorder *moqUsual_Nothing_recorder
}

// moqUsual_Variadic_adaptor adapts moqUsual as needed by the runtime
type moqUsual_Variadic_adaptor struct {
	moq *moqUsual
}

// moqUsual_Variadic_params holds the params of the Usual type
type moqUsual_Variadic_params struct {
	other bool
	args  []string
}

// moqUsual_Variadic_paramsKey holds the map key params of the Usual type
type moqUsual_Variadic_paramsKey struct {
	params struct{ other bool }
	hashes struct {
		other hash.Hash
		args  hash.Hash
	}
}

// moqUsual_Variadic_results holds the results of the Usual type
type moqUsual_Variadic_results struct {
	sResult string
	err     error
}

// moqUsual_Variadic_paramIndexing holds the parameter indexing runtime
// configuration for the Usual type
type moqUsual_Variadic_paramIndexing struct {
	other moq.ParamIndexing
	args  moq.ParamIndexing
}

// moqUsual_Variadic_doFn defines the type of function needed when calling
// andDo for the Usual type
type moqUsual_Variadic_doFn func(other bool, args ...string)

// moqUsual_Variadic_doReturnFn defines the type of function needed when
// calling doReturnResults for the Usual type
type moqUsual_Variadic_doReturnFn func(other bool, args ...string) (sResult string, err error)

// moqUsual_Variadic_recorder routes recorded function calls to the moqUsual
// moq
type moqUsual_Variadic_recorder struct {
	recorder *impl.Recorder[
		*moqUsual_Variadic_adaptor,
		moqUsual_Variadic_params,
		moqUsual_Variadic_paramsKey,
		moqUsual_Variadic_results,
	]
}

// moqUsual_Variadic_anyParams isolates the any params functions of the Usual
// type
type moqUsual_Variadic_anyParams struct {
	recorder *moqUsual_Variadic_recorder
}

// moqUsual_RepeatedIds_adaptor adapts moqUsual as needed by the runtime
type moqUsual_RepeatedIds_adaptor struct {
	moq *moqUsual
}

// moqUsual_RepeatedIds_params holds the params of the Usual type
type moqUsual_RepeatedIds_params struct {
	sParam1, sParam2 string
	bParam           bool
}

// moqUsual_RepeatedIds_paramsKey holds the map key params of the Usual type
type moqUsual_RepeatedIds_paramsKey struct {
	params struct {
		sParam1, sParam2 string
		bParam           bool
	}
	hashes struct {
		sParam1, sParam2 hash.Hash
		bParam           hash.Hash
	}
}

// moqUsual_RepeatedIds_results holds the results of the Usual type
type moqUsual_RepeatedIds_results struct {
	sResult1, sResult2 string
	err                error
}

// moqUsual_RepeatedIds_paramIndexing holds the parameter indexing runtime
// configuration for the Usual type
type moqUsual_RepeatedIds_paramIndexing struct {
	sParam1, sParam2 moq.ParamIndexing
	bParam           moq.ParamIndexing
}

// moqUsual_RepeatedIds_doFn defines the type of function needed when calling
// andDo for the Usual type
type moqUsual_RepeatedIds_doFn func(sParam1, sParam2 string, bParam bool)

// moqUsual_RepeatedIds_doReturnFn defines the type of function needed when
// calling doReturnResults for the Usual type
type moqUsual_RepeatedIds_doReturnFn func(sParam1, sParam2 string, bParam bool) (sResult1, sResult2 string, err error)

// moqUsual_RepeatedIds_recorder routes recorded function calls to the moqUsual
// moq
type moqUsual_RepeatedIds_recorder struct {
	recorder *impl.Recorder[
		*moqUsual_RepeatedIds_adaptor,
		moqUsual_RepeatedIds_params,
		moqUsual_RepeatedIds_paramsKey,
		moqUsual_RepeatedIds_results,
	]
}

// moqUsual_RepeatedIds_anyParams isolates the any params functions of the
// Usual type
type moqUsual_RepeatedIds_anyParams struct {
	recorder *moqUsual_RepeatedIds_recorder
}

// moqUsual_Times_adaptor adapts moqUsual as needed by the runtime
type moqUsual_Times_adaptor struct {
	moq *moqUsual
}

// moqUsual_Times_params holds the params of the Usual type
type moqUsual_Times_params struct {
	sParam string
	times  bool
}

// moqUsual_Times_paramsKey holds the map key params of the Usual type
type moqUsual_Times_paramsKey struct {
	params struct {
		sParam string
		times  bool
	}
	hashes struct {
		sParam hash.Hash
		times  hash.Hash
	}
}

// moqUsual_Times_results holds the results of the Usual type
type moqUsual_Times_results struct {
	sResult string
	err     error
}

// moqUsual_Times_paramIndexing holds the parameter indexing runtime
// configuration for the Usual type
type moqUsual_Times_paramIndexing struct {
	sParam moq.ParamIndexing
	times  moq.ParamIndexing
}

// moqUsual_Times_doFn defines the type of function needed when calling andDo
// for the Usual type
type moqUsual_Times_doFn func(sParam string, times bool)

// moqUsual_Times_doReturnFn defines the type of function needed when calling
// doReturnResults for the Usual type
type moqUsual_Times_doReturnFn func(sParam string, times bool) (sResult string, err error)

// moqUsual_Times_recorder routes recorded function calls to the moqUsual moq
type moqUsual_Times_recorder struct {
	recorder *impl.Recorder[
		*moqUsual_Times_adaptor,
		moqUsual_Times_params,
		moqUsual_Times_paramsKey,
		moqUsual_Times_results,
	]
}

// moqUsual_Times_anyParams isolates the any params functions of the Usual type
type moqUsual_Times_anyParams struct {
	recorder *moqUsual_Times_recorder
}

// moqUsual_DifficultParamNames_adaptor adapts moqUsual as needed by the
// runtime
type moqUsual_DifficultParamNames_adaptor struct {
	moq *moqUsual
}

// moqUsual_DifficultParamNames_params holds the params of the Usual type
type moqUsual_DifficultParamNames_params struct {
	param1, param2         bool
	param3                 string
	param, param5, param6  int
	param7, param8, param9 float32
}

// moqUsual_DifficultParamNames_paramsKey holds the map key params of the Usual
// type
type moqUsual_DifficultParamNames_paramsKey struct {
	params struct {
		param1, param2         bool
		param3                 string
		param, param5, param6  int
		param7, param8, param9 float32
	}
	hashes struct {
		param1, param2         hash.Hash
		param3                 hash.Hash
		param, param5, param6  hash.Hash
		param7, param8, param9 hash.Hash
	}
}

// moqUsual_DifficultParamNames_results holds the results of the Usual type
type moqUsual_DifficultParamNames_results struct{}

// moqUsual_DifficultParamNames_paramIndexing holds the parameter indexing
// runtime configuration for the Usual type
type moqUsual_DifficultParamNames_paramIndexing struct {
	param1, param2         moq.ParamIndexing
	param3                 moq.ParamIndexing
	param, param5, param6  moq.ParamIndexing
	param7, param8, param9 moq.ParamIndexing
}

// moqUsual_DifficultParamNames_doFn defines the type of function needed when
// calling andDo for the Usual type
type moqUsual_DifficultParamNames_doFn func(m, r bool, sequence string, param, params, i int, result, results, _ float32)

// moqUsual_DifficultParamNames_doReturnFn defines the type of function needed
// when calling doReturnResults for the Usual type
type moqUsual_DifficultParamNames_doReturnFn func(m, r bool, sequence string, param, params, i int, result, results, _ float32)

// moqUsual_DifficultParamNames_recorder routes recorded function calls to the
// moqUsual moq
type moqUsual_DifficultParamNames_recorder struct {
	recorder *impl.Recorder[
		*moqUsual_DifficultParamNames_adaptor,
		moqUsual_DifficultParamNames_params,
		moqUsual_DifficultParamNames_paramsKey,
		moqUsual_DifficultParamNames_results,
	]
}

// moqUsual_DifficultParamNames_anyParams isolates the any params functions of
// the Usual type
type moqUsual_DifficultParamNames_anyParams struct {
	recorder *moqUsual_DifficultParamNames_recorder
}

// moqUsual_DifficultResultNames_adaptor adapts moqUsual as needed by the
// runtime
type moqUsual_DifficultResultNames_adaptor struct {
	moq *moqUsual
}

// moqUsual_DifficultResultNames_params holds the params of the Usual type
type moqUsual_DifficultResultNames_params struct{}

// moqUsual_DifficultResultNames_paramsKey holds the map key params of the
// Usual type
type moqUsual_DifficultResultNames_paramsKey struct {
	params struct{}
	hashes struct{}
}

// moqUsual_DifficultResultNames_results holds the results of the Usual type
type moqUsual_DifficultResultNames_results struct {
	result1, result2          string
	result3                   error
	param, result5, result6   int
	result7, result8, result9 float32
}

// moqUsual_DifficultResultNames_paramIndexing holds the parameter indexing
// runtime configuration for the Usual type
type moqUsual_DifficultResultNames_paramIndexing struct{}

// moqUsual_DifficultResultNames_doFn defines the type of function needed when
// calling andDo for the Usual type
type moqUsual_DifficultResultNames_doFn func()

// moqUsual_DifficultResultNames_doReturnFn defines the type of function needed
// when calling doReturnResults for the Usual type
type moqUsual_DifficultResultNames_doReturnFn func() (m, r string, sequence error, param, params, i int, result, results, _ float32)

// moqUsual_DifficultResultNames_recorder routes recorded function calls to the
// moqUsual moq
type moqUsual_DifficultResultNames_recorder struct {
	recorder *impl.Recorder[
		*moqUsual_DifficultResultNames_adaptor,
		moqUsual_DifficultResultNames_params,
		moqUsual_DifficultResultNames_paramsKey,
		moqUsual_DifficultResultNames_results,
	]
}

// moqUsual_DifficultResultNames_anyParams isolates the any params functions of
// the Usual type
type moqUsual_DifficultResultNames_anyParams struct {
	recorder *moqUsual_DifficultResultNames_recorder
}

// moqUsual_PassByArray_adaptor adapts moqUsual as needed by the runtime
type moqUsual_PassByArray_adaptor struct {
	moq *moqUsual
}

// moqUsual_PassByArray_params holds the params of the Usual type
type moqUsual_PassByArray_params struct{ p [3]testmoqs.Params }

// moqUsual_PassByArray_paramsKey holds the map key params of the Usual type
type moqUsual_PassByArray_paramsKey struct {
	params struct{ p [3]testmoqs.Params }
	hashes struct{ p hash.Hash }
}

// moqUsual_PassByArray_results holds the results of the Usual type
type moqUsual_PassByArray_results struct {
	result1 [3]testmoqs.Results
}

// moqUsual_PassByArray_paramIndexing holds the parameter indexing runtime
// configuration for the Usual type
type moqUsual_PassByArray_paramIndexing struct {
	p moq.ParamIndexing
}

// moqUsual_PassByArray_doFn defines the type of function needed when calling
// andDo for the Usual type
type moqUsual_PassByArray_doFn func(p [3]testmoqs.Params)

// moqUsual_PassByArray_doReturnFn defines the type of function needed when
// calling doReturnResults for the Usual type
type moqUsual_PassByArray_doReturnFn func(p [3]testmoqs.Params) [3]testmoqs.Results

// moqUsual_PassByArray_recorder routes recorded function calls to the moqUsual
// moq
type moqUsual_PassByArray_recorder struct {
	recorder *impl.Recorder[
		*moqUsual_PassByArray_adaptor,
		moqUsual_PassByArray_params,
		moqUsual_PassByArray_paramsKey,
		moqUsual_PassByArray_results,
	]
}

// moqUsual_PassByArray_anyParams isolates the any params functions of the
// Usual type
type moqUsual_PassByArray_anyParams struct {
	recorder *moqUsual_PassByArray_recorder
}

// moqUsual_PassByChan_adaptor adapts moqUsual as needed by the runtime
type moqUsual_PassByChan_adaptor struct {
	moq *moqUsual
}

// moqUsual_PassByChan_params holds the params of the Usual type
type moqUsual_PassByChan_params struct{ p chan testmoqs.Params }

// moqUsual_PassByChan_paramsKey holds the map key params of the Usual type
type moqUsual_PassByChan_paramsKey struct {
	params struct{ p chan testmoqs.Params }
	hashes struct{ p hash.Hash }
}

// moqUsual_PassByChan_results holds the results of the Usual type
type moqUsual_PassByChan_results struct {
	result1 chan testmoqs.Results
}

// moqUsual_PassByChan_paramIndexing holds the parameter indexing runtime
// configuration for the Usual type
type moqUsual_PassByChan_paramIndexing struct {
	p moq.ParamIndexing
}

// moqUsual_PassByChan_doFn defines the type of function needed when calling
// andDo for the Usual type
type moqUsual_PassByChan_doFn func(p chan testmoqs.Params)

// moqUsual_PassByChan_doReturnFn defines the type of function needed when
// calling doReturnResults for the Usual type
type moqUsual_PassByChan_doReturnFn func(p chan testmoqs.Params) chan testmoqs.Results

// moqUsual_PassByChan_recorder routes recorded function calls to the moqUsual
// moq
type moqUsual_PassByChan_recorder struct {
	recorder *impl.Recorder[
		*moqUsual_PassByChan_adaptor,
		moqUsual_PassByChan_params,
		moqUsual_PassByChan_paramsKey,
		moqUsual_PassByChan_results,
	]
}

// moqUsual_PassByChan_anyParams isolates the any params functions of the Usual
// type
type moqUsual_PassByChan_anyParams struct {
	recorder *moqUsual_PassByChan_recorder
}

// moqUsual_PassByEllipsis_adaptor adapts moqUsual as needed by the runtime
type moqUsual_PassByEllipsis_adaptor struct {
	moq *moqUsual
}

// moqUsual_PassByEllipsis_params holds the params of the Usual type
type moqUsual_PassByEllipsis_params struct{ p []testmoqs.Params }

// moqUsual_PassByEllipsis_paramsKey holds the map key params of the Usual type
type moqUsual_PassByEllipsis_paramsKey struct {
	params struct{}
	hashes struct{ p hash.Hash }
}

// moqUsual_PassByEllipsis_results holds the results of the Usual type
type moqUsual_PassByEllipsis_results struct {
	result1 string
	result2 error
}

// moqUsual_PassByEllipsis_paramIndexing holds the parameter indexing runtime
// configuration for the Usual type
type moqUsual_PassByEllipsis_paramIndexing struct {
	p moq.ParamIndexing
}

// moqUsual_PassByEllipsis_doFn defines the type of function needed when
// calling andDo for the Usual type
type moqUsual_PassByEllipsis_doFn func(p ...testmoqs.Params)

// moqUsual_PassByEllipsis_doReturnFn defines the type of function needed when
// calling doReturnResults for the Usual type
type moqUsual_PassByEllipsis_doReturnFn func(p ...testmoqs.Params) (string, error)

// moqUsual_PassByEllipsis_recorder routes recorded function calls to the
// moqUsual moq
type moqUsual_PassByEllipsis_recorder struct {
	recorder *impl.Recorder[
		*moqUsual_PassByEllipsis_adaptor,
		moqUsual_PassByEllipsis_params,
		moqUsual_PassByEllipsis_paramsKey,
		moqUsual_PassByEllipsis_results,
	]
}

// moqUsual_PassByEllipsis_anyParams isolates the any params functions of the
// Usual type
type moqUsual_PassByEllipsis_anyParams struct {
	recorder *moqUsual_PassByEllipsis_recorder
}

// moqUsual_PassByMap_adaptor adapts moqUsual as needed by the runtime
type moqUsual_PassByMap_adaptor struct {
	moq *moqUsual
}

// moqUsual_PassByMap_params holds the params of the Usual type
type moqUsual_PassByMap_params struct{ p map[string]testmoqs.Params }

// moqUsual_PassByMap_paramsKey holds the map key params of the Usual type
type moqUsual_PassByMap_paramsKey struct {
	params struct{}
	hashes struct{ p hash.Hash }
}

// moqUsual_PassByMap_results holds the results of the Usual type
type moqUsual_PassByMap_results struct {
	result1 map[string]testmoqs.Results
}

// moqUsual_PassByMap_paramIndexing holds the parameter indexing runtime
// configuration for the Usual type
type moqUsual_PassByMap_paramIndexing struct {
	p moq.ParamIndexing
}

// moqUsual_PassByMap_doFn defines the type of function needed when calling
// andDo for the Usual type
type moqUsual_PassByMap_doFn func(p map[string]testmoqs.Params)

// moqUsual_PassByMap_doReturnFn defines the type of function needed when
// calling doReturnResults for the Usual type
type moqUsual_PassByMap_doReturnFn func(p map[string]testmoqs.Params) map[string]testmoqs.Results

// moqUsual_PassByMap_recorder routes recorded function calls to the moqUsual
// moq
type moqUsual_PassByMap_recorder struct {
	recorder *impl.Recorder[
		*moqUsual_PassByMap_adaptor,
		moqUsual_PassByMap_params,
		moqUsual_PassByMap_paramsKey,
		moqUsual_PassByMap_results,
	]
}

// moqUsual_PassByMap_anyParams isolates the any params functions of the Usual
// type
type moqUsual_PassByMap_anyParams struct {
	recorder *moqUsual_PassByMap_recorder
}

// moqUsual_PassByReference_adaptor adapts moqUsual as needed by the runtime
type moqUsual_PassByReference_adaptor struct {
	moq *moqUsual
}

// moqUsual_PassByReference_params holds the params of the Usual type
type moqUsual_PassByReference_params struct{ p *testmoqs.Params }

// moqUsual_PassByReference_paramsKey holds the map key params of the Usual
// type
type moqUsual_PassByReference_paramsKey struct {
	params struct{ p *testmoqs.Params }
	hashes struct{ p hash.Hash }
}

// moqUsual_PassByReference_results holds the results of the Usual type
type moqUsual_PassByReference_results struct {
	result1 *testmoqs.Results
}

// moqUsual_PassByReference_paramIndexing holds the parameter indexing runtime
// configuration for the Usual type
type moqUsual_PassByReference_paramIndexing struct {
	p moq.ParamIndexing
}

// moqUsual_PassByReference_doFn defines the type of function needed when
// calling andDo for the Usual type
type moqUsual_PassByReference_doFn func(p *testmoqs.Params)

// moqUsual_PassByReference_doReturnFn defines the type of function needed when
// calling doReturnResults for the Usual type
type moqUsual_PassByReference_doReturnFn func(p *testmoqs.Params) *testmoqs.Results

// moqUsual_PassByReference_recorder routes recorded function calls to the
// moqUsual moq
type moqUsual_PassByReference_recorder struct {
	recorder *impl.Recorder[
		*moqUsual_PassByReference_adaptor,
		moqUsual_PassByReference_params,
		moqUsual_PassByReference_paramsKey,
		moqUsual_PassByReference_results,
	]
}

// moqUsual_PassByReference_anyParams isolates the any params functions of the
// Usual type
type moqUsual_PassByReference_anyParams struct {
	recorder *moqUsual_PassByReference_recorder
}

// moqUsual_PassBySlice_adaptor adapts moqUsual as needed by the runtime
type moqUsual_PassBySlice_adaptor struct {
	moq *moqUsual
}

// moqUsual_PassBySlice_params holds the params of the Usual type
type moqUsual_PassBySlice_params struct{ p []testmoqs.Params }

// moqUsual_PassBySlice_paramsKey holds the map key params of the Usual type
type moqUsual_PassBySlice_paramsKey struct {
	params struct{}
	hashes struct{ p hash.Hash }
}

// moqUsual_PassBySlice_results holds the results of the Usual type
type moqUsual_PassBySlice_results struct {
	result1 []testmoqs.Results
}

// moqUsual_PassBySlice_paramIndexing holds the parameter indexing runtime
// configuration for the Usual type
type moqUsual_PassBySlice_paramIndexing struct {
	p moq.ParamIndexing
}

// moqUsual_PassBySlice_doFn defines the type of function needed when calling
// andDo for the Usual type
type moqUsual_PassBySlice_doFn func(p []testmoqs.Params)

// moqUsual_PassBySlice_doReturnFn defines the type of function needed when
// calling doReturnResults for the Usual type
type moqUsual_PassBySlice_doReturnFn func(p []testmoqs.Params) []testmoqs.Results

// moqUsual_PassBySlice_recorder routes recorded function calls to the moqUsual
// moq
type moqUsual_PassBySlice_recorder struct {
	recorder *impl.Recorder[
		*moqUsual_PassBySlice_adaptor,
		moqUsual_PassBySlice_params,
		moqUsual_PassBySlice_paramsKey,
		moqUsual_PassBySlice_results,
	]
}

// moqUsual_PassBySlice_anyParams isolates the any params functions of the
// Usual type
type moqUsual_PassBySlice_anyParams struct {
	recorder *moqUsual_PassBySlice_recorder
}

// moqUsual_PassByValue_adaptor adapts moqUsual as needed by the runtime
type moqUsual_PassByValue_adaptor struct {
	moq *moqUsual
}

// moqUsual_PassByValue_params holds the params of the Usual type
type moqUsual_PassByValue_params struct{ p testmoqs.Params }

// moqUsual_PassByValue_paramsKey holds the map key params of the Usual type
type moqUsual_PassByValue_paramsKey struct {
	params struct{ p testmoqs.Params }
	hashes struct{ p hash.Hash }
}

// moqUsual_PassByValue_results holds the results of the Usual type
type moqUsual_PassByValue_results struct {
	result1 testmoqs.Results
}

// moqUsual_PassByValue_paramIndexing holds the parameter indexing runtime
// configuration for the Usual type
type moqUsual_PassByValue_paramIndexing struct {
	p moq.ParamIndexing
}

// moqUsual_PassByValue_doFn defines the type of function needed when calling
// andDo for the Usual type
type moqUsual_PassByValue_doFn func(p testmoqs.Params)

// moqUsual_PassByValue_doReturnFn defines the type of function needed when
// calling doReturnResults for the Usual type
type moqUsual_PassByValue_doReturnFn func(p testmoqs.Params) testmoqs.Results

// moqUsual_PassByValue_recorder routes recorded function calls to the moqUsual
// moq
type moqUsual_PassByValue_recorder struct {
	recorder *impl.Recorder[
		*moqUsual_PassByValue_adaptor,
		moqUsual_PassByValue_params,
		moqUsual_PassByValue_paramsKey,
		moqUsual_PassByValue_results,
	]
}

// moqUsual_PassByValue_anyParams isolates the any params functions of the
// Usual type
type moqUsual_PassByValue_anyParams struct {
	recorder *moqUsual_PassByValue_recorder
}

// moqUsual_InterfaceParam_adaptor adapts moqUsual as needed by the runtime
type moqUsual_InterfaceParam_adaptor struct {
	moq *moqUsual
}

// moqUsual_InterfaceParam_params holds the params of the Usual type
type moqUsual_InterfaceParam_params struct{ w io.Writer }

// moqUsual_InterfaceParam_paramsKey holds the map key params of the Usual type
type moqUsual_InterfaceParam_paramsKey struct {
	params struct{ w io.Writer }
	hashes struct{ w hash.Hash }
}

// moqUsual_InterfaceParam_results holds the results of the Usual type
type moqUsual_InterfaceParam_results struct {
	sResult string
	err     error
}

// moqUsual_InterfaceParam_paramIndexing holds the parameter indexing runtime
// configuration for the Usual type
type moqUsual_InterfaceParam_paramIndexing struct {
	w moq.ParamIndexing
}

// moqUsual_InterfaceParam_doFn defines the type of function needed when
// calling andDo for the Usual type
type moqUsual_InterfaceParam_doFn func(w io.Writer)

// moqUsual_InterfaceParam_doReturnFn defines the type of function needed when
// calling doReturnResults for the Usual type
type moqUsual_InterfaceParam_doReturnFn func(w io.Writer) (sResult string, err error)

// moqUsual_InterfaceParam_recorder routes recorded function calls to the
// moqUsual moq
type moqUsual_InterfaceParam_recorder struct {
	recorder *impl.Recorder[
		*moqUsual_InterfaceParam_adaptor,
		moqUsual_InterfaceParam_params,
		moqUsual_InterfaceParam_paramsKey,
		moqUsual_InterfaceParam_results,
	]
}

// moqUsual_InterfaceParam_anyParams isolates the any params functions of the
// Usual type
type moqUsual_InterfaceParam_anyParams struct {
	recorder *moqUsual_InterfaceParam_recorder
}

// moqUsual_InterfaceResult_adaptor adapts moqUsual as needed by the runtime
type moqUsual_InterfaceResult_adaptor struct {
	moq *moqUsual
}

// moqUsual_InterfaceResult_params holds the params of the Usual type
type moqUsual_InterfaceResult_params struct {
	sParam string
	bParam bool
}

// moqUsual_InterfaceResult_paramsKey holds the map key params of the Usual
// type
type moqUsual_InterfaceResult_paramsKey struct {
	params struct {
		sParam string
		bParam bool
	}
	hashes struct {
		sParam hash.Hash
		bParam hash.Hash
	}
}

// moqUsual_InterfaceResult_results holds the results of the Usual type
type moqUsual_InterfaceResult_results struct{ result1 io.Reader }

// moqUsual_InterfaceResult_paramIndexing holds the parameter indexing runtime
// configuration for the Usual type
type moqUsual_InterfaceResult_paramIndexing struct {
	sParam moq.ParamIndexing
	bParam moq.ParamIndexing
}

// moqUsual_InterfaceResult_doFn defines the type of function needed when
// calling andDo for the Usual type
type moqUsual_InterfaceResult_doFn func(sParam string, bParam bool)

// moqUsual_InterfaceResult_doReturnFn defines the type of function needed when
// calling doReturnResults for the Usual type
type moqUsual_InterfaceResult_doReturnFn func(sParam string, bParam bool) (r io.Reader)

// moqUsual_InterfaceResult_recorder routes recorded function calls to the
// moqUsual moq
type moqUsual_InterfaceResult_recorder struct {
	recorder *impl.Recorder[
		*moqUsual_InterfaceResult_adaptor,
		moqUsual_InterfaceResult_params,
		moqUsual_InterfaceResult_paramsKey,
		moqUsual_InterfaceResult_results,
	]
}

// moqUsual_InterfaceResult_anyParams isolates the any params functions of the
// Usual type
type moqUsual_InterfaceResult_anyParams struct {
	recorder *moqUsual_InterfaceResult_recorder
}

// moqUsual_FnParam_adaptor adapts moqUsual as needed by the runtime
type moqUsual_FnParam_adaptor struct {
	moq *moqUsual
}

// moqUsual_FnParam_params holds the params of the Usual type
type moqUsual_FnParam_params struct{ fn func() }

// moqUsual_FnParam_paramsKey holds the map key params of the Usual type
type moqUsual_FnParam_paramsKey struct {
	params struct{}
	hashes struct{ fn hash.Hash }
}

// moqUsual_FnParam_results holds the results of the Usual type
type moqUsual_FnParam_results struct{}

// moqUsual_FnParam_paramIndexing holds the parameter indexing runtime
// configuration for the Usual type
type moqUsual_FnParam_paramIndexing struct {
	fn moq.ParamIndexing
}

// moqUsual_FnParam_doFn defines the type of function needed when calling andDo
// for the Usual type
type moqUsual_FnParam_doFn func(fn func())

// moqUsual_FnParam_doReturnFn defines the type of function needed when calling
// doReturnResults for the Usual type
type moqUsual_FnParam_doReturnFn func(fn func())

// moqUsual_FnParam_recorder routes recorded function calls to the moqUsual moq
type moqUsual_FnParam_recorder struct {
	recorder *impl.Recorder[
		*moqUsual_FnParam_adaptor,
		moqUsual_FnParam_params,
		moqUsual_FnParam_paramsKey,
		moqUsual_FnParam_results,
	]
}

// moqUsual_FnParam_anyParams isolates the any params functions of the Usual
// type
type moqUsual_FnParam_anyParams struct {
	recorder *moqUsual_FnParam_recorder
}

// moqUsual_Other_adaptor adapts moqUsual as needed by the runtime
type moqUsual_Other_adaptor struct {
	moq *moqUsual
}

// moqUsual_Other_params holds the params of the Usual type
type moqUsual_Other_params struct{ param1 other.Params }

// moqUsual_Other_paramsKey holds the map key params of the Usual type
type moqUsual_Other_paramsKey struct {
	params struct{ param1 other.Params }
	hashes struct{ param1 hash.Hash }
}

// moqUsual_Other_results holds the results of the Usual type
type moqUsual_Other_results struct {
	result1 other.Results
}

// moqUsual_Other_paramIndexing holds the parameter indexing runtime
// configuration for the Usual type
type moqUsual_Other_paramIndexing struct {
	param1 moq.ParamIndexing
}

// moqUsual_Other_doFn defines the type of function needed when calling andDo
// for the Usual type
type moqUsual_Other_doFn func(other.Params)

// moqUsual_Other_doReturnFn defines the type of function needed when calling
// doReturnResults for the Usual type
type moqUsual_Other_doReturnFn func(other.Params) other.Results

// moqUsual_Other_recorder routes recorded function calls to the moqUsual moq
type moqUsual_Other_recorder struct {
	recorder *impl.Recorder[
		*moqUsual_Other_adaptor,
		moqUsual_Other_params,
		moqUsual_Other_paramsKey,
		moqUsual_Other_results,
	]
}

// moqUsual_Other_anyParams isolates the any params functions of the Usual type
type moqUsual_Other_anyParams struct {
	recorder *moqUsual_Other_recorder
}

// newMoqUsual creates a new moq of the Usual type
func newMoqUsual(scene *moq.Scene, config *moq.Config) *moqUsual {
	adaptor1 := &moqUsual_Usual_adaptor{}
	adaptor2 := &moqUsual_NoNames_adaptor{}
	adaptor3 := &moqUsual_NoResults_adaptor{}
	adaptor4 := &moqUsual_NoParams_adaptor{}
	adaptor5 := &moqUsual_Nothing_adaptor{}
	adaptor6 := &moqUsual_Variadic_adaptor{}
	adaptor7 := &moqUsual_RepeatedIds_adaptor{}
	adaptor8 := &moqUsual_Times_adaptor{}
	adaptor9 := &moqUsual_DifficultParamNames_adaptor{}
	adaptor10 := &moqUsual_DifficultResultNames_adaptor{}
	adaptor11 := &moqUsual_PassByArray_adaptor{}
	adaptor12 := &moqUsual_PassByChan_adaptor{}
	adaptor13 := &moqUsual_PassByEllipsis_adaptor{}
	adaptor14 := &moqUsual_PassByMap_adaptor{}
	adaptor15 := &moqUsual_PassByReference_adaptor{}
	adaptor16 := &moqUsual_PassBySlice_adaptor{}
	adaptor17 := &moqUsual_PassByValue_adaptor{}
	adaptor18 := &moqUsual_InterfaceParam_adaptor{}
	adaptor19 := &moqUsual_InterfaceResult_adaptor{}
	adaptor20 := &moqUsual_FnParam_adaptor{}
	adaptor21 := &moqUsual_Other_adaptor{}
	m := &moqUsual{
		moq: &moqUsual_mock{},

		moq_Usual: impl.NewMoq[
			*moqUsual_Usual_adaptor,
			moqUsual_Usual_params,
			moqUsual_Usual_paramsKey,
			moqUsual_Usual_results,
		](scene, adaptor1, config),
		moq_NoNames: impl.NewMoq[
			*moqUsual_NoNames_adaptor,
			moqUsual_NoNames_params,
			moqUsual_NoNames_paramsKey,
			moqUsual_NoNames_results,
		](scene, adaptor2, config),
		moq_NoResults: impl.NewMoq[
			*moqUsual_NoResults_adaptor,
			moqUsual_NoResults_params,
			moqUsual_NoResults_paramsKey,
			moqUsual_NoResults_results,
		](scene, adaptor3, config),
		moq_NoParams: impl.NewMoq[
			*moqUsual_NoParams_adaptor,
			moqUsual_NoParams_params,
			moqUsual_NoParams_paramsKey,
			moqUsual_NoParams_results,
		](scene, adaptor4, config),
		moq_Nothing: impl.NewMoq[
			*moqUsual_Nothing_adaptor,
			moqUsual_Nothing_params,
			moqUsual_Nothing_paramsKey,
			moqUsual_Nothing_results,
		](scene, adaptor5, config),
		moq_Variadic: impl.NewMoq[
			*moqUsual_Variadic_adaptor,
			moqUsual_Variadic_params,
			moqUsual_Variadic_paramsKey,
			moqUsual_Variadic_results,
		](scene, adaptor6, config),
		moq_RepeatedIds: impl.NewMoq[
			*moqUsual_RepeatedIds_adaptor,
			moqUsual_RepeatedIds_params,
			moqUsual_RepeatedIds_paramsKey,
			moqUsual_RepeatedIds_results,
		](scene, adaptor7, config),
		moq_Times: impl.NewMoq[
			*moqUsual_Times_adaptor,
			moqUsual_Times_params,
			moqUsual_Times_paramsKey,
			moqUsual_Times_results,
		](scene, adaptor8, config),
		moq_DifficultParamNames: impl.NewMoq[
			*moqUsual_DifficultParamNames_adaptor,
			moqUsual_DifficultParamNames_params,
			moqUsual_DifficultParamNames_paramsKey,
			moqUsual_DifficultParamNames_results,
		](scene, adaptor9, config),
		moq_DifficultResultNames: impl.NewMoq[
			*moqUsual_DifficultResultNames_adaptor,
			moqUsual_DifficultResultNames_params,
			moqUsual_DifficultResultNames_paramsKey,
			moqUsual_DifficultResultNames_results,
		](scene, adaptor10, config),
		moq_PassByArray: impl.NewMoq[
			*moqUsual_PassByArray_adaptor,
			moqUsual_PassByArray_params,
			moqUsual_PassByArray_paramsKey,
			moqUsual_PassByArray_results,
		](scene, adaptor11, config),
		moq_PassByChan: impl.NewMoq[
			*moqUsual_PassByChan_adaptor,
			moqUsual_PassByChan_params,
			moqUsual_PassByChan_paramsKey,
			moqUsual_PassByChan_results,
		](scene, adaptor12, config),
		moq_PassByEllipsis: impl.NewMoq[
			*moqUsual_PassByEllipsis_adaptor,
			moqUsual_PassByEllipsis_params,
			moqUsual_PassByEllipsis_paramsKey,
			moqUsual_PassByEllipsis_results,
		](scene, adaptor13, config),
		moq_PassByMap: impl.NewMoq[
			*moqUsual_PassByMap_adaptor,
			moqUsual_PassByMap_params,
			moqUsual_PassByMap_paramsKey,
			moqUsual_PassByMap_results,
		](scene, adaptor14, config),
		moq_PassByReference: impl.NewMoq[
			*moqUsual_PassByReference_adaptor,
			moqUsual_PassByReference_params,
			moqUsual_PassByReference_paramsKey,
			moqUsual_PassByReference_results,
		](scene, adaptor15, config),
		moq_PassBySlice: impl.NewMoq[
			*moqUsual_PassBySlice_adaptor,
			moqUsual_PassBySlice_params,
			moqUsual_PassBySlice_paramsKey,
			moqUsual_PassBySlice_results,
		](scene, adaptor16, config),
		moq_PassByValue: impl.NewMoq[
			*moqUsual_PassByValue_adaptor,
			moqUsual_PassByValue_params,
			moqUsual_PassByValue_paramsKey,
			moqUsual_PassByValue_results,
		](scene, adaptor17, config),
		moq_InterfaceParam: impl.NewMoq[
			*moqUsual_InterfaceParam_adaptor,
			moqUsual_InterfaceParam_params,
			moqUsual_InterfaceParam_paramsKey,
			moqUsual_InterfaceParam_results,
		](scene, adaptor18, config),
		moq_InterfaceResult: impl.NewMoq[
			*moqUsual_InterfaceResult_adaptor,
			moqUsual_InterfaceResult_params,
			moqUsual_InterfaceResult_paramsKey,
			moqUsual_InterfaceResult_results,
		](scene, adaptor19, config),
		moq_FnParam: impl.NewMoq[
			*moqUsual_FnParam_adaptor,
			moqUsual_FnParam_params,
			moqUsual_FnParam_paramsKey,
			moqUsual_FnParam_results,
		](scene, adaptor20, config),
		moq_Other: impl.NewMoq[
			*moqUsual_Other_adaptor,
			moqUsual_Other_params,
			moqUsual_Other_paramsKey,
			moqUsual_Other_results,
		](scene, adaptor21, config),

		runtime: moqUsual_runtime{parameterIndexing: struct {
			Usual                moqUsual_Usual_paramIndexing
			NoNames              moqUsual_NoNames_paramIndexing
			NoResults            moqUsual_NoResults_paramIndexing
			NoParams             moqUsual_NoParams_paramIndexing
			Nothing              moqUsual_Nothing_paramIndexing
			Variadic             moqUsual_Variadic_paramIndexing
			RepeatedIds          moqUsual_RepeatedIds_paramIndexing
			Times                moqUsual_Times_paramIndexing
			DifficultParamNames  moqUsual_DifficultParamNames_paramIndexing
			DifficultResultNames moqUsual_DifficultResultNames_paramIndexing
			PassByArray          moqUsual_PassByArray_paramIndexing
			PassByChan           moqUsual_PassByChan_paramIndexing
			PassByEllipsis       moqUsual_PassByEllipsis_paramIndexing
			PassByMap            moqUsual_PassByMap_paramIndexing
			PassByReference      moqUsual_PassByReference_paramIndexing
			PassBySlice          moqUsual_PassBySlice_paramIndexing
			PassByValue          moqUsual_PassByValue_paramIndexing
			InterfaceParam       moqUsual_InterfaceParam_paramIndexing
			InterfaceResult      moqUsual_InterfaceResult_paramIndexing
			FnParam              moqUsual_FnParam_paramIndexing
			Other                moqUsual_Other_paramIndexing
		}{
			Usual: moqUsual_Usual_paramIndexing{
				sParam: moq.ParamIndexByValue,
				bParam: moq.ParamIndexByValue,
			},
			NoNames: moqUsual_NoNames_paramIndexing{
				param1: moq.ParamIndexByValue,
				param2: moq.ParamIndexByValue,
			},
			NoResults: moqUsual_NoResults_paramIndexing{
				sParam: moq.ParamIndexByValue,
				bParam: moq.ParamIndexByValue,
			},
			NoParams: moqUsual_NoParams_paramIndexing{},
			Nothing:  moqUsual_Nothing_paramIndexing{},
			Variadic: moqUsual_Variadic_paramIndexing{
				other: moq.ParamIndexByValue,
				args:  moq.ParamIndexByHash,
			},
			RepeatedIds: moqUsual_RepeatedIds_paramIndexing{
				sParam1: moq.ParamIndexByValue,
				sParam2: moq.ParamIndexByValue,
				bParam:  moq.ParamIndexByValue,
			},
			Times: moqUsual_Times_paramIndexing{
				sParam: moq.ParamIndexByValue,
				times:  moq.ParamIndexByValue,
			},
			DifficultParamNames: moqUsual_DifficultParamNames_paramIndexing{
				param1: moq.ParamIndexByValue,
				param2: moq.ParamIndexByValue,
				param3: moq.ParamIndexByValue,
				param:  moq.ParamIndexByValue,
				param5: moq.ParamIndexByValue,
				param6: moq.ParamIndexByValue,
				param7: moq.ParamIndexByValue,
				param8: moq.ParamIndexByValue,
				param9: moq.ParamIndexByValue,
			},
			DifficultResultNames: moqUsual_DifficultResultNames_paramIndexing{},
			PassByArray: moqUsual_PassByArray_paramIndexing{
				p: moq.ParamIndexByValue,
			},
			PassByChan: moqUsual_PassByChan_paramIndexing{
				p: moq.ParamIndexByValue,
			},
			PassByEllipsis: moqUsual_PassByEllipsis_paramIndexing{
				p: moq.ParamIndexByHash,
			},
			PassByMap: moqUsual_PassByMap_paramIndexing{
				p: moq.ParamIndexByHash,
			},
			PassByReference: moqUsual_PassByReference_paramIndexing{
				p: moq.ParamIndexByHash,
			},
			PassBySlice: moqUsual_PassBySlice_paramIndexing{
				p: moq.ParamIndexByHash,
			},
			PassByValue: moqUsual_PassByValue_paramIndexing{
				p: moq.ParamIndexByValue,
			},
			InterfaceParam: moqUsual_InterfaceParam_paramIndexing{
				w: moq.ParamIndexByHash,
			},
			InterfaceResult: moqUsual_InterfaceResult_paramIndexing{
				sParam: moq.ParamIndexByValue,
				bParam: moq.ParamIndexByValue,
			},
			FnParam: moqUsual_FnParam_paramIndexing{
				fn: moq.ParamIndexByHash,
			},
			Other: moqUsual_Other_paramIndexing{
				param1: moq.ParamIndexByValue,
			},
		}},
	}
	m.moq.moq = m

	adaptor1.moq = m
	adaptor2.moq = m
	adaptor3.moq = m
	adaptor4.moq = m
	adaptor5.moq = m
	adaptor6.moq = m
	adaptor7.moq = m
	adaptor8.moq = m
	adaptor9.moq = m
	adaptor10.moq = m
	adaptor11.moq = m
	adaptor12.moq = m
	adaptor13.moq = m
	adaptor14.moq = m
	adaptor15.moq = m
	adaptor16.moq = m
	adaptor17.moq = m
	adaptor18.moq = m
	adaptor19.moq = m
	adaptor20.moq = m
	adaptor21.moq = m

	scene.AddMoq(m)
	return m
}

// mock returns the mock implementation of the Usual type
func (m *moqUsual) mock() *moqUsual_mock { return m.moq }

func (m *moqUsual_mock) Usual(sParam string, bParam bool) (string, error) {
	m.moq.moq_Usual.Scene.T.Helper()
	params := moqUsual_Usual_params{
		sParam: sParam,
		bParam: bParam,
	}

	var result1 string
	var result2 error
	if result := m.moq.moq_Usual.Function(params); result != nil {
		result1 = result.sResult
		result2 = result.err
	}
	return result1, result2
}

func (m *moqUsual_mock) NoNames(param1 string, param2 bool) (string, error) {
	m.moq.moq_NoNames.Scene.T.Helper()
	params := moqUsual_NoNames_params{
		param1: param1,
		param2: param2,
	}

	var result1 string
	var result2 error
	if result := m.moq.moq_NoNames.Function(params); result != nil {
		result1 = result.result1
		result2 = result.result2
	}
	return result1, result2
}

func (m *moqUsual_mock) NoResults(sParam string, bParam bool) {
	m.moq.moq_NoResults.Scene.T.Helper()
	params := moqUsual_NoResults_params{
		sParam: sParam,
		bParam: bParam,
	}

	m.moq.moq_NoResults.Function(params)
}

func (m *moqUsual_mock) NoParams() (string, error) {
	m.moq.moq_NoParams.Scene.T.Helper()
	params := moqUsual_NoParams_params{}

	var result1 string
	var result2 error
	if result := m.moq.moq_NoParams.Function(params); result != nil {
		result1 = result.sResult
		result2 = result.err
	}
	return result1, result2
}

func (m *moqUsual_mock) Nothing() {
	m.moq.moq_Nothing.Scene.T.Helper()
	params := moqUsual_Nothing_params{}

	m.moq.moq_Nothing.Function(params)
}

func (m *moqUsual_mock) Variadic(other bool, args ...string) (string, error) {
	m.moq.moq_Variadic.Scene.T.Helper()
	params := moqUsual_Variadic_params{
		other: other,
		args:  args,
	}

	var result1 string
	var result2 error
	if result := m.moq.moq_Variadic.Function(params); result != nil {
		result1 = result.sResult
		result2 = result.err
	}
	return result1, result2
}

func (m *moqUsual_mock) RepeatedIds(sParam1, sParam2 string, bParam bool) (string, string, error) {
	m.moq.moq_RepeatedIds.Scene.T.Helper()
	params := moqUsual_RepeatedIds_params{
		sParam1: sParam1,
		sParam2: sParam2,
		bParam:  bParam,
	}

	var result1 string
	var result2 string
	var result3 error
	if result := m.moq.moq_RepeatedIds.Function(params); result != nil {
		result1 = result.sResult1
		result2 = result.sResult2
		result3 = result.err
	}
	return result1, result2, result3
}

func (m *moqUsual_mock) Times(sParam string, times bool) (string, error) {
	m.moq.moq_Times.Scene.T.Helper()
	params := moqUsual_Times_params{
		sParam: sParam,
		times:  times,
	}

	var result1 string
	var result2 error
	if result := m.moq.moq_Times.Function(params); result != nil {
		result1 = result.sResult
		result2 = result.err
	}
	return result1, result2
}

func (m *moqUsual_mock) DifficultParamNames(param1, param2 bool, param3 string, param, param5, param6 int, param7, param8, param9 float32) {
	m.moq.moq_DifficultParamNames.Scene.T.Helper()
	params := moqUsual_DifficultParamNames_params{
		param1: param1,
		param2: param2,
		param3: param3,
		param:  param,
		param5: param5,
		param6: param6,
		param7: param7,
		param8: param8,
		param9: param9,
	}

	m.moq.moq_DifficultParamNames.Function(params)
}

func (m *moqUsual_mock) DifficultResultNames() (string, string, error, int, int, int, float32, float32, float32) {
	m.moq.moq_DifficultResultNames.Scene.T.Helper()
	params := moqUsual_DifficultResultNames_params{}

	var result1 string
	var result2 string
	var result3 error
	var result4 int
	var result5 int
	var result6 int
	var result7 float32
	var result8 float32
	var result9 float32
	if result := m.moq.moq_DifficultResultNames.Function(params); result != nil {
		result1 = result.result1
		result2 = result.result2
		result3 = result.result3
		result4 = result.param
		result5 = result.result5
		result6 = result.result6
		result7 = result.result7
		result8 = result.result8
		result9 = result.result9
	}
	return result1, result2, result3, result4, result5, result6, result7, result8, result9
}

func (m *moqUsual_mock) PassByArray(p [3]testmoqs.Params) [3]testmoqs.Results {
	m.moq.moq_PassByArray.Scene.T.Helper()
	params := moqUsual_PassByArray_params{
		p: p,
	}

	var result1 [3]testmoqs.Results
	if result := m.moq.moq_PassByArray.Function(params); result != nil {
		result1 = result.result1
	}
	return result1
}

func (m *moqUsual_mock) PassByChan(p chan testmoqs.Params) chan testmoqs.Results {
	m.moq.moq_PassByChan.Scene.T.Helper()
	params := moqUsual_PassByChan_params{
		p: p,
	}

	var result1 chan testmoqs.Results
	if result := m.moq.moq_PassByChan.Function(params); result != nil {
		result1 = result.result1
	}
	return result1
}

func (m *moqUsual_mock) PassByEllipsis(p ...testmoqs.Params) (string, error) {
	m.moq.moq_PassByEllipsis.Scene.T.Helper()
	params := moqUsual_PassByEllipsis_params{
		p: p,
	}

	var result1 string
	var result2 error
	if result := m.moq.moq_PassByEllipsis.Function(params); result != nil {
		result1 = result.result1
		result2 = result.result2
	}
	return result1, result2
}

func (m *moqUsual_mock) PassByMap(p map[string]testmoqs.Params) map[string]testmoqs.Results {
	m.moq.moq_PassByMap.Scene.T.Helper()
	params := moqUsual_PassByMap_params{
		p: p,
	}

	var result1 map[string]testmoqs.Results
	if result := m.moq.moq_PassByMap.Function(params); result != nil {
		result1 = result.result1
	}
	return result1
}

func (m *moqUsual_mock) PassByReference(p *testmoqs.Params) *testmoqs.Results {
	m.moq.moq_PassByReference.Scene.T.Helper()
	params := moqUsual_PassByReference_params{
		p: p,
	}

	var result1 *testmoqs.Results
	if result := m.moq.moq_PassByReference.Function(params); result != nil {
		result1 = result.result1
	}
	return result1
}

func (m *moqUsual_mock) PassBySlice(p []testmoqs.Params) []testmoqs.Results {
	m.moq.moq_PassBySlice.Scene.T.Helper()
	params := moqUsual_PassBySlice_params{
		p: p,
	}

	var result1 []testmoqs.Results
	if result := m.moq.moq_PassBySlice.Function(params); result != nil {
		result1 = result.result1
	}
	return result1
}

func (m *moqUsual_mock) PassByValue(p testmoqs.Params) testmoqs.Results {
	m.moq.moq_PassByValue.Scene.T.Helper()
	params := moqUsual_PassByValue_params{
		p: p,
	}

	var result1 testmoqs.Results
	if result := m.moq.moq_PassByValue.Function(params); result != nil {
		result1 = result.result1
	}
	return result1
}

func (m *moqUsual_mock) InterfaceParam(w io.Writer) (string, error) {
	m.moq.moq_InterfaceParam.Scene.T.Helper()
	params := moqUsual_InterfaceParam_params{
		w: w,
	}

	var result1 string
	var result2 error
	if result := m.moq.moq_InterfaceParam.Function(params); result != nil {
		result1 = result.sResult
		result2 = result.err
	}
	return result1, result2
}

func (m *moqUsual_mock) InterfaceResult(sParam string, bParam bool) io.Reader {
	m.moq.moq_InterfaceResult.Scene.T.Helper()
	params := moqUsual_InterfaceResult_params{
		sParam: sParam,
		bParam: bParam,
	}

	var result1 io.Reader
	if result := m.moq.moq_InterfaceResult.Function(params); result != nil {
		result1 = result.result1
	}
	return result1
}

func (m *moqUsual_mock) FnParam(fn func()) {
	m.moq.moq_FnParam.Scene.T.Helper()
	params := moqUsual_FnParam_params{
		fn: fn,
	}

	m.moq.moq_FnParam.Function(params)
}

func (m *moqUsual_mock) Other(param1 other.Params) other.Results {
	m.moq.moq_Other.Scene.T.Helper()
	params := moqUsual_Other_params{
		param1: param1,
	}

	var result1 other.Results
	if result := m.moq.moq_Other.Function(params); result != nil {
		result1 = result.result1
	}
	return result1
}

// onCall returns the recorder implementation of the Usual type
func (m *moqUsual) onCall() *moqUsual_recorder {
	return &moqUsual_recorder{
		moq: m,
	}
}

func (m *moqUsual_recorder) Usual(sParam string, bParam bool) *moqUsual_Usual_recorder {
	return &moqUsual_Usual_recorder{
		recorder: m.moq.moq_Usual.OnCall(moqUsual_Usual_params{
			sParam: sParam,
			bParam: bParam,
		}),
	}
}

func (r *moqUsual_Usual_recorder) any() *moqUsual_Usual_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqUsual_Usual_anyParams{recorder: r}
}

func (a *moqUsual_Usual_anyParams) sParam() *moqUsual_Usual_recorder {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (a *moqUsual_Usual_anyParams) bParam() *moqUsual_Usual_recorder {
	a.recorder.recorder.AnyParam(2)
	return a.recorder
}

func (r *moqUsual_Usual_recorder) seq() *moqUsual_Usual_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqUsual_Usual_recorder) noSeq() *moqUsual_Usual_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqUsual_Usual_recorder) returnResults(sResult string, err error) *moqUsual_Usual_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqUsual_Usual_results{
		sResult: sResult,
		err:     err,
	})
	return r
}

func (r *moqUsual_Usual_recorder) andDo(fn moqUsual_Usual_doFn) *moqUsual_Usual_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqUsual_Usual_params) {
		fn(params.sParam, params.bParam)
	}, false) {
		return nil
	}
	return r
}

func (r *moqUsual_Usual_recorder) doReturnResults(fn moqUsual_Usual_doReturnFn) *moqUsual_Usual_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqUsual_Usual_params) *moqUsual_Usual_results {
		sResult, err := fn(params.sParam, params.bParam)
		return &moqUsual_Usual_results{
			sResult: sResult,
			err:     err,
		}
	})
	return r
}

func (r *moqUsual_Usual_recorder) repeat(repeaters ...moq.Repeater) *moqUsual_Usual_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqUsual_Usual_adaptor) PrettyParams(params moqUsual_Usual_params) string {
	return fmt.Sprintf("Usual(%#v, %#v)", params.sParam, params.bParam)
}

func (a *moqUsual_Usual_adaptor) ParamsKey(params moqUsual_Usual_params, anyParams uint64) moqUsual_Usual_paramsKey {
	a.moq.moq_Usual.Scene.T.Helper()
	sParamUsed, sParamUsedHash := impl.ParamKey(
		params.sParam, 1, a.moq.runtime.parameterIndexing.Usual.sParam, anyParams)
	bParamUsed, bParamUsedHash := impl.ParamKey(
		params.bParam, 2, a.moq.runtime.parameterIndexing.Usual.bParam, anyParams)
	return moqUsual_Usual_paramsKey{
		params: struct {
			sParam string
			bParam bool
		}{
			sParam: sParamUsed,
			bParam: bParamUsed,
		},
		hashes: struct {
			sParam hash.Hash
			bParam hash.Hash
		}{
			sParam: sParamUsedHash,
			bParam: bParamUsedHash,
		},
	}
}

func (m *moqUsual_recorder) NoNames(param1 string, param2 bool) *moqUsual_NoNames_recorder {
	return &moqUsual_NoNames_recorder{
		recorder: m.moq.moq_NoNames.OnCall(moqUsual_NoNames_params{
			param1: param1,
			param2: param2,
		}),
	}
}

func (r *moqUsual_NoNames_recorder) any() *moqUsual_NoNames_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqUsual_NoNames_anyParams{recorder: r}
}

func (a *moqUsual_NoNames_anyParams) param1() *moqUsual_NoNames_recorder {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (a *moqUsual_NoNames_anyParams) param2() *moqUsual_NoNames_recorder {
	a.recorder.recorder.AnyParam(2)
	return a.recorder
}

func (r *moqUsual_NoNames_recorder) seq() *moqUsual_NoNames_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqUsual_NoNames_recorder) noSeq() *moqUsual_NoNames_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqUsual_NoNames_recorder) returnResults(result1 string, result2 error) *moqUsual_NoNames_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqUsual_NoNames_results{
		result1: result1,
		result2: result2,
	})
	return r
}

func (r *moqUsual_NoNames_recorder) andDo(fn moqUsual_NoNames_doFn) *moqUsual_NoNames_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqUsual_NoNames_params) {
		fn(params.param1, params.param2)
	}, false) {
		return nil
	}
	return r
}

func (r *moqUsual_NoNames_recorder) doReturnResults(fn moqUsual_NoNames_doReturnFn) *moqUsual_NoNames_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqUsual_NoNames_params) *moqUsual_NoNames_results {
		result1, result2 := fn(params.param1, params.param2)
		return &moqUsual_NoNames_results{
			result1: result1,
			result2: result2,
		}
	})
	return r
}

func (r *moqUsual_NoNames_recorder) repeat(repeaters ...moq.Repeater) *moqUsual_NoNames_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqUsual_NoNames_adaptor) PrettyParams(params moqUsual_NoNames_params) string {
	return fmt.Sprintf("NoNames(%#v, %#v)", params.param1, params.param2)
}

func (a *moqUsual_NoNames_adaptor) ParamsKey(params moqUsual_NoNames_params, anyParams uint64) moqUsual_NoNames_paramsKey {
	a.moq.moq_NoNames.Scene.T.Helper()
	param1Used, param1UsedHash := impl.ParamKey(
		params.param1, 1, a.moq.runtime.parameterIndexing.NoNames.param1, anyParams)
	param2Used, param2UsedHash := impl.ParamKey(
		params.param2, 2, a.moq.runtime.parameterIndexing.NoNames.param2, anyParams)
	return moqUsual_NoNames_paramsKey{
		params: struct {
			param1 string
			param2 bool
		}{
			param1: param1Used,
			param2: param2Used,
		},
		hashes: struct {
			param1 hash.Hash
			param2 hash.Hash
		}{
			param1: param1UsedHash,
			param2: param2UsedHash,
		},
	}
}

func (m *moqUsual_recorder) NoResults(sParam string, bParam bool) *moqUsual_NoResults_recorder {
	return &moqUsual_NoResults_recorder{
		recorder: m.moq.moq_NoResults.OnCall(moqUsual_NoResults_params{
			sParam: sParam,
			bParam: bParam,
		}),
	}
}

func (r *moqUsual_NoResults_recorder) any() *moqUsual_NoResults_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqUsual_NoResults_anyParams{recorder: r}
}

func (a *moqUsual_NoResults_anyParams) sParam() *moqUsual_NoResults_recorder {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (a *moqUsual_NoResults_anyParams) bParam() *moqUsual_NoResults_recorder {
	a.recorder.recorder.AnyParam(2)
	return a.recorder
}

func (r *moqUsual_NoResults_recorder) seq() *moqUsual_NoResults_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqUsual_NoResults_recorder) noSeq() *moqUsual_NoResults_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqUsual_NoResults_recorder) returnResults() *moqUsual_NoResults_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqUsual_NoResults_results{})
	return r
}

func (r *moqUsual_NoResults_recorder) andDo(fn moqUsual_NoResults_doFn) *moqUsual_NoResults_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqUsual_NoResults_params) {
		fn(params.sParam, params.bParam)
	}, false) {
		return nil
	}
	return r
}

func (r *moqUsual_NoResults_recorder) doReturnResults(fn moqUsual_NoResults_doReturnFn) *moqUsual_NoResults_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqUsual_NoResults_params) *moqUsual_NoResults_results {
		fn(params.sParam, params.bParam)
		return &moqUsual_NoResults_results{}
	})
	return r
}

func (r *moqUsual_NoResults_recorder) repeat(repeaters ...moq.Repeater) *moqUsual_NoResults_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqUsual_NoResults_adaptor) PrettyParams(params moqUsual_NoResults_params) string {
	return fmt.Sprintf("NoResults(%#v, %#v)", params.sParam, params.bParam)
}

func (a *moqUsual_NoResults_adaptor) ParamsKey(params moqUsual_NoResults_params, anyParams uint64) moqUsual_NoResults_paramsKey {
	a.moq.moq_NoResults.Scene.T.Helper()
	sParamUsed, sParamUsedHash := impl.ParamKey(
		params.sParam, 1, a.moq.runtime.parameterIndexing.NoResults.sParam, anyParams)
	bParamUsed, bParamUsedHash := impl.ParamKey(
		params.bParam, 2, a.moq.runtime.parameterIndexing.NoResults.bParam, anyParams)
	return moqUsual_NoResults_paramsKey{
		params: struct {
			sParam string
			bParam bool
		}{
			sParam: sParamUsed,
			bParam: bParamUsed,
		},
		hashes: struct {
			sParam hash.Hash
			bParam hash.Hash
		}{
			sParam: sParamUsedHash,
			bParam: bParamUsedHash,
		},
	}
}

func (m *moqUsual_recorder) NoParams() *moqUsual_NoParams_recorder {
	return &moqUsual_NoParams_recorder{
		recorder: m.moq.moq_NoParams.OnCall(moqUsual_NoParams_params{}),
	}
}

func (r *moqUsual_NoParams_recorder) any() *moqUsual_NoParams_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqUsual_NoParams_anyParams{recorder: r}
}

func (r *moqUsual_NoParams_recorder) seq() *moqUsual_NoParams_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqUsual_NoParams_recorder) noSeq() *moqUsual_NoParams_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqUsual_NoParams_recorder) returnResults(sResult string, err error) *moqUsual_NoParams_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqUsual_NoParams_results{
		sResult: sResult,
		err:     err,
	})
	return r
}

func (r *moqUsual_NoParams_recorder) andDo(fn moqUsual_NoParams_doFn) *moqUsual_NoParams_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqUsual_NoParams_params) {
		fn()
	}, false) {
		return nil
	}
	return r
}

func (r *moqUsual_NoParams_recorder) doReturnResults(fn moqUsual_NoParams_doReturnFn) *moqUsual_NoParams_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqUsual_NoParams_params) *moqUsual_NoParams_results {
		sResult, err := fn()
		return &moqUsual_NoParams_results{
			sResult: sResult,
			err:     err,
		}
	})
	return r
}

func (r *moqUsual_NoParams_recorder) repeat(repeaters ...moq.Repeater) *moqUsual_NoParams_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqUsual_NoParams_adaptor) PrettyParams(params moqUsual_NoParams_params) string {
	return fmt.Sprintf("NoParams()")
}

func (a *moqUsual_NoParams_adaptor) ParamsKey(params moqUsual_NoParams_params, anyParams uint64) moqUsual_NoParams_paramsKey {
	a.moq.moq_NoParams.Scene.T.Helper()
	return moqUsual_NoParams_paramsKey{
		params: struct{}{},
		hashes: struct{}{},
	}
}

func (m *moqUsual_recorder) Nothing() *moqUsual_Nothing_recorder {
	return &moqUsual_Nothing_recorder{
		recorder: m.moq.moq_Nothing.OnCall(moqUsual_Nothing_params{}),
	}
}

func (r *moqUsual_Nothing_recorder) any() *moqUsual_Nothing_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqUsual_Nothing_anyParams{recorder: r}
}

func (r *moqUsual_Nothing_recorder) seq() *moqUsual_Nothing_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqUsual_Nothing_recorder) noSeq() *moqUsual_Nothing_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqUsual_Nothing_recorder) returnResults() *moqUsual_Nothing_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqUsual_Nothing_results{})
	return r
}

func (r *moqUsual_Nothing_recorder) andDo(fn moqUsual_Nothing_doFn) *moqUsual_Nothing_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqUsual_Nothing_params) {
		fn()
	}, false) {
		return nil
	}
	return r
}

func (r *moqUsual_Nothing_recorder) doReturnResults(fn moqUsual_Nothing_doReturnFn) *moqUsual_Nothing_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqUsual_Nothing_params) *moqUsual_Nothing_results {
		fn()
		return &moqUsual_Nothing_results{}
	})
	return r
}

func (r *moqUsual_Nothing_recorder) repeat(repeaters ...moq.Repeater) *moqUsual_Nothing_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqUsual_Nothing_adaptor) PrettyParams(params moqUsual_Nothing_params) string {
	return fmt.Sprintf("Nothing()")
}

func (a *moqUsual_Nothing_adaptor) ParamsKey(params moqUsual_Nothing_params, anyParams uint64) moqUsual_Nothing_paramsKey {
	a.moq.moq_Nothing.Scene.T.Helper()
	return moqUsual_Nothing_paramsKey{
		params: struct{}{},
		hashes: struct{}{},
	}
}

func (m *moqUsual_recorder) Variadic(other bool, args ...string) *moqUsual_Variadic_recorder {
	return &moqUsual_Variadic_recorder{
		recorder: m.moq.moq_Variadic.OnCall(moqUsual_Variadic_params{
			other: other,
			args:  args,
		}),
	}
}

func (r *moqUsual_Variadic_recorder) any() *moqUsual_Variadic_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqUsual_Variadic_anyParams{recorder: r}
}

func (a *moqUsual_Variadic_anyParams) other() *moqUsual_Variadic_recorder {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (a *moqUsual_Variadic_anyParams) args() *moqUsual_Variadic_recorder {
	a.recorder.recorder.AnyParam(2)
	return a.recorder
}

func (r *moqUsual_Variadic_recorder) seq() *moqUsual_Variadic_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqUsual_Variadic_recorder) noSeq() *moqUsual_Variadic_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqUsual_Variadic_recorder) returnResults(sResult string, err error) *moqUsual_Variadic_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqUsual_Variadic_results{
		sResult: sResult,
		err:     err,
	})
	return r
}

func (r *moqUsual_Variadic_recorder) andDo(fn moqUsual_Variadic_doFn) *moqUsual_Variadic_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqUsual_Variadic_params) {
		fn(params.other, params.args...)
	}, false) {
		return nil
	}
	return r
}

func (r *moqUsual_Variadic_recorder) doReturnResults(fn moqUsual_Variadic_doReturnFn) *moqUsual_Variadic_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqUsual_Variadic_params) *moqUsual_Variadic_results {
		sResult, err := fn(params.other, params.args...)
		return &moqUsual_Variadic_results{
			sResult: sResult,
			err:     err,
		}
	})
	return r
}

func (r *moqUsual_Variadic_recorder) repeat(repeaters ...moq.Repeater) *moqUsual_Variadic_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqUsual_Variadic_adaptor) PrettyParams(params moqUsual_Variadic_params) string {
	return fmt.Sprintf("Variadic(%#v, %#v)", params.other, params.args)
}

func (a *moqUsual_Variadic_adaptor) ParamsKey(params moqUsual_Variadic_params, anyParams uint64) moqUsual_Variadic_paramsKey {
	a.moq.moq_Variadic.Scene.T.Helper()
	otherUsed, otherUsedHash := impl.ParamKey(
		params.other, 1, a.moq.runtime.parameterIndexing.Variadic.other, anyParams)
	argsUsedHash := impl.HashOnlyParamKey(a.moq.moq_Variadic.Scene.T,
		params.args, "args", 2, a.moq.runtime.parameterIndexing.Variadic.args, anyParams)
	return moqUsual_Variadic_paramsKey{
		params: struct{ other bool }{
			other: otherUsed,
		},
		hashes: struct {
			other hash.Hash
			args  hash.Hash
		}{
			other: otherUsedHash,
			args:  argsUsedHash,
		},
	}
}

func (m *moqUsual_recorder) RepeatedIds(sParam1, sParam2 string, bParam bool) *moqUsual_RepeatedIds_recorder {
	return &moqUsual_RepeatedIds_recorder{
		recorder: m.moq.moq_RepeatedIds.OnCall(moqUsual_RepeatedIds_params{
			sParam1: sParam1,
			sParam2: sParam2,
			bParam:  bParam,
		}),
	}
}

func (r *moqUsual_RepeatedIds_recorder) any() *moqUsual_RepeatedIds_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqUsual_RepeatedIds_anyParams{recorder: r}
}

func (a *moqUsual_RepeatedIds_anyParams) sParam1() *moqUsual_RepeatedIds_recorder {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (a *moqUsual_RepeatedIds_anyParams) sParam2() *moqUsual_RepeatedIds_recorder {
	a.recorder.recorder.AnyParam(2)
	return a.recorder
}

func (a *moqUsual_RepeatedIds_anyParams) bParam() *moqUsual_RepeatedIds_recorder {
	a.recorder.recorder.AnyParam(3)
	return a.recorder
}

func (r *moqUsual_RepeatedIds_recorder) seq() *moqUsual_RepeatedIds_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqUsual_RepeatedIds_recorder) noSeq() *moqUsual_RepeatedIds_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqUsual_RepeatedIds_recorder) returnResults(sResult1, sResult2 string, err error) *moqUsual_RepeatedIds_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqUsual_RepeatedIds_results{
		sResult1: sResult1,
		sResult2: sResult2,
		err:      err,
	})
	return r
}

func (r *moqUsual_RepeatedIds_recorder) andDo(fn moqUsual_RepeatedIds_doFn) *moqUsual_RepeatedIds_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqUsual_RepeatedIds_params) {
		fn(params.sParam1, params.sParam2, params.bParam)
	}, false) {
		return nil
	}
	return r
}

func (r *moqUsual_RepeatedIds_recorder) doReturnResults(fn moqUsual_RepeatedIds_doReturnFn) *moqUsual_RepeatedIds_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqUsual_RepeatedIds_params) *moqUsual_RepeatedIds_results {
		sResult1, sResult2, err := fn(params.sParam1, params.sParam2, params.bParam)
		return &moqUsual_RepeatedIds_results{
			sResult1: sResult1,
			sResult2: sResult2,
			err:      err,
		}
	})
	return r
}

func (r *moqUsual_RepeatedIds_recorder) repeat(repeaters ...moq.Repeater) *moqUsual_RepeatedIds_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqUsual_RepeatedIds_adaptor) PrettyParams(params moqUsual_RepeatedIds_params) string {
	return fmt.Sprintf("RepeatedIds(%#v, %#v, %#v)", params.sParam1, params.sParam2, params.bParam)
}

func (a *moqUsual_RepeatedIds_adaptor) ParamsKey(params moqUsual_RepeatedIds_params, anyParams uint64) moqUsual_RepeatedIds_paramsKey {
	a.moq.moq_RepeatedIds.Scene.T.Helper()
	sParam1Used, sParam1UsedHash := impl.ParamKey(
		params.sParam1, 1, a.moq.runtime.parameterIndexing.RepeatedIds.sParam1, anyParams)
	sParam2Used, sParam2UsedHash := impl.ParamKey(
		params.sParam2, 2, a.moq.runtime.parameterIndexing.RepeatedIds.sParam2, anyParams)
	bParamUsed, bParamUsedHash := impl.ParamKey(
		params.bParam, 3, a.moq.runtime.parameterIndexing.RepeatedIds.bParam, anyParams)
	return moqUsual_RepeatedIds_paramsKey{
		params: struct {
			sParam1, sParam2 string
			bParam           bool
		}{
			sParam1: sParam1Used,
			sParam2: sParam2Used,
			bParam:  bParamUsed,
		},
		hashes: struct {
			sParam1, sParam2 hash.Hash
			bParam           hash.Hash
		}{
			sParam1: sParam1UsedHash,
			sParam2: sParam2UsedHash,
			bParam:  bParamUsedHash,
		},
	}
}

func (m *moqUsual_recorder) Times(sParam string, times bool) *moqUsual_Times_recorder {
	return &moqUsual_Times_recorder{
		recorder: m.moq.moq_Times.OnCall(moqUsual_Times_params{
			sParam: sParam,
			times:  times,
		}),
	}
}

func (r *moqUsual_Times_recorder) any() *moqUsual_Times_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqUsual_Times_anyParams{recorder: r}
}

func (a *moqUsual_Times_anyParams) sParam() *moqUsual_Times_recorder {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (a *moqUsual_Times_anyParams) times() *moqUsual_Times_recorder {
	a.recorder.recorder.AnyParam(2)
	return a.recorder
}

func (r *moqUsual_Times_recorder) seq() *moqUsual_Times_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqUsual_Times_recorder) noSeq() *moqUsual_Times_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqUsual_Times_recorder) returnResults(sResult string, err error) *moqUsual_Times_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqUsual_Times_results{
		sResult: sResult,
		err:     err,
	})
	return r
}

func (r *moqUsual_Times_recorder) andDo(fn moqUsual_Times_doFn) *moqUsual_Times_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqUsual_Times_params) {
		fn(params.sParam, params.times)
	}, false) {
		return nil
	}
	return r
}

func (r *moqUsual_Times_recorder) doReturnResults(fn moqUsual_Times_doReturnFn) *moqUsual_Times_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqUsual_Times_params) *moqUsual_Times_results {
		sResult, err := fn(params.sParam, params.times)
		return &moqUsual_Times_results{
			sResult: sResult,
			err:     err,
		}
	})
	return r
}

func (r *moqUsual_Times_recorder) repeat(repeaters ...moq.Repeater) *moqUsual_Times_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqUsual_Times_adaptor) PrettyParams(params moqUsual_Times_params) string {
	return fmt.Sprintf("Times(%#v, %#v)", params.sParam, params.times)
}

func (a *moqUsual_Times_adaptor) ParamsKey(params moqUsual_Times_params, anyParams uint64) moqUsual_Times_paramsKey {
	a.moq.moq_Times.Scene.T.Helper()
	sParamUsed, sParamUsedHash := impl.ParamKey(
		params.sParam, 1, a.moq.runtime.parameterIndexing.Times.sParam, anyParams)
	timesUsed, timesUsedHash := impl.ParamKey(
		params.times, 2, a.moq.runtime.parameterIndexing.Times.times, anyParams)
	return moqUsual_Times_paramsKey{
		params: struct {
			sParam string
			times  bool
		}{
			sParam: sParamUsed,
			times:  timesUsed,
		},
		hashes: struct {
			sParam hash.Hash
			times  hash.Hash
		}{
			sParam: sParamUsedHash,
			times:  timesUsedHash,
		},
	}
}

func (m *moqUsual_recorder) DifficultParamNames(param1, param2 bool, param3 string, param, param5, param6 int, param7, param8, param9 float32) *moqUsual_DifficultParamNames_recorder {
	return &moqUsual_DifficultParamNames_recorder{
		recorder: m.moq.moq_DifficultParamNames.OnCall(moqUsual_DifficultParamNames_params{
			param1: param1,
			param2: param2,
			param3: param3,
			param:  param,
			param5: param5,
			param6: param6,
			param7: param7,
			param8: param8,
			param9: param9,
		}),
	}
}

func (r *moqUsual_DifficultParamNames_recorder) any() *moqUsual_DifficultParamNames_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqUsual_DifficultParamNames_anyParams{recorder: r}
}

func (a *moqUsual_DifficultParamNames_anyParams) param1() *moqUsual_DifficultParamNames_recorder {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (a *moqUsual_DifficultParamNames_anyParams) param2() *moqUsual_DifficultParamNames_recorder {
	a.recorder.recorder.AnyParam(2)
	return a.recorder
}

func (a *moqUsual_DifficultParamNames_anyParams) param3() *moqUsual_DifficultParamNames_recorder {
	a.recorder.recorder.AnyParam(3)
	return a.recorder
}

func (a *moqUsual_DifficultParamNames_anyParams) param() *moqUsual_DifficultParamNames_recorder {
	a.recorder.recorder.AnyParam(4)
	return a.recorder
}

func (a *moqUsual_DifficultParamNames_anyParams) param5() *moqUsual_DifficultParamNames_recorder {
	a.recorder.recorder.AnyParam(5)
	return a.recorder
}

func (a *moqUsual_DifficultParamNames_anyParams) param6() *moqUsual_DifficultParamNames_recorder {
	a.recorder.recorder.AnyParam(6)
	return a.recorder
}

func (a *moqUsual_DifficultParamNames_anyParams) param7() *moqUsual_DifficultParamNames_recorder {
	a.recorder.recorder.AnyParam(7)
	return a.recorder
}

func (a *moqUsual_DifficultParamNames_anyParams) param8() *moqUsual_DifficultParamNames_recorder {
	a.recorder.recorder.AnyParam(8)
	return a.recorder
}

func (a *moqUsual_DifficultParamNames_anyParams) param9() *moqUsual_DifficultParamNames_recorder {
	a.recorder.recorder.AnyParam(9)
	return a.recorder
}

func (r *moqUsual_DifficultParamNames_recorder) seq() *moqUsual_DifficultParamNames_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqUsual_DifficultParamNames_recorder) noSeq() *moqUsual_DifficultParamNames_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqUsual_DifficultParamNames_recorder) returnResults() *moqUsual_DifficultParamNames_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqUsual_DifficultParamNames_results{})
	return r
}

func (r *moqUsual_DifficultParamNames_recorder) andDo(fn moqUsual_DifficultParamNames_doFn) *moqUsual_DifficultParamNames_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqUsual_DifficultParamNames_params) {
		fn(params.param1, params.param2, params.param3, params.param, params.param5, params.param6, params.param7, params.param8, params.param9)
	}, false) {
		return nil
	}
	return r
}

func (r *moqUsual_DifficultParamNames_recorder) doReturnResults(fn moqUsual_DifficultParamNames_doReturnFn) *moqUsual_DifficultParamNames_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqUsual_DifficultParamNames_params) *moqUsual_DifficultParamNames_results {
		fn(params.param1, params.param2, params.param3, params.param, params.param5, params.param6, params.param7, params.param8, params.param9)
		return &moqUsual_DifficultParamNames_results{}
	})
	return r
}

func (r *moqUsual_DifficultParamNames_recorder) repeat(repeaters ...moq.Repeater) *moqUsual_DifficultParamNames_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqUsual_DifficultParamNames_adaptor) PrettyParams(params moqUsual_DifficultParamNames_params) string {
	return fmt.Sprintf("DifficultParamNames(%#v, %#v, %#v, %#v, %#v, %#v, %#v, %#v, %#v)", params.param1, params.param2, params.param3, params.param, params.param5, params.param6, params.param7, params.param8, params.param9)
}

func (a *moqUsual_DifficultParamNames_adaptor) ParamsKey(params moqUsual_DifficultParamNames_params, anyParams uint64) moqUsual_DifficultParamNames_paramsKey {
	a.moq.moq_DifficultParamNames.Scene.T.Helper()
	param1Used, param1UsedHash := impl.ParamKey(
		params.param1, 1, a.moq.runtime.parameterIndexing.DifficultParamNames.param1, anyParams)
	param2Used, param2UsedHash := impl.ParamKey(
		params.param2, 2, a.moq.runtime.parameterIndexing.DifficultParamNames.param2, anyParams)
	param3Used, param3UsedHash := impl.ParamKey(
		params.param3, 3, a.moq.runtime.parameterIndexing.DifficultParamNames.param3, anyParams)
	paramUsed, paramUsedHash := impl.ParamKey(
		params.param, 4, a.moq.runtime.parameterIndexing.DifficultParamNames.param, anyParams)
	param5Used, param5UsedHash := impl.ParamKey(
		params.param5, 5, a.moq.runtime.parameterIndexing.DifficultParamNames.param5, anyParams)
	param6Used, param6UsedHash := impl.ParamKey(
		params.param6, 6, a.moq.runtime.parameterIndexing.DifficultParamNames.param6, anyParams)
	param7Used, param7UsedHash := impl.ParamKey(
		params.param7, 7, a.moq.runtime.parameterIndexing.DifficultParamNames.param7, anyParams)
	param8Used, param8UsedHash := impl.ParamKey(
		params.param8, 8, a.moq.runtime.parameterIndexing.DifficultParamNames.param8, anyParams)
	param9Used, param9UsedHash := impl.ParamKey(
		params.param9, 9, a.moq.runtime.parameterIndexing.DifficultParamNames.param9, anyParams)
	return moqUsual_DifficultParamNames_paramsKey{
		params: struct {
			param1, param2         bool
			param3                 string
			param, param5, param6  int
			param7, param8, param9 float32
		}{
			param1: param1Used,
			param2: param2Used,
			param3: param3Used,
			param:  paramUsed,
			param5: param5Used,
			param6: param6Used,
			param7: param7Used,
			param8: param8Used,
			param9: param9Used,
		},
		hashes: struct {
			param1, param2         hash.Hash
			param3                 hash.Hash
			param, param5, param6  hash.Hash
			param7, param8, param9 hash.Hash
		}{
			param1: param1UsedHash,
			param2: param2UsedHash,
			param3: param3UsedHash,
			param:  paramUsedHash,
			param5: param5UsedHash,
			param6: param6UsedHash,
			param7: param7UsedHash,
			param8: param8UsedHash,
			param9: param9UsedHash,
		},
	}
}

func (m *moqUsual_recorder) DifficultResultNames() *moqUsual_DifficultResultNames_recorder {
	return &moqUsual_DifficultResultNames_recorder{
		recorder: m.moq.moq_DifficultResultNames.OnCall(moqUsual_DifficultResultNames_params{}),
	}
}

func (r *moqUsual_DifficultResultNames_recorder) any() *moqUsual_DifficultResultNames_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqUsual_DifficultResultNames_anyParams{recorder: r}
}

func (r *moqUsual_DifficultResultNames_recorder) seq() *moqUsual_DifficultResultNames_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqUsual_DifficultResultNames_recorder) noSeq() *moqUsual_DifficultResultNames_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqUsual_DifficultResultNames_recorder) returnResults(result1, result2 string, result3 error, param, result5, result6 int, result7, result8, result9 float32) *moqUsual_DifficultResultNames_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqUsual_DifficultResultNames_results{
		result1: result1,
		result2: result2,
		result3: result3,
		param:   param,
		result5: result5,
		result6: result6,
		result7: result7,
		result8: result8,
		result9: result9,
	})
	return r
}

func (r *moqUsual_DifficultResultNames_recorder) andDo(fn moqUsual_DifficultResultNames_doFn) *moqUsual_DifficultResultNames_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqUsual_DifficultResultNames_params) {
		fn()
	}, false) {
		return nil
	}
	return r
}

func (r *moqUsual_DifficultResultNames_recorder) doReturnResults(fn moqUsual_DifficultResultNames_doReturnFn) *moqUsual_DifficultResultNames_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqUsual_DifficultResultNames_params) *moqUsual_DifficultResultNames_results {
		result1, result2, result3, param, result5, result6, result7, result8, result9 := fn()
		return &moqUsual_DifficultResultNames_results{
			result1: result1,
			result2: result2,
			result3: result3,
			param:   param,
			result5: result5,
			result6: result6,
			result7: result7,
			result8: result8,
			result9: result9,
		}
	})
	return r
}

func (r *moqUsual_DifficultResultNames_recorder) repeat(repeaters ...moq.Repeater) *moqUsual_DifficultResultNames_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqUsual_DifficultResultNames_adaptor) PrettyParams(params moqUsual_DifficultResultNames_params) string {
	return fmt.Sprintf("DifficultResultNames()")
}

func (a *moqUsual_DifficultResultNames_adaptor) ParamsKey(params moqUsual_DifficultResultNames_params, anyParams uint64) moqUsual_DifficultResultNames_paramsKey {
	a.moq.moq_DifficultResultNames.Scene.T.Helper()
	return moqUsual_DifficultResultNames_paramsKey{
		params: struct{}{},
		hashes: struct{}{},
	}
}

func (m *moqUsual_recorder) PassByArray(p [3]testmoqs.Params) *moqUsual_PassByArray_recorder {
	return &moqUsual_PassByArray_recorder{
		recorder: m.moq.moq_PassByArray.OnCall(moqUsual_PassByArray_params{
			p: p,
		}),
	}
}

func (r *moqUsual_PassByArray_recorder) any() *moqUsual_PassByArray_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqUsual_PassByArray_anyParams{recorder: r}
}

func (a *moqUsual_PassByArray_anyParams) p() *moqUsual_PassByArray_recorder {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (r *moqUsual_PassByArray_recorder) seq() *moqUsual_PassByArray_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqUsual_PassByArray_recorder) noSeq() *moqUsual_PassByArray_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqUsual_PassByArray_recorder) returnResults(result1 [3]testmoqs.Results) *moqUsual_PassByArray_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqUsual_PassByArray_results{
		result1: result1,
	})
	return r
}

func (r *moqUsual_PassByArray_recorder) andDo(fn moqUsual_PassByArray_doFn) *moqUsual_PassByArray_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqUsual_PassByArray_params) {
		fn(params.p)
	}, false) {
		return nil
	}
	return r
}

func (r *moqUsual_PassByArray_recorder) doReturnResults(fn moqUsual_PassByArray_doReturnFn) *moqUsual_PassByArray_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqUsual_PassByArray_params) *moqUsual_PassByArray_results {
		result1 := fn(params.p)
		return &moqUsual_PassByArray_results{
			result1: result1,
		}
	})
	return r
}

func (r *moqUsual_PassByArray_recorder) repeat(repeaters ...moq.Repeater) *moqUsual_PassByArray_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqUsual_PassByArray_adaptor) PrettyParams(params moqUsual_PassByArray_params) string {
	return fmt.Sprintf("PassByArray(%#v)", params.p)
}

func (a *moqUsual_PassByArray_adaptor) ParamsKey(params moqUsual_PassByArray_params, anyParams uint64) moqUsual_PassByArray_paramsKey {
	a.moq.moq_PassByArray.Scene.T.Helper()
	pUsed, pUsedHash := impl.ParamKey(
		params.p, 1, a.moq.runtime.parameterIndexing.PassByArray.p, anyParams)
	return moqUsual_PassByArray_paramsKey{
		params: struct{ p [3]testmoqs.Params }{
			p: pUsed,
		},
		hashes: struct{ p hash.Hash }{
			p: pUsedHash,
		},
	}
}

func (m *moqUsual_recorder) PassByChan(p chan testmoqs.Params) *moqUsual_PassByChan_recorder {
	return &moqUsual_PassByChan_recorder{
		recorder: m.moq.moq_PassByChan.OnCall(moqUsual_PassByChan_params{
			p: p,
		}),
	}
}

func (r *moqUsual_PassByChan_recorder) any() *moqUsual_PassByChan_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqUsual_PassByChan_anyParams{recorder: r}
}

func (a *moqUsual_PassByChan_anyParams) p() *moqUsual_PassByChan_recorder {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (r *moqUsual_PassByChan_recorder) seq() *moqUsual_PassByChan_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqUsual_PassByChan_recorder) noSeq() *moqUsual_PassByChan_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqUsual_PassByChan_recorder) returnResults(result1 chan testmoqs.Results) *moqUsual_PassByChan_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqUsual_PassByChan_results{
		result1: result1,
	})
	return r
}

func (r *moqUsual_PassByChan_recorder) andDo(fn moqUsual_PassByChan_doFn) *moqUsual_PassByChan_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqUsual_PassByChan_params) {
		fn(params.p)
	}, false) {
		return nil
	}
	return r
}

func (r *moqUsual_PassByChan_recorder) doReturnResults(fn moqUsual_PassByChan_doReturnFn) *moqUsual_PassByChan_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqUsual_PassByChan_params) *moqUsual_PassByChan_results {
		result1 := fn(params.p)
		return &moqUsual_PassByChan_results{
			result1: result1,
		}
	})
	return r
}

func (r *moqUsual_PassByChan_recorder) repeat(repeaters ...moq.Repeater) *moqUsual_PassByChan_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqUsual_PassByChan_adaptor) PrettyParams(params moqUsual_PassByChan_params) string {
	return fmt.Sprintf("PassByChan(%#v)", params.p)
}

func (a *moqUsual_PassByChan_adaptor) ParamsKey(params moqUsual_PassByChan_params, anyParams uint64) moqUsual_PassByChan_paramsKey {
	a.moq.moq_PassByChan.Scene.T.Helper()
	pUsed, pUsedHash := impl.ParamKey(
		params.p, 1, a.moq.runtime.parameterIndexing.PassByChan.p, anyParams)
	return moqUsual_PassByChan_paramsKey{
		params: struct{ p chan testmoqs.Params }{
			p: pUsed,
		},
		hashes: struct{ p hash.Hash }{
			p: pUsedHash,
		},
	}
}

func (m *moqUsual_recorder) PassByEllipsis(p ...testmoqs.Params) *moqUsual_PassByEllipsis_recorder {
	return &moqUsual_PassByEllipsis_recorder{
		recorder: m.moq.moq_PassByEllipsis.OnCall(moqUsual_PassByEllipsis_params{
			p: p,
		}),
	}
}

func (r *moqUsual_PassByEllipsis_recorder) any() *moqUsual_PassByEllipsis_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqUsual_PassByEllipsis_anyParams{recorder: r}
}

func (a *moqUsual_PassByEllipsis_anyParams) p() *moqUsual_PassByEllipsis_recorder {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (r *moqUsual_PassByEllipsis_recorder) seq() *moqUsual_PassByEllipsis_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqUsual_PassByEllipsis_recorder) noSeq() *moqUsual_PassByEllipsis_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqUsual_PassByEllipsis_recorder) returnResults(result1 string, result2 error) *moqUsual_PassByEllipsis_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqUsual_PassByEllipsis_results{
		result1: result1,
		result2: result2,
	})
	return r
}

func (r *moqUsual_PassByEllipsis_recorder) andDo(fn moqUsual_PassByEllipsis_doFn) *moqUsual_PassByEllipsis_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqUsual_PassByEllipsis_params) {
		fn(params.p...)
	}, false) {
		return nil
	}
	return r
}

func (r *moqUsual_PassByEllipsis_recorder) doReturnResults(fn moqUsual_PassByEllipsis_doReturnFn) *moqUsual_PassByEllipsis_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqUsual_PassByEllipsis_params) *moqUsual_PassByEllipsis_results {
		result1, result2 := fn(params.p...)
		return &moqUsual_PassByEllipsis_results{
			result1: result1,
			result2: result2,
		}
	})
	return r
}

func (r *moqUsual_PassByEllipsis_recorder) repeat(repeaters ...moq.Repeater) *moqUsual_PassByEllipsis_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqUsual_PassByEllipsis_adaptor) PrettyParams(params moqUsual_PassByEllipsis_params) string {
	return fmt.Sprintf("PassByEllipsis(%#v)", params.p)
}

func (a *moqUsual_PassByEllipsis_adaptor) ParamsKey(params moqUsual_PassByEllipsis_params, anyParams uint64) moqUsual_PassByEllipsis_paramsKey {
	a.moq.moq_PassByEllipsis.Scene.T.Helper()
	pUsedHash := impl.HashOnlyParamKey(a.moq.moq_PassByEllipsis.Scene.T,
		params.p, "p", 1, a.moq.runtime.parameterIndexing.PassByEllipsis.p, anyParams)
	return moqUsual_PassByEllipsis_paramsKey{
		params: struct{}{},
		hashes: struct{ p hash.Hash }{
			p: pUsedHash,
		},
	}
}

func (m *moqUsual_recorder) PassByMap(p map[string]testmoqs.Params) *moqUsual_PassByMap_recorder {
	return &moqUsual_PassByMap_recorder{
		recorder: m.moq.moq_PassByMap.OnCall(moqUsual_PassByMap_params{
			p: p,
		}),
	}
}

func (r *moqUsual_PassByMap_recorder) any() *moqUsual_PassByMap_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqUsual_PassByMap_anyParams{recorder: r}
}

func (a *moqUsual_PassByMap_anyParams) p() *moqUsual_PassByMap_recorder {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (r *moqUsual_PassByMap_recorder) seq() *moqUsual_PassByMap_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqUsual_PassByMap_recorder) noSeq() *moqUsual_PassByMap_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqUsual_PassByMap_recorder) returnResults(result1 map[string]testmoqs.Results) *moqUsual_PassByMap_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqUsual_PassByMap_results{
		result1: result1,
	})
	return r
}

func (r *moqUsual_PassByMap_recorder) andDo(fn moqUsual_PassByMap_doFn) *moqUsual_PassByMap_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqUsual_PassByMap_params) {
		fn(params.p)
	}, false) {
		return nil
	}
	return r
}

func (r *moqUsual_PassByMap_recorder) doReturnResults(fn moqUsual_PassByMap_doReturnFn) *moqUsual_PassByMap_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqUsual_PassByMap_params) *moqUsual_PassByMap_results {
		result1 := fn(params.p)
		return &moqUsual_PassByMap_results{
			result1: result1,
		}
	})
	return r
}

func (r *moqUsual_PassByMap_recorder) repeat(repeaters ...moq.Repeater) *moqUsual_PassByMap_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqUsual_PassByMap_adaptor) PrettyParams(params moqUsual_PassByMap_params) string {
	return fmt.Sprintf("PassByMap(%#v)", params.p)
}

func (a *moqUsual_PassByMap_adaptor) ParamsKey(params moqUsual_PassByMap_params, anyParams uint64) moqUsual_PassByMap_paramsKey {
	a.moq.moq_PassByMap.Scene.T.Helper()
	pUsedHash := impl.HashOnlyParamKey(a.moq.moq_PassByMap.Scene.T,
		params.p, "p", 1, a.moq.runtime.parameterIndexing.PassByMap.p, anyParams)
	return moqUsual_PassByMap_paramsKey{
		params: struct{}{},
		hashes: struct{ p hash.Hash }{
			p: pUsedHash,
		},
	}
}

func (m *moqUsual_recorder) PassByReference(p *testmoqs.Params) *moqUsual_PassByReference_recorder {
	return &moqUsual_PassByReference_recorder{
		recorder: m.moq.moq_PassByReference.OnCall(moqUsual_PassByReference_params{
			p: p,
		}),
	}
}

func (r *moqUsual_PassByReference_recorder) any() *moqUsual_PassByReference_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqUsual_PassByReference_anyParams{recorder: r}
}

func (a *moqUsual_PassByReference_anyParams) p() *moqUsual_PassByReference_recorder {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (r *moqUsual_PassByReference_recorder) seq() *moqUsual_PassByReference_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqUsual_PassByReference_recorder) noSeq() *moqUsual_PassByReference_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqUsual_PassByReference_recorder) returnResults(result1 *testmoqs.Results) *moqUsual_PassByReference_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqUsual_PassByReference_results{
		result1: result1,
	})
	return r
}

func (r *moqUsual_PassByReference_recorder) andDo(fn moqUsual_PassByReference_doFn) *moqUsual_PassByReference_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqUsual_PassByReference_params) {
		fn(params.p)
	}, false) {
		return nil
	}
	return r
}

func (r *moqUsual_PassByReference_recorder) doReturnResults(fn moqUsual_PassByReference_doReturnFn) *moqUsual_PassByReference_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqUsual_PassByReference_params) *moqUsual_PassByReference_results {
		result1 := fn(params.p)
		return &moqUsual_PassByReference_results{
			result1: result1,
		}
	})
	return r
}

func (r *moqUsual_PassByReference_recorder) repeat(repeaters ...moq.Repeater) *moqUsual_PassByReference_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqUsual_PassByReference_adaptor) PrettyParams(params moqUsual_PassByReference_params) string {
	return fmt.Sprintf("PassByReference(%#v)", params.p)
}

func (a *moqUsual_PassByReference_adaptor) ParamsKey(params moqUsual_PassByReference_params, anyParams uint64) moqUsual_PassByReference_paramsKey {
	a.moq.moq_PassByReference.Scene.T.Helper()
	pUsed, pUsedHash := impl.ParamKey(
		params.p, 1, a.moq.runtime.parameterIndexing.PassByReference.p, anyParams)
	return moqUsual_PassByReference_paramsKey{
		params: struct{ p *testmoqs.Params }{
			p: pUsed,
		},
		hashes: struct{ p hash.Hash }{
			p: pUsedHash,
		},
	}
}

func (m *moqUsual_recorder) PassBySlice(p []testmoqs.Params) *moqUsual_PassBySlice_recorder {
	return &moqUsual_PassBySlice_recorder{
		recorder: m.moq.moq_PassBySlice.OnCall(moqUsual_PassBySlice_params{
			p: p,
		}),
	}
}

func (r *moqUsual_PassBySlice_recorder) any() *moqUsual_PassBySlice_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqUsual_PassBySlice_anyParams{recorder: r}
}

func (a *moqUsual_PassBySlice_anyParams) p() *moqUsual_PassBySlice_recorder {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (r *moqUsual_PassBySlice_recorder) seq() *moqUsual_PassBySlice_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqUsual_PassBySlice_recorder) noSeq() *moqUsual_PassBySlice_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqUsual_PassBySlice_recorder) returnResults(result1 []testmoqs.Results) *moqUsual_PassBySlice_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqUsual_PassBySlice_results{
		result1: result1,
	})
	return r
}

func (r *moqUsual_PassBySlice_recorder) andDo(fn moqUsual_PassBySlice_doFn) *moqUsual_PassBySlice_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqUsual_PassBySlice_params) {
		fn(params.p)
	}, false) {
		return nil
	}
	return r
}

func (r *moqUsual_PassBySlice_recorder) doReturnResults(fn moqUsual_PassBySlice_doReturnFn) *moqUsual_PassBySlice_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqUsual_PassBySlice_params) *moqUsual_PassBySlice_results {
		result1 := fn(params.p)
		return &moqUsual_PassBySlice_results{
			result1: result1,
		}
	})
	return r
}

func (r *moqUsual_PassBySlice_recorder) repeat(repeaters ...moq.Repeater) *moqUsual_PassBySlice_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqUsual_PassBySlice_adaptor) PrettyParams(params moqUsual_PassBySlice_params) string {
	return fmt.Sprintf("PassBySlice(%#v)", params.p)
}

func (a *moqUsual_PassBySlice_adaptor) ParamsKey(params moqUsual_PassBySlice_params, anyParams uint64) moqUsual_PassBySlice_paramsKey {
	a.moq.moq_PassBySlice.Scene.T.Helper()
	pUsedHash := impl.HashOnlyParamKey(a.moq.moq_PassBySlice.Scene.T,
		params.p, "p", 1, a.moq.runtime.parameterIndexing.PassBySlice.p, anyParams)
	return moqUsual_PassBySlice_paramsKey{
		params: struct{}{},
		hashes: struct{ p hash.Hash }{
			p: pUsedHash,
		},
	}
}

func (m *moqUsual_recorder) PassByValue(p testmoqs.Params) *moqUsual_PassByValue_recorder {
	return &moqUsual_PassByValue_recorder{
		recorder: m.moq.moq_PassByValue.OnCall(moqUsual_PassByValue_params{
			p: p,
		}),
	}
}

func (r *moqUsual_PassByValue_recorder) any() *moqUsual_PassByValue_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqUsual_PassByValue_anyParams{recorder: r}
}

func (a *moqUsual_PassByValue_anyParams) p() *moqUsual_PassByValue_recorder {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (r *moqUsual_PassByValue_recorder) seq() *moqUsual_PassByValue_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqUsual_PassByValue_recorder) noSeq() *moqUsual_PassByValue_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqUsual_PassByValue_recorder) returnResults(result1 testmoqs.Results) *moqUsual_PassByValue_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqUsual_PassByValue_results{
		result1: result1,
	})
	return r
}

func (r *moqUsual_PassByValue_recorder) andDo(fn moqUsual_PassByValue_doFn) *moqUsual_PassByValue_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqUsual_PassByValue_params) {
		fn(params.p)
	}, false) {
		return nil
	}
	return r
}

func (r *moqUsual_PassByValue_recorder) doReturnResults(fn moqUsual_PassByValue_doReturnFn) *moqUsual_PassByValue_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqUsual_PassByValue_params) *moqUsual_PassByValue_results {
		result1 := fn(params.p)
		return &moqUsual_PassByValue_results{
			result1: result1,
		}
	})
	return r
}

func (r *moqUsual_PassByValue_recorder) repeat(repeaters ...moq.Repeater) *moqUsual_PassByValue_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqUsual_PassByValue_adaptor) PrettyParams(params moqUsual_PassByValue_params) string {
	return fmt.Sprintf("PassByValue(%#v)", params.p)
}

func (a *moqUsual_PassByValue_adaptor) ParamsKey(params moqUsual_PassByValue_params, anyParams uint64) moqUsual_PassByValue_paramsKey {
	a.moq.moq_PassByValue.Scene.T.Helper()
	pUsed, pUsedHash := impl.ParamKey(
		params.p, 1, a.moq.runtime.parameterIndexing.PassByValue.p, anyParams)
	return moqUsual_PassByValue_paramsKey{
		params: struct{ p testmoqs.Params }{
			p: pUsed,
		},
		hashes: struct{ p hash.Hash }{
			p: pUsedHash,
		},
	}
}

func (m *moqUsual_recorder) InterfaceParam(w io.Writer) *moqUsual_InterfaceParam_recorder {
	return &moqUsual_InterfaceParam_recorder{
		recorder: m.moq.moq_InterfaceParam.OnCall(moqUsual_InterfaceParam_params{
			w: w,
		}),
	}
}

func (r *moqUsual_InterfaceParam_recorder) any() *moqUsual_InterfaceParam_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqUsual_InterfaceParam_anyParams{recorder: r}
}

func (a *moqUsual_InterfaceParam_anyParams) w() *moqUsual_InterfaceParam_recorder {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (r *moqUsual_InterfaceParam_recorder) seq() *moqUsual_InterfaceParam_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqUsual_InterfaceParam_recorder) noSeq() *moqUsual_InterfaceParam_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqUsual_InterfaceParam_recorder) returnResults(sResult string, err error) *moqUsual_InterfaceParam_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqUsual_InterfaceParam_results{
		sResult: sResult,
		err:     err,
	})
	return r
}

func (r *moqUsual_InterfaceParam_recorder) andDo(fn moqUsual_InterfaceParam_doFn) *moqUsual_InterfaceParam_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqUsual_InterfaceParam_params) {
		fn(params.w)
	}, false) {
		return nil
	}
	return r
}

func (r *moqUsual_InterfaceParam_recorder) doReturnResults(fn moqUsual_InterfaceParam_doReturnFn) *moqUsual_InterfaceParam_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqUsual_InterfaceParam_params) *moqUsual_InterfaceParam_results {
		sResult, err := fn(params.w)
		return &moqUsual_InterfaceParam_results{
			sResult: sResult,
			err:     err,
		}
	})
	return r
}

func (r *moqUsual_InterfaceParam_recorder) repeat(repeaters ...moq.Repeater) *moqUsual_InterfaceParam_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqUsual_InterfaceParam_adaptor) PrettyParams(params moqUsual_InterfaceParam_params) string {
	return fmt.Sprintf("InterfaceParam(%#v)", params.w)
}

func (a *moqUsual_InterfaceParam_adaptor) ParamsKey(params moqUsual_InterfaceParam_params, anyParams uint64) moqUsual_InterfaceParam_paramsKey {
	a.moq.moq_InterfaceParam.Scene.T.Helper()
	wUsed, wUsedHash := impl.ParamKey(
		params.w, 1, a.moq.runtime.parameterIndexing.InterfaceParam.w, anyParams)
	return moqUsual_InterfaceParam_paramsKey{
		params: struct{ w io.Writer }{
			w: wUsed,
		},
		hashes: struct{ w hash.Hash }{
			w: wUsedHash,
		},
	}
}

func (m *moqUsual_recorder) InterfaceResult(sParam string, bParam bool) *moqUsual_InterfaceResult_recorder {
	return &moqUsual_InterfaceResult_recorder{
		recorder: m.moq.moq_InterfaceResult.OnCall(moqUsual_InterfaceResult_params{
			sParam: sParam,
			bParam: bParam,
		}),
	}
}

func (r *moqUsual_InterfaceResult_recorder) any() *moqUsual_InterfaceResult_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqUsual_InterfaceResult_anyParams{recorder: r}
}

func (a *moqUsual_InterfaceResult_anyParams) sParam() *moqUsual_InterfaceResult_recorder {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (a *moqUsual_InterfaceResult_anyParams) bParam() *moqUsual_InterfaceResult_recorder {
	a.recorder.recorder.AnyParam(2)
	return a.recorder
}

func (r *moqUsual_InterfaceResult_recorder) seq() *moqUsual_InterfaceResult_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqUsual_InterfaceResult_recorder) noSeq() *moqUsual_InterfaceResult_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqUsual_InterfaceResult_recorder) returnResults(result1 io.Reader) *moqUsual_InterfaceResult_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqUsual_InterfaceResult_results{
		result1: result1,
	})
	return r
}

func (r *moqUsual_InterfaceResult_recorder) andDo(fn moqUsual_InterfaceResult_doFn) *moqUsual_InterfaceResult_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqUsual_InterfaceResult_params) {
		fn(params.sParam, params.bParam)
	}, false) {
		return nil
	}
	return r
}

func (r *moqUsual_InterfaceResult_recorder) doReturnResults(fn moqUsual_InterfaceResult_doReturnFn) *moqUsual_InterfaceResult_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqUsual_InterfaceResult_params) *moqUsual_InterfaceResult_results {
		result1 := fn(params.sParam, params.bParam)
		return &moqUsual_InterfaceResult_results{
			result1: result1,
		}
	})
	return r
}

func (r *moqUsual_InterfaceResult_recorder) repeat(repeaters ...moq.Repeater) *moqUsual_InterfaceResult_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqUsual_InterfaceResult_adaptor) PrettyParams(params moqUsual_InterfaceResult_params) string {
	return fmt.Sprintf("InterfaceResult(%#v, %#v)", params.sParam, params.bParam)
}

func (a *moqUsual_InterfaceResult_adaptor) ParamsKey(params moqUsual_InterfaceResult_params, anyParams uint64) moqUsual_InterfaceResult_paramsKey {
	a.moq.moq_InterfaceResult.Scene.T.Helper()
	sParamUsed, sParamUsedHash := impl.ParamKey(
		params.sParam, 1, a.moq.runtime.parameterIndexing.InterfaceResult.sParam, anyParams)
	bParamUsed, bParamUsedHash := impl.ParamKey(
		params.bParam, 2, a.moq.runtime.parameterIndexing.InterfaceResult.bParam, anyParams)
	return moqUsual_InterfaceResult_paramsKey{
		params: struct {
			sParam string
			bParam bool
		}{
			sParam: sParamUsed,
			bParam: bParamUsed,
		},
		hashes: struct {
			sParam hash.Hash
			bParam hash.Hash
		}{
			sParam: sParamUsedHash,
			bParam: bParamUsedHash,
		},
	}
}

func (m *moqUsual_recorder) FnParam(fn func()) *moqUsual_FnParam_recorder {
	return &moqUsual_FnParam_recorder{
		recorder: m.moq.moq_FnParam.OnCall(moqUsual_FnParam_params{
			fn: fn,
		}),
	}
}

func (r *moqUsual_FnParam_recorder) any() *moqUsual_FnParam_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqUsual_FnParam_anyParams{recorder: r}
}

func (a *moqUsual_FnParam_anyParams) fn() *moqUsual_FnParam_recorder {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (r *moqUsual_FnParam_recorder) seq() *moqUsual_FnParam_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqUsual_FnParam_recorder) noSeq() *moqUsual_FnParam_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqUsual_FnParam_recorder) returnResults() *moqUsual_FnParam_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqUsual_FnParam_results{})
	return r
}

func (r *moqUsual_FnParam_recorder) andDo(fn moqUsual_FnParam_doFn) *moqUsual_FnParam_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqUsual_FnParam_params) {
		fn(params.fn)
	}, false) {
		return nil
	}
	return r
}

func (r *moqUsual_FnParam_recorder) doReturnResults(fn moqUsual_FnParam_doReturnFn) *moqUsual_FnParam_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqUsual_FnParam_params) *moqUsual_FnParam_results {
		fn(params.fn)
		return &moqUsual_FnParam_results{}
	})
	return r
}

func (r *moqUsual_FnParam_recorder) repeat(repeaters ...moq.Repeater) *moqUsual_FnParam_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqUsual_FnParam_adaptor) PrettyParams(params moqUsual_FnParam_params) string {
	return fmt.Sprintf("FnParam(%#v)", moq.FnString(params.fn))
}

func (a *moqUsual_FnParam_adaptor) ParamsKey(params moqUsual_FnParam_params, anyParams uint64) moqUsual_FnParam_paramsKey {
	a.moq.moq_FnParam.Scene.T.Helper()
	fnUsedHash := impl.HashOnlyParamKey(a.moq.moq_FnParam.Scene.T,
		params.fn, "fn", 1, a.moq.runtime.parameterIndexing.FnParam.fn, anyParams)
	return moqUsual_FnParam_paramsKey{
		params: struct{}{},
		hashes: struct{ fn hash.Hash }{
			fn: fnUsedHash,
		},
	}
}

func (m *moqUsual_recorder) Other(param1 other.Params) *moqUsual_Other_recorder {
	return &moqUsual_Other_recorder{
		recorder: m.moq.moq_Other.OnCall(moqUsual_Other_params{
			param1: param1,
		}),
	}
}

func (r *moqUsual_Other_recorder) any() *moqUsual_Other_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqUsual_Other_anyParams{recorder: r}
}

func (a *moqUsual_Other_anyParams) param1() *moqUsual_Other_recorder {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (r *moqUsual_Other_recorder) seq() *moqUsual_Other_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqUsual_Other_recorder) noSeq() *moqUsual_Other_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqUsual_Other_recorder) returnResults(result1 other.Results) *moqUsual_Other_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqUsual_Other_results{
		result1: result1,
	})
	return r
}

func (r *moqUsual_Other_recorder) andDo(fn moqUsual_Other_doFn) *moqUsual_Other_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqUsual_Other_params) {
		fn(params.param1)
	}, false) {
		return nil
	}
	return r
}

func (r *moqUsual_Other_recorder) doReturnResults(fn moqUsual_Other_doReturnFn) *moqUsual_Other_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqUsual_Other_params) *moqUsual_Other_results {
		result1 := fn(params.param1)
		return &moqUsual_Other_results{
			result1: result1,
		}
	})
	return r
}

func (r *moqUsual_Other_recorder) repeat(repeaters ...moq.Repeater) *moqUsual_Other_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqUsual_Other_adaptor) PrettyParams(params moqUsual_Other_params) string {
	return fmt.Sprintf("Other(%#v)", params.param1)
}

func (a *moqUsual_Other_adaptor) ParamsKey(params moqUsual_Other_params, anyParams uint64) moqUsual_Other_paramsKey {
	a.moq.moq_Other.Scene.T.Helper()
	param1Used, param1UsedHash := impl.ParamKey(
		params.param1, 1, a.moq.runtime.parameterIndexing.Other.param1, anyParams)
	return moqUsual_Other_paramsKey{
		params: struct{ param1 other.Params }{
			param1: param1Used,
		},
		hashes: struct{ param1 hash.Hash }{
			param1: param1UsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *moqUsual) Reset() {
	m.moq_Usual.Reset()
	m.moq_NoNames.Reset()
	m.moq_NoResults.Reset()
	m.moq_NoParams.Reset()
	m.moq_Nothing.Reset()
	m.moq_Variadic.Reset()
	m.moq_RepeatedIds.Reset()
	m.moq_Times.Reset()
	m.moq_DifficultParamNames.Reset()
	m.moq_DifficultResultNames.Reset()
	m.moq_PassByArray.Reset()
	m.moq_PassByChan.Reset()
	m.moq_PassByEllipsis.Reset()
	m.moq_PassByMap.Reset()
	m.moq_PassByReference.Reset()
	m.moq_PassBySlice.Reset()
	m.moq_PassByValue.Reset()
	m.moq_InterfaceParam.Reset()
	m.moq_InterfaceResult.Reset()
	m.moq_FnParam.Reset()
	m.moq_Other.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *moqUsual) AssertExpectationsMet() {
	m.moq_Usual.Scene.T.Helper()
	m.moq_Usual.AssertExpectationsMet()
	m.moq_NoNames.AssertExpectationsMet()
	m.moq_NoResults.AssertExpectationsMet()
	m.moq_NoParams.AssertExpectationsMet()
	m.moq_Nothing.AssertExpectationsMet()
	m.moq_Variadic.AssertExpectationsMet()
	m.moq_RepeatedIds.AssertExpectationsMet()
	m.moq_Times.AssertExpectationsMet()
	m.moq_DifficultParamNames.AssertExpectationsMet()
	m.moq_DifficultResultNames.AssertExpectationsMet()
	m.moq_PassByArray.AssertExpectationsMet()
	m.moq_PassByChan.AssertExpectationsMet()
	m.moq_PassByEllipsis.AssertExpectationsMet()
	m.moq_PassByMap.AssertExpectationsMet()
	m.moq_PassByReference.AssertExpectationsMet()
	m.moq_PassBySlice.AssertExpectationsMet()
	m.moq_PassByValue.AssertExpectationsMet()
	m.moq_InterfaceParam.AssertExpectationsMet()
	m.moq_InterfaceResult.AssertExpectationsMet()
	m.moq_FnParam.AssertExpectationsMet()
	m.moq_Other.AssertExpectationsMet()
}

// The following type assertion assures that testmoqs.GenericParams is mocked
// completely
var _ testmoqs.GenericParams[any, any] = (*moqGenericParams_mock[any, any])(nil)

// moqGenericParams holds the state of a moq of the GenericParams type
type moqGenericParams[S, B any] struct {
	moq *moqGenericParams_mock[S, B]

	moq_Usual *impl.Moq[
		*moqGenericParams_Usual_adaptor[S, B],
		moqGenericParams_Usual_params[S, B],
		moqGenericParams_Usual_paramsKey[S, B],
		moqGenericParams_Usual_results[S, B]]

	runtime moqGenericParams_runtime
}

// moqGenericParams_mock isolates the mock interface of the GenericParams type
type moqGenericParams_mock[S, B any] struct {
	moq *moqGenericParams[S, B]
}

// moqGenericParams_recorder isolates the recorder interface of the
// GenericParams type
type moqGenericParams_recorder[S, B any] struct {
	moq *moqGenericParams[S, B]
}

// moqGenericParams_runtime holds runtime configuration for the GenericParams
// type
type moqGenericParams_runtime struct {
	parameterIndexing struct {
		Usual moqGenericParams_Usual_paramIndexing
	}
}

// moqGenericParams_Usual_adaptor adapts moqGenericParams as needed by the
// runtime
type moqGenericParams_Usual_adaptor[S, B any] struct {
	moq *moqGenericParams[S, B]
}

// moqGenericParams_Usual_params holds the params of the GenericParams type
type moqGenericParams_Usual_params[S, B any] struct {
	param1 S
	param2 B
}

// moqGenericParams_Usual_paramsKey holds the map key params of the
// GenericParams type
type moqGenericParams_Usual_paramsKey[S, B any] struct {
	params struct{}
	hashes struct {
		param1 hash.Hash
		param2 hash.Hash
	}
}

// moqGenericParams_Usual_results holds the results of the GenericParams type
type moqGenericParams_Usual_results[S, B any] struct {
	result1 string
	result2 error
}

// moqGenericParams_Usual_paramIndexing holds the parameter indexing runtime
// configuration for the GenericParams type
type moqGenericParams_Usual_paramIndexing struct {
	param1 moq.ParamIndexing
	param2 moq.ParamIndexing
}

// moqGenericParams_Usual_doFn defines the type of function needed when calling
// andDo for the GenericParams type
type moqGenericParams_Usual_doFn[S, B any] func(S, B)

// moqGenericParams_Usual_doReturnFn defines the type of function needed when
// calling doReturnResults for the GenericParams type
type moqGenericParams_Usual_doReturnFn[S, B any] func(S, B) (string, error)

// moqGenericParams_Usual_recorder routes recorded function calls to the
// moqGenericParams moq
type moqGenericParams_Usual_recorder[S, B any] struct {
	recorder *impl.Recorder[
		*moqGenericParams_Usual_adaptor[S, B],
		moqGenericParams_Usual_params[S, B],
		moqGenericParams_Usual_paramsKey[S, B],
		moqGenericParams_Usual_results[S, B]]
}

// moqGenericParams_Usual_anyParams isolates the any params functions of the
// GenericParams type
type moqGenericParams_Usual_anyParams[S, B any] struct {
	recorder *moqGenericParams_Usual_recorder[S, B]
}

// newMoqGenericParams creates a new moq of the GenericParams type
func newMoqGenericParams[S, B any](scene *moq.Scene, config *moq.Config) *moqGenericParams[S, B] {
	adaptor1 := &moqGenericParams_Usual_adaptor[S, B]{}
	m := &moqGenericParams[S, B]{
		moq: &moqGenericParams_mock[S, B]{},

		moq_Usual: impl.NewMoq[
			*moqGenericParams_Usual_adaptor[S, B],
			moqGenericParams_Usual_params[S, B],
			moqGenericParams_Usual_paramsKey[S, B],
			moqGenericParams_Usual_results[S, B]](scene, adaptor1, config),

		runtime: moqGenericParams_runtime{parameterIndexing: struct {
			Usual moqGenericParams_Usual_paramIndexing
		}{
			Usual: moqGenericParams_Usual_paramIndexing{
				param1: moq.ParamIndexByHash,
				param2: moq.ParamIndexByHash,
			},
		}},
	}
	m.moq.moq = m

	adaptor1.moq = m

	scene.AddMoq(m)
	return m
}

// mock returns the mock implementation of the GenericParams type
func (m *moqGenericParams[S, B]) mock() *moqGenericParams_mock[S, B] { return m.moq }

func (m *moqGenericParams_mock[S, B]) Usual(param1 S, param2 B) (string, error) {
	m.moq.moq_Usual.Scene.T.Helper()
	params := moqGenericParams_Usual_params[S, B]{
		param1: param1,
		param2: param2,
	}

	var result1 string
	var result2 error
	if result := m.moq.moq_Usual.Function(params); result != nil {
		result1 = result.result1
		result2 = result.result2
	}
	return result1, result2
}

// onCall returns the recorder implementation of the GenericParams type
func (m *moqGenericParams[S, B]) onCall() *moqGenericParams_recorder[S, B] {
	return &moqGenericParams_recorder[S, B]{
		moq: m,
	}
}

func (m *moqGenericParams_recorder[S, B]) Usual(param1 S, param2 B) *moqGenericParams_Usual_recorder[S, B] {
	return &moqGenericParams_Usual_recorder[S, B]{
		recorder: m.moq.moq_Usual.OnCall(moqGenericParams_Usual_params[S, B]{
			param1: param1,
			param2: param2,
		}),
	}
}

func (r *moqGenericParams_Usual_recorder[S, B]) any() *moqGenericParams_Usual_anyParams[S, B] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqGenericParams_Usual_anyParams[S, B]{recorder: r}
}

func (a *moqGenericParams_Usual_anyParams[S, B]) param1() *moqGenericParams_Usual_recorder[S, B] {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (a *moqGenericParams_Usual_anyParams[S, B]) param2() *moqGenericParams_Usual_recorder[S, B] {
	a.recorder.recorder.AnyParam(2)
	return a.recorder
}

func (r *moqGenericParams_Usual_recorder[S, B]) seq() *moqGenericParams_Usual_recorder[S, B] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqGenericParams_Usual_recorder[S, B]) noSeq() *moqGenericParams_Usual_recorder[S, B] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqGenericParams_Usual_recorder[S, B]) returnResults(result1 string, result2 error) *moqGenericParams_Usual_recorder[S, B] {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqGenericParams_Usual_results[S, B]{
		result1: result1,
		result2: result2,
	})
	return r
}

func (r *moqGenericParams_Usual_recorder[S, B]) andDo(fn moqGenericParams_Usual_doFn[S, B]) *moqGenericParams_Usual_recorder[S, B] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqGenericParams_Usual_params[S, B]) {
		fn(params.param1, params.param2)
	}, false) {
		return nil
	}
	return r
}

func (r *moqGenericParams_Usual_recorder[S, B]) doReturnResults(fn moqGenericParams_Usual_doReturnFn[S, B]) *moqGenericParams_Usual_recorder[S, B] {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqGenericParams_Usual_params[S, B]) *moqGenericParams_Usual_results[S, B] {
		result1, result2 := fn(params.param1, params.param2)
		return &moqGenericParams_Usual_results[S, B]{
			result1: result1,
			result2: result2,
		}
	})
	return r
}

func (r *moqGenericParams_Usual_recorder[S, B]) repeat(repeaters ...moq.Repeater) *moqGenericParams_Usual_recorder[S, B] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqGenericParams_Usual_adaptor[S, B]) PrettyParams(params moqGenericParams_Usual_params[S, B]) string {
	return fmt.Sprintf("Usual(%#v, %#v)", params.param1, params.param2)
}

func (a *moqGenericParams_Usual_adaptor[S, B]) ParamsKey(params moqGenericParams_Usual_params[S, B], anyParams uint64) moqGenericParams_Usual_paramsKey[S, B] {
	a.moq.moq_Usual.Scene.T.Helper()
	param1UsedHash := impl.HashOnlyParamKey(a.moq.moq_Usual.Scene.T,
		params.param1, "param1", 1, a.moq.runtime.parameterIndexing.Usual.param1, anyParams)
	param2UsedHash := impl.HashOnlyParamKey(a.moq.moq_Usual.Scene.T,
		params.param2, "param2", 2, a.moq.runtime.parameterIndexing.Usual.param2, anyParams)
	return moqGenericParams_Usual_paramsKey[S, B]{
		params: struct{}{},
		hashes: struct {
			param1 hash.Hash
			param2 hash.Hash
		}{
			param1: param1UsedHash,
			param2: param2UsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *moqGenericParams[S, B]) Reset() {
	m.moq_Usual.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *moqGenericParams[S, B]) AssertExpectationsMet() {
	m.moq_Usual.Scene.T.Helper()
	m.moq_Usual.AssertExpectationsMet()
}

// The following type assertion assures that testmoqs.PartialGenericParams is
// mocked completely
var _ testmoqs.PartialGenericParams[any] = (*moqPartialGenericParams_mock[any])(nil)

// moqPartialGenericParams holds the state of a moq of the PartialGenericParams
// type
type moqPartialGenericParams[S any] struct {
	moq *moqPartialGenericParams_mock[S]

	moq_Usual *impl.Moq[
		*moqPartialGenericParams_Usual_adaptor[S],
		moqPartialGenericParams_Usual_params[S],
		moqPartialGenericParams_Usual_paramsKey[S],
		moqPartialGenericParams_Usual_results[S]]

	runtime moqPartialGenericParams_runtime
}

// moqPartialGenericParams_mock isolates the mock interface of the
// PartialGenericParams type
type moqPartialGenericParams_mock[S any] struct {
	moq *moqPartialGenericParams[S]
}

// moqPartialGenericParams_recorder isolates the recorder interface of the
// PartialGenericParams type
type moqPartialGenericParams_recorder[S any] struct {
	moq *moqPartialGenericParams[S]
}

// moqPartialGenericParams_runtime holds runtime configuration for the
// PartialGenericParams type
type moqPartialGenericParams_runtime struct {
	parameterIndexing struct {
		Usual moqPartialGenericParams_Usual_paramIndexing
	}
}

// moqPartialGenericParams_Usual_adaptor adapts moqPartialGenericParams as
// needed by the runtime
type moqPartialGenericParams_Usual_adaptor[S any] struct {
	moq *moqPartialGenericParams[S]
}

// moqPartialGenericParams_Usual_params holds the params of the
// PartialGenericParams type
type moqPartialGenericParams_Usual_params[S any] struct {
	param1 S
	param2 bool
}

// moqPartialGenericParams_Usual_paramsKey holds the map key params of the
// PartialGenericParams type
type moqPartialGenericParams_Usual_paramsKey[S any] struct {
	params struct{ param2 bool }
	hashes struct {
		param1 hash.Hash
		param2 hash.Hash
	}
}

// moqPartialGenericParams_Usual_results holds the results of the
// PartialGenericParams type
type moqPartialGenericParams_Usual_results[S any] struct {
	result1 string
	result2 error
}

// moqPartialGenericParams_Usual_paramIndexing holds the parameter indexing
// runtime configuration for the PartialGenericParams type
type moqPartialGenericParams_Usual_paramIndexing struct {
	param1 moq.ParamIndexing
	param2 moq.ParamIndexing
}

// moqPartialGenericParams_Usual_doFn defines the type of function needed when
// calling andDo for the PartialGenericParams type
type moqPartialGenericParams_Usual_doFn[S any] func(S, bool)

// moqPartialGenericParams_Usual_doReturnFn defines the type of function needed
// when calling doReturnResults for the PartialGenericParams type
type moqPartialGenericParams_Usual_doReturnFn[S any] func(S, bool) (string, error)

// moqPartialGenericParams_Usual_recorder routes recorded function calls to the
// moqPartialGenericParams moq
type moqPartialGenericParams_Usual_recorder[S any] struct {
	recorder *impl.Recorder[
		*moqPartialGenericParams_Usual_adaptor[S],
		moqPartialGenericParams_Usual_params[S],
		moqPartialGenericParams_Usual_paramsKey[S],
		moqPartialGenericParams_Usual_results[S]]
}

// moqPartialGenericParams_Usual_anyParams isolates the any params functions of
// the PartialGenericParams type
type moqPartialGenericParams_Usual_anyParams[S any] struct {
	recorder *moqPartialGenericParams_Usual_recorder[S]
}

// newMoqPartialGenericParams creates a new moq of the PartialGenericParams
// type
func newMoqPartialGenericParams[S any](scene *moq.Scene, config *moq.Config) *moqPartialGenericParams[S] {
	adaptor1 := &moqPartialGenericParams_Usual_adaptor[S]{}
	m := &moqPartialGenericParams[S]{
		moq: &moqPartialGenericParams_mock[S]{},

		moq_Usual: impl.NewMoq[
			*moqPartialGenericParams_Usual_adaptor[S],
			moqPartialGenericParams_Usual_params[S],
			moqPartialGenericParams_Usual_paramsKey[S],
			moqPartialGenericParams_Usual_results[S]](scene, adaptor1, config),

		runtime: moqPartialGenericParams_runtime{parameterIndexing: struct {
			Usual moqPartialGenericParams_Usual_paramIndexing
		}{
			Usual: moqPartialGenericParams_Usual_paramIndexing{
				param1: moq.ParamIndexByHash,
				param2: moq.ParamIndexByValue,
			},
		}},
	}
	m.moq.moq = m

	adaptor1.moq = m

	scene.AddMoq(m)
	return m
}

// mock returns the mock implementation of the PartialGenericParams type
func (m *moqPartialGenericParams[S]) mock() *moqPartialGenericParams_mock[S] { return m.moq }

func (m *moqPartialGenericParams_mock[S]) Usual(param1 S, param2 bool) (string, error) {
	m.moq.moq_Usual.Scene.T.Helper()
	params := moqPartialGenericParams_Usual_params[S]{
		param1: param1,
		param2: param2,
	}

	var result1 string
	var result2 error
	if result := m.moq.moq_Usual.Function(params); result != nil {
		result1 = result.result1
		result2 = result.result2
	}
	return result1, result2
}

// onCall returns the recorder implementation of the PartialGenericParams type
func (m *moqPartialGenericParams[S]) onCall() *moqPartialGenericParams_recorder[S] {
	return &moqPartialGenericParams_recorder[S]{
		moq: m,
	}
}

func (m *moqPartialGenericParams_recorder[S]) Usual(param1 S, param2 bool) *moqPartialGenericParams_Usual_recorder[S] {
	return &moqPartialGenericParams_Usual_recorder[S]{
		recorder: m.moq.moq_Usual.OnCall(moqPartialGenericParams_Usual_params[S]{
			param1: param1,
			param2: param2,
		}),
	}
}

func (r *moqPartialGenericParams_Usual_recorder[S]) any() *moqPartialGenericParams_Usual_anyParams[S] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqPartialGenericParams_Usual_anyParams[S]{recorder: r}
}

func (a *moqPartialGenericParams_Usual_anyParams[S]) param1() *moqPartialGenericParams_Usual_recorder[S] {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (a *moqPartialGenericParams_Usual_anyParams[S]) param2() *moqPartialGenericParams_Usual_recorder[S] {
	a.recorder.recorder.AnyParam(2)
	return a.recorder
}

func (r *moqPartialGenericParams_Usual_recorder[S]) seq() *moqPartialGenericParams_Usual_recorder[S] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqPartialGenericParams_Usual_recorder[S]) noSeq() *moqPartialGenericParams_Usual_recorder[S] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqPartialGenericParams_Usual_recorder[S]) returnResults(result1 string, result2 error) *moqPartialGenericParams_Usual_recorder[S] {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqPartialGenericParams_Usual_results[S]{
		result1: result1,
		result2: result2,
	})
	return r
}

func (r *moqPartialGenericParams_Usual_recorder[S]) andDo(fn moqPartialGenericParams_Usual_doFn[S]) *moqPartialGenericParams_Usual_recorder[S] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqPartialGenericParams_Usual_params[S]) {
		fn(params.param1, params.param2)
	}, false) {
		return nil
	}
	return r
}

func (r *moqPartialGenericParams_Usual_recorder[S]) doReturnResults(fn moqPartialGenericParams_Usual_doReturnFn[S]) *moqPartialGenericParams_Usual_recorder[S] {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqPartialGenericParams_Usual_params[S]) *moqPartialGenericParams_Usual_results[S] {
		result1, result2 := fn(params.param1, params.param2)
		return &moqPartialGenericParams_Usual_results[S]{
			result1: result1,
			result2: result2,
		}
	})
	return r
}

func (r *moqPartialGenericParams_Usual_recorder[S]) repeat(repeaters ...moq.Repeater) *moqPartialGenericParams_Usual_recorder[S] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqPartialGenericParams_Usual_adaptor[S]) PrettyParams(params moqPartialGenericParams_Usual_params[S]) string {
	return fmt.Sprintf("Usual(%#v, %#v)", params.param1, params.param2)
}

func (a *moqPartialGenericParams_Usual_adaptor[S]) ParamsKey(params moqPartialGenericParams_Usual_params[S], anyParams uint64) moqPartialGenericParams_Usual_paramsKey[S] {
	a.moq.moq_Usual.Scene.T.Helper()
	param1UsedHash := impl.HashOnlyParamKey(a.moq.moq_Usual.Scene.T,
		params.param1, "param1", 1, a.moq.runtime.parameterIndexing.Usual.param1, anyParams)
	param2Used, param2UsedHash := impl.ParamKey(
		params.param2, 2, a.moq.runtime.parameterIndexing.Usual.param2, anyParams)
	return moqPartialGenericParams_Usual_paramsKey[S]{
		params: struct{ param2 bool }{
			param2: param2Used,
		},
		hashes: struct {
			param1 hash.Hash
			param2 hash.Hash
		}{
			param1: param1UsedHash,
			param2: param2UsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *moqPartialGenericParams[S]) Reset() {
	m.moq_Usual.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *moqPartialGenericParams[S]) AssertExpectationsMet() {
	m.moq_Usual.Scene.T.Helper()
	m.moq_Usual.AssertExpectationsMet()
}

// The following type assertion assures that testmoqs.GenericResults is mocked
// completely
var _ testmoqs.GenericResults[string, error] = (*moqGenericResults_mock[string, error])(nil)

// moqGenericResults holds the state of a moq of the GenericResults type
type moqGenericResults[S ~string, E error] struct {
	moq *moqGenericResults_mock[S, E]

	moq_Usual *impl.Moq[
		*moqGenericResults_Usual_adaptor[S, E],
		moqGenericResults_Usual_params[S, E],
		moqGenericResults_Usual_paramsKey[S, E],
		moqGenericResults_Usual_results[S, E]]

	runtime moqGenericResults_runtime
}

// moqGenericResults_mock isolates the mock interface of the GenericResults
// type
type moqGenericResults_mock[S ~string, E error] struct {
	moq *moqGenericResults[S, E]
}

// moqGenericResults_recorder isolates the recorder interface of the
// GenericResults type
type moqGenericResults_recorder[S ~string, E error] struct {
	moq *moqGenericResults[S, E]
}

// moqGenericResults_runtime holds runtime configuration for the GenericResults
// type
type moqGenericResults_runtime struct {
	parameterIndexing struct {
		Usual moqGenericResults_Usual_paramIndexing
	}
}

// moqGenericResults_Usual_adaptor adapts moqGenericResults as needed by the
// runtime
type moqGenericResults_Usual_adaptor[S ~string, E error] struct {
	moq *moqGenericResults[S, E]
}

// moqGenericResults_Usual_params holds the params of the GenericResults type
type moqGenericResults_Usual_params[S ~string, E error] struct {
	param1 string
	param2 bool
}

// moqGenericResults_Usual_paramsKey holds the map key params of the
// GenericResults type
type moqGenericResults_Usual_paramsKey[S ~string, E error] struct {
	params struct {
		param1 string
		param2 bool
	}
	hashes struct {
		param1 hash.Hash
		param2 hash.Hash
	}
}

// moqGenericResults_Usual_results holds the results of the GenericResults type
type moqGenericResults_Usual_results[S ~string, E error] struct {
	result1 S
	result2 E
}

// moqGenericResults_Usual_paramIndexing holds the parameter indexing runtime
// configuration for the GenericResults type
type moqGenericResults_Usual_paramIndexing struct {
	param1 moq.ParamIndexing
	param2 moq.ParamIndexing
}

// moqGenericResults_Usual_doFn defines the type of function needed when
// calling andDo for the GenericResults type
type moqGenericResults_Usual_doFn[S ~string, E error] func(string, bool)

// moqGenericResults_Usual_doReturnFn defines the type of function needed when
// calling doReturnResults for the GenericResults type
type moqGenericResults_Usual_doReturnFn[S ~string, E error] func(string, bool) (S, E)

// moqGenericResults_Usual_recorder routes recorded function calls to the
// moqGenericResults moq
type moqGenericResults_Usual_recorder[S ~string, E error] struct {
	recorder *impl.Recorder[
		*moqGenericResults_Usual_adaptor[S, E],
		moqGenericResults_Usual_params[S, E],
		moqGenericResults_Usual_paramsKey[S, E],
		moqGenericResults_Usual_results[S, E]]
}

// moqGenericResults_Usual_anyParams isolates the any params functions of the
// GenericResults type
type moqGenericResults_Usual_anyParams[S ~string, E error] struct {
	recorder *moqGenericResults_Usual_recorder[S, E]
}

// newMoqGenericResults creates a new moq of the GenericResults type
func newMoqGenericResults[S ~string, E error](scene *moq.Scene, config *moq.Config) *moqGenericResults[S, E] {
	adaptor1 := &moqGenericResults_Usual_adaptor[S, E]{}
	m := &moqGenericResults[S, E]{
		moq: &moqGenericResults_mock[S, E]{},

		moq_Usual: impl.NewMoq[
			*moqGenericResults_Usual_adaptor[S, E],
			moqGenericResults_Usual_params[S, E],
			moqGenericResults_Usual_paramsKey[S, E],
			moqGenericResults_Usual_results[S, E]](scene, adaptor1, config),

		runtime: moqGenericResults_runtime{parameterIndexing: struct {
			Usual moqGenericResults_Usual_paramIndexing
		}{
			Usual: moqGenericResults_Usual_paramIndexing{
				param1: moq.ParamIndexByValue,
				param2: moq.ParamIndexByValue,
			},
		}},
	}
	m.moq.moq = m

	adaptor1.moq = m

	scene.AddMoq(m)
	return m
}

// mock returns the mock implementation of the GenericResults type
func (m *moqGenericResults[S, E]) mock() *moqGenericResults_mock[S, E] { return m.moq }

func (m *moqGenericResults_mock[S, E]) Usual(param1 string, param2 bool) (S, E) {
	m.moq.moq_Usual.Scene.T.Helper()
	params := moqGenericResults_Usual_params[S, E]{
		param1: param1,
		param2: param2,
	}

	var result1 S
	var result2 E
	if result := m.moq.moq_Usual.Function(params); result != nil {
		result1 = result.result1
		result2 = result.result2
	}
	return result1, result2
}

// onCall returns the recorder implementation of the GenericResults type
func (m *moqGenericResults[S, E]) onCall() *moqGenericResults_recorder[S, E] {
	return &moqGenericResults_recorder[S, E]{
		moq: m,
	}
}

func (m *moqGenericResults_recorder[S, E]) Usual(param1 string, param2 bool) *moqGenericResults_Usual_recorder[S, E] {
	return &moqGenericResults_Usual_recorder[S, E]{
		recorder: m.moq.moq_Usual.OnCall(moqGenericResults_Usual_params[S, E]{
			param1: param1,
			param2: param2,
		}),
	}
}

func (r *moqGenericResults_Usual_recorder[S, E]) any() *moqGenericResults_Usual_anyParams[S, E] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqGenericResults_Usual_anyParams[S, E]{recorder: r}
}

func (a *moqGenericResults_Usual_anyParams[S, E]) param1() *moqGenericResults_Usual_recorder[S, E] {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (a *moqGenericResults_Usual_anyParams[S, E]) param2() *moqGenericResults_Usual_recorder[S, E] {
	a.recorder.recorder.AnyParam(2)
	return a.recorder
}

func (r *moqGenericResults_Usual_recorder[S, E]) seq() *moqGenericResults_Usual_recorder[S, E] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqGenericResults_Usual_recorder[S, E]) noSeq() *moqGenericResults_Usual_recorder[S, E] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqGenericResults_Usual_recorder[S, E]) returnResults(result1 S, result2 E) *moqGenericResults_Usual_recorder[S, E] {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqGenericResults_Usual_results[S, E]{
		result1: result1,
		result2: result2,
	})
	return r
}

func (r *moqGenericResults_Usual_recorder[S, E]) andDo(fn moqGenericResults_Usual_doFn[S, E]) *moqGenericResults_Usual_recorder[S, E] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqGenericResults_Usual_params[S, E]) {
		fn(params.param1, params.param2)
	}, false) {
		return nil
	}
	return r
}

func (r *moqGenericResults_Usual_recorder[S, E]) doReturnResults(fn moqGenericResults_Usual_doReturnFn[S, E]) *moqGenericResults_Usual_recorder[S, E] {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqGenericResults_Usual_params[S, E]) *moqGenericResults_Usual_results[S, E] {
		result1, result2 := fn(params.param1, params.param2)
		return &moqGenericResults_Usual_results[S, E]{
			result1: result1,
			result2: result2,
		}
	})
	return r
}

func (r *moqGenericResults_Usual_recorder[S, E]) repeat(repeaters ...moq.Repeater) *moqGenericResults_Usual_recorder[S, E] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqGenericResults_Usual_adaptor[S, E]) PrettyParams(params moqGenericResults_Usual_params[S, E]) string {
	return fmt.Sprintf("Usual(%#v, %#v)", params.param1, params.param2)
}

func (a *moqGenericResults_Usual_adaptor[S, E]) ParamsKey(params moqGenericResults_Usual_params[S, E], anyParams uint64) moqGenericResults_Usual_paramsKey[S, E] {
	a.moq.moq_Usual.Scene.T.Helper()
	param1Used, param1UsedHash := impl.ParamKey(
		params.param1, 1, a.moq.runtime.parameterIndexing.Usual.param1, anyParams)
	param2Used, param2UsedHash := impl.ParamKey(
		params.param2, 2, a.moq.runtime.parameterIndexing.Usual.param2, anyParams)
	return moqGenericResults_Usual_paramsKey[S, E]{
		params: struct {
			param1 string
			param2 bool
		}{
			param1: param1Used,
			param2: param2Used,
		},
		hashes: struct {
			param1 hash.Hash
			param2 hash.Hash
		}{
			param1: param1UsedHash,
			param2: param2UsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *moqGenericResults[S, E]) Reset() {
	m.moq_Usual.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *moqGenericResults[S, E]) AssertExpectationsMet() {
	m.moq_Usual.Scene.T.Helper()
	m.moq_Usual.AssertExpectationsMet()
}

// The following type assertion assures that testmoqs.PartialGenericResults is
// mocked completely
var _ testmoqs.PartialGenericResults[string] = (*moqPartialGenericResults_mock[string])(nil)

// moqPartialGenericResults holds the state of a moq of the
// PartialGenericResults type
type moqPartialGenericResults[S ~string] struct {
	moq *moqPartialGenericResults_mock[S]

	moq_Usual *impl.Moq[
		*moqPartialGenericResults_Usual_adaptor[S],
		moqPartialGenericResults_Usual_params[S],
		moqPartialGenericResults_Usual_paramsKey[S],
		moqPartialGenericResults_Usual_results[S]]

	runtime moqPartialGenericResults_runtime
}

// moqPartialGenericResults_mock isolates the mock interface of the
// PartialGenericResults type
type moqPartialGenericResults_mock[S ~string] struct {
	moq *moqPartialGenericResults[S]
}

// moqPartialGenericResults_recorder isolates the recorder interface of the
// PartialGenericResults type
type moqPartialGenericResults_recorder[S ~string] struct {
	moq *moqPartialGenericResults[S]
}

// moqPartialGenericResults_runtime holds runtime configuration for the
// PartialGenericResults type
type moqPartialGenericResults_runtime struct {
	parameterIndexing struct {
		Usual moqPartialGenericResults_Usual_paramIndexing
	}
}

// moqPartialGenericResults_Usual_adaptor adapts moqPartialGenericResults as
// needed by the runtime
type moqPartialGenericResults_Usual_adaptor[S ~string] struct {
	moq *moqPartialGenericResults[S]
}

// moqPartialGenericResults_Usual_params holds the params of the
// PartialGenericResults type
type moqPartialGenericResults_Usual_params[S ~string] struct {
	param1 string
	param2 bool
}

// moqPartialGenericResults_Usual_paramsKey holds the map key params of the
// PartialGenericResults type
type moqPartialGenericResults_Usual_paramsKey[S ~string] struct {
	params struct {
		param1 string
		param2 bool
	}
	hashes struct {
		param1 hash.Hash
		param2 hash.Hash
	}
}

// moqPartialGenericResults_Usual_results holds the results of the
// PartialGenericResults type
type moqPartialGenericResults_Usual_results[S ~string] struct {
	result1 S
	result2 error
}

// moqPartialGenericResults_Usual_paramIndexing holds the parameter indexing
// runtime configuration for the PartialGenericResults type
type moqPartialGenericResults_Usual_paramIndexing struct {
	param1 moq.ParamIndexing
	param2 moq.ParamIndexing
}

// moqPartialGenericResults_Usual_doFn defines the type of function needed when
// calling andDo for the PartialGenericResults type
type moqPartialGenericResults_Usual_doFn[S ~string] func(string, bool)

// moqPartialGenericResults_Usual_doReturnFn defines the type of function
// needed when calling doReturnResults for the PartialGenericResults type
type moqPartialGenericResults_Usual_doReturnFn[S ~string] func(string, bool) (S, error)

// moqPartialGenericResults_Usual_recorder routes recorded function calls to
// the moqPartialGenericResults moq
type moqPartialGenericResults_Usual_recorder[S ~string] struct {
	recorder *impl.Recorder[
		*moqPartialGenericResults_Usual_adaptor[S],
		moqPartialGenericResults_Usual_params[S],
		moqPartialGenericResults_Usual_paramsKey[S],
		moqPartialGenericResults_Usual_results[S]]
}

// moqPartialGenericResults_Usual_anyParams isolates the any params functions
// of the PartialGenericResults type
type moqPartialGenericResults_Usual_anyParams[S ~string] struct {
	recorder *moqPartialGenericResults_Usual_recorder[S]
}

// newMoqPartialGenericResults creates a new moq of the PartialGenericResults
// type
func newMoqPartialGenericResults[S ~string](scene *moq.Scene, config *moq.Config) *moqPartialGenericResults[S] {
	adaptor1 := &moqPartialGenericResults_Usual_adaptor[S]{}
	m := &moqPartialGenericResults[S]{
		moq: &moqPartialGenericResults_mock[S]{},

		moq_Usual: impl.NewMoq[
			*moqPartialGenericResults_Usual_adaptor[S],
			moqPartialGenericResults_Usual_params[S],
			moqPartialGenericResults_Usual_paramsKey[S],
			moqPartialGenericResults_Usual_results[S]](scene, adaptor1, config),

		runtime: moqPartialGenericResults_runtime{parameterIndexing: struct {
			Usual moqPartialGenericResults_Usual_paramIndexing
		}{
			Usual: moqPartialGenericResults_Usual_paramIndexing{
				param1: moq.ParamIndexByValue,
				param2: moq.ParamIndexByValue,
			},
		}},
	}
	m.moq.moq = m

	adaptor1.moq = m

	scene.AddMoq(m)
	return m
}

// mock returns the mock implementation of the PartialGenericResults type
func (m *moqPartialGenericResults[S]) mock() *moqPartialGenericResults_mock[S] { return m.moq }

func (m *moqPartialGenericResults_mock[S]) Usual(param1 string, param2 bool) (S, error) {
	m.moq.moq_Usual.Scene.T.Helper()
	params := moqPartialGenericResults_Usual_params[S]{
		param1: param1,
		param2: param2,
	}

	var result1 S
	var result2 error
	if result := m.moq.moq_Usual.Function(params); result != nil {
		result1 = result.result1
		result2 = result.result2
	}
	return result1, result2
}

// onCall returns the recorder implementation of the PartialGenericResults type
func (m *moqPartialGenericResults[S]) onCall() *moqPartialGenericResults_recorder[S] {
	return &moqPartialGenericResults_recorder[S]{
		moq: m,
	}
}

func (m *moqPartialGenericResults_recorder[S]) Usual(param1 string, param2 bool) *moqPartialGenericResults_Usual_recorder[S] {
	return &moqPartialGenericResults_Usual_recorder[S]{
		recorder: m.moq.moq_Usual.OnCall(moqPartialGenericResults_Usual_params[S]{
			param1: param1,
			param2: param2,
		}),
	}
}

func (r *moqPartialGenericResults_Usual_recorder[S]) any() *moqPartialGenericResults_Usual_anyParams[S] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqPartialGenericResults_Usual_anyParams[S]{recorder: r}
}

func (a *moqPartialGenericResults_Usual_anyParams[S]) param1() *moqPartialGenericResults_Usual_recorder[S] {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (a *moqPartialGenericResults_Usual_anyParams[S]) param2() *moqPartialGenericResults_Usual_recorder[S] {
	a.recorder.recorder.AnyParam(2)
	return a.recorder
}

func (r *moqPartialGenericResults_Usual_recorder[S]) seq() *moqPartialGenericResults_Usual_recorder[S] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqPartialGenericResults_Usual_recorder[S]) noSeq() *moqPartialGenericResults_Usual_recorder[S] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqPartialGenericResults_Usual_recorder[S]) returnResults(result1 S, result2 error) *moqPartialGenericResults_Usual_recorder[S] {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqPartialGenericResults_Usual_results[S]{
		result1: result1,
		result2: result2,
	})
	return r
}

func (r *moqPartialGenericResults_Usual_recorder[S]) andDo(fn moqPartialGenericResults_Usual_doFn[S]) *moqPartialGenericResults_Usual_recorder[S] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqPartialGenericResults_Usual_params[S]) {
		fn(params.param1, params.param2)
	}, false) {
		return nil
	}
	return r
}

func (r *moqPartialGenericResults_Usual_recorder[S]) doReturnResults(fn moqPartialGenericResults_Usual_doReturnFn[S]) *moqPartialGenericResults_Usual_recorder[S] {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqPartialGenericResults_Usual_params[S]) *moqPartialGenericResults_Usual_results[S] {
		result1, result2 := fn(params.param1, params.param2)
		return &moqPartialGenericResults_Usual_results[S]{
			result1: result1,
			result2: result2,
		}
	})
	return r
}

func (r *moqPartialGenericResults_Usual_recorder[S]) repeat(repeaters ...moq.Repeater) *moqPartialGenericResults_Usual_recorder[S] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqPartialGenericResults_Usual_adaptor[S]) PrettyParams(params moqPartialGenericResults_Usual_params[S]) string {
	return fmt.Sprintf("Usual(%#v, %#v)", params.param1, params.param2)
}

func (a *moqPartialGenericResults_Usual_adaptor[S]) ParamsKey(params moqPartialGenericResults_Usual_params[S], anyParams uint64) moqPartialGenericResults_Usual_paramsKey[S] {
	a.moq.moq_Usual.Scene.T.Helper()
	param1Used, param1UsedHash := impl.ParamKey(
		params.param1, 1, a.moq.runtime.parameterIndexing.Usual.param1, anyParams)
	param2Used, param2UsedHash := impl.ParamKey(
		params.param2, 2, a.moq.runtime.parameterIndexing.Usual.param2, anyParams)
	return moqPartialGenericResults_Usual_paramsKey[S]{
		params: struct {
			param1 string
			param2 bool
		}{
			param1: param1Used,
			param2: param2Used,
		},
		hashes: struct {
			param1 hash.Hash
			param2 hash.Hash
		}{
			param1: param1UsedHash,
			param2: param2UsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *moqPartialGenericResults[S]) Reset() {
	m.moq_Usual.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *moqPartialGenericResults[S]) AssertExpectationsMet() {
	m.moq_Usual.Scene.T.Helper()
	m.moq_Usual.AssertExpectationsMet()
}

// The following type assertion assures that testmoqs.GenericInterfaceParam is
// mocked completely
var _ testmoqs.GenericInterfaceParam[testmoqs.MyWriter] = (*moqGenericInterfaceParam_mock[testmoqs.MyWriter])(nil)

// moqGenericInterfaceParam holds the state of a moq of the
// GenericInterfaceParam type
type moqGenericInterfaceParam[W testmoqs.MyWriter] struct {
	moq *moqGenericInterfaceParam_mock[W]

	moq_Usual *impl.Moq[
		*moqGenericInterfaceParam_Usual_adaptor[W],
		moqGenericInterfaceParam_Usual_params[W],
		moqGenericInterfaceParam_Usual_paramsKey[W],
		moqGenericInterfaceParam_Usual_results[W]]

	runtime moqGenericInterfaceParam_runtime
}

// moqGenericInterfaceParam_mock isolates the mock interface of the
// GenericInterfaceParam type
type moqGenericInterfaceParam_mock[W testmoqs.MyWriter] struct {
	moq *moqGenericInterfaceParam[W]
}

// moqGenericInterfaceParam_recorder isolates the recorder interface of the
// GenericInterfaceParam type
type moqGenericInterfaceParam_recorder[W testmoqs.MyWriter] struct {
	moq *moqGenericInterfaceParam[W]
}

// moqGenericInterfaceParam_runtime holds runtime configuration for the
// GenericInterfaceParam type
type moqGenericInterfaceParam_runtime struct {
	parameterIndexing struct {
		Usual moqGenericInterfaceParam_Usual_paramIndexing
	}
}

// moqGenericInterfaceParam_Usual_adaptor adapts moqGenericInterfaceParam as
// needed by the runtime
type moqGenericInterfaceParam_Usual_adaptor[W testmoqs.MyWriter] struct {
	moq *moqGenericInterfaceParam[W]
}

// moqGenericInterfaceParam_Usual_params holds the params of the
// GenericInterfaceParam type
type moqGenericInterfaceParam_Usual_params[W testmoqs.MyWriter] struct{ w W }

// moqGenericInterfaceParam_Usual_paramsKey holds the map key params of the
// GenericInterfaceParam type
type moqGenericInterfaceParam_Usual_paramsKey[W testmoqs.MyWriter] struct {
	params struct{}
	hashes struct{ w hash.Hash }
}

// moqGenericInterfaceParam_Usual_results holds the results of the
// GenericInterfaceParam type
type moqGenericInterfaceParam_Usual_results[W testmoqs.MyWriter] struct {
	sResult string
	err     error
}

// moqGenericInterfaceParam_Usual_paramIndexing holds the parameter indexing
// runtime configuration for the GenericInterfaceParam type
type moqGenericInterfaceParam_Usual_paramIndexing struct {
	w moq.ParamIndexing
}

// moqGenericInterfaceParam_Usual_doFn defines the type of function needed when
// calling andDo for the GenericInterfaceParam type
type moqGenericInterfaceParam_Usual_doFn[W testmoqs.MyWriter] func(w W)

// moqGenericInterfaceParam_Usual_doReturnFn defines the type of function
// needed when calling doReturnResults for the GenericInterfaceParam type
type moqGenericInterfaceParam_Usual_doReturnFn[W testmoqs.MyWriter] func(w W) (sResult string, err error)

// moqGenericInterfaceParam_Usual_recorder routes recorded function calls to
// the moqGenericInterfaceParam moq
type moqGenericInterfaceParam_Usual_recorder[W testmoqs.MyWriter] struct {
	recorder *impl.Recorder[
		*moqGenericInterfaceParam_Usual_adaptor[W],
		moqGenericInterfaceParam_Usual_params[W],
		moqGenericInterfaceParam_Usual_paramsKey[W],
		moqGenericInterfaceParam_Usual_results[W]]
}

// moqGenericInterfaceParam_Usual_anyParams isolates the any params functions
// of the GenericInterfaceParam type
type moqGenericInterfaceParam_Usual_anyParams[W testmoqs.MyWriter] struct {
	recorder *moqGenericInterfaceParam_Usual_recorder[W]
}

// newMoqGenericInterfaceParam creates a new moq of the GenericInterfaceParam
// type
func newMoqGenericInterfaceParam[W testmoqs.MyWriter](scene *moq.Scene, config *moq.Config) *moqGenericInterfaceParam[W] {
	adaptor1 := &moqGenericInterfaceParam_Usual_adaptor[W]{}
	m := &moqGenericInterfaceParam[W]{
		moq: &moqGenericInterfaceParam_mock[W]{},

		moq_Usual: impl.NewMoq[
			*moqGenericInterfaceParam_Usual_adaptor[W],
			moqGenericInterfaceParam_Usual_params[W],
			moqGenericInterfaceParam_Usual_paramsKey[W],
			moqGenericInterfaceParam_Usual_results[W]](scene, adaptor1, config),

		runtime: moqGenericInterfaceParam_runtime{parameterIndexing: struct {
			Usual moqGenericInterfaceParam_Usual_paramIndexing
		}{
			Usual: moqGenericInterfaceParam_Usual_paramIndexing{
				w: moq.ParamIndexByHash,
			},
		}},
	}
	m.moq.moq = m

	adaptor1.moq = m

	scene.AddMoq(m)
	return m
}

// mock returns the mock implementation of the GenericInterfaceParam type
func (m *moqGenericInterfaceParam[W]) mock() *moqGenericInterfaceParam_mock[W] { return m.moq }

func (m *moqGenericInterfaceParam_mock[W]) Usual(w W) (string, error) {
	m.moq.moq_Usual.Scene.T.Helper()
	params := moqGenericInterfaceParam_Usual_params[W]{
		w: w,
	}

	var result1 string
	var result2 error
	if result := m.moq.moq_Usual.Function(params); result != nil {
		result1 = result.sResult
		result2 = result.err
	}
	return result1, result2
}

// onCall returns the recorder implementation of the GenericInterfaceParam type
func (m *moqGenericInterfaceParam[W]) onCall() *moqGenericInterfaceParam_recorder[W] {
	return &moqGenericInterfaceParam_recorder[W]{
		moq: m,
	}
}

func (m *moqGenericInterfaceParam_recorder[W]) Usual(w W) *moqGenericInterfaceParam_Usual_recorder[W] {
	return &moqGenericInterfaceParam_Usual_recorder[W]{
		recorder: m.moq.moq_Usual.OnCall(moqGenericInterfaceParam_Usual_params[W]{
			w: w,
		}),
	}
}

func (r *moqGenericInterfaceParam_Usual_recorder[W]) any() *moqGenericInterfaceParam_Usual_anyParams[W] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqGenericInterfaceParam_Usual_anyParams[W]{recorder: r}
}

func (a *moqGenericInterfaceParam_Usual_anyParams[W]) w() *moqGenericInterfaceParam_Usual_recorder[W] {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (r *moqGenericInterfaceParam_Usual_recorder[W]) seq() *moqGenericInterfaceParam_Usual_recorder[W] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqGenericInterfaceParam_Usual_recorder[W]) noSeq() *moqGenericInterfaceParam_Usual_recorder[W] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqGenericInterfaceParam_Usual_recorder[W]) returnResults(sResult string, err error) *moqGenericInterfaceParam_Usual_recorder[W] {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqGenericInterfaceParam_Usual_results[W]{
		sResult: sResult,
		err:     err,
	})
	return r
}

func (r *moqGenericInterfaceParam_Usual_recorder[W]) andDo(fn moqGenericInterfaceParam_Usual_doFn[W]) *moqGenericInterfaceParam_Usual_recorder[W] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqGenericInterfaceParam_Usual_params[W]) {
		fn(params.w)
	}, false) {
		return nil
	}
	return r
}

func (r *moqGenericInterfaceParam_Usual_recorder[W]) doReturnResults(fn moqGenericInterfaceParam_Usual_doReturnFn[W]) *moqGenericInterfaceParam_Usual_recorder[W] {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqGenericInterfaceParam_Usual_params[W]) *moqGenericInterfaceParam_Usual_results[W] {
		sResult, err := fn(params.w)
		return &moqGenericInterfaceParam_Usual_results[W]{
			sResult: sResult,
			err:     err,
		}
	})
	return r
}

func (r *moqGenericInterfaceParam_Usual_recorder[W]) repeat(repeaters ...moq.Repeater) *moqGenericInterfaceParam_Usual_recorder[W] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqGenericInterfaceParam_Usual_adaptor[W]) PrettyParams(params moqGenericInterfaceParam_Usual_params[W]) string {
	return fmt.Sprintf("Usual(%#v)", params.w)
}

func (a *moqGenericInterfaceParam_Usual_adaptor[W]) ParamsKey(params moqGenericInterfaceParam_Usual_params[W], anyParams uint64) moqGenericInterfaceParam_Usual_paramsKey[W] {
	a.moq.moq_Usual.Scene.T.Helper()
	wUsedHash := impl.HashOnlyParamKey(a.moq.moq_Usual.Scene.T,
		params.w, "w", 1, a.moq.runtime.parameterIndexing.Usual.w, anyParams)
	return moqGenericInterfaceParam_Usual_paramsKey[W]{
		params: struct{}{},
		hashes: struct{ w hash.Hash }{
			w: wUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *moqGenericInterfaceParam[W]) Reset() {
	m.moq_Usual.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *moqGenericInterfaceParam[W]) AssertExpectationsMet() {
	m.moq_Usual.Scene.T.Helper()
	m.moq_Usual.AssertExpectationsMet()
}

// The following type assertion assures that testmoqs.GenericInterfaceResult is
// mocked completely
var _ testmoqs.GenericInterfaceResult[testmoqs.MyReader] = (*moqGenericInterfaceResult_mock[testmoqs.MyReader])(nil)

// moqGenericInterfaceResult holds the state of a moq of the
// GenericInterfaceResult type
type moqGenericInterfaceResult[R testmoqs.MyReader] struct {
	moq *moqGenericInterfaceResult_mock[R]

	moq_Usual *impl.Moq[
		*moqGenericInterfaceResult_Usual_adaptor[R],
		moqGenericInterfaceResult_Usual_params[R],
		moqGenericInterfaceResult_Usual_paramsKey[R],
		moqGenericInterfaceResult_Usual_results[R]]

	runtime moqGenericInterfaceResult_runtime
}

// moqGenericInterfaceResult_mock isolates the mock interface of the
// GenericInterfaceResult type
type moqGenericInterfaceResult_mock[R testmoqs.MyReader] struct {
	moq *moqGenericInterfaceResult[R]
}

// moqGenericInterfaceResult_recorder isolates the recorder interface of the
// GenericInterfaceResult type
type moqGenericInterfaceResult_recorder[R testmoqs.MyReader] struct {
	moq *moqGenericInterfaceResult[R]
}

// moqGenericInterfaceResult_runtime holds runtime configuration for the
// GenericInterfaceResult type
type moqGenericInterfaceResult_runtime struct {
	parameterIndexing struct {
		Usual moqGenericInterfaceResult_Usual_paramIndexing
	}
}

// moqGenericInterfaceResult_Usual_adaptor adapts moqGenericInterfaceResult as
// needed by the runtime
type moqGenericInterfaceResult_Usual_adaptor[R testmoqs.MyReader] struct {
	moq *moqGenericInterfaceResult[R]
}

// moqGenericInterfaceResult_Usual_params holds the params of the
// GenericInterfaceResult type
type moqGenericInterfaceResult_Usual_params[R testmoqs.MyReader] struct {
	sParam string
	bParam bool
}

// moqGenericInterfaceResult_Usual_paramsKey holds the map key params of the
// GenericInterfaceResult type
type moqGenericInterfaceResult_Usual_paramsKey[R testmoqs.MyReader] struct {
	params struct {
		sParam string
		bParam bool
	}
	hashes struct {
		sParam hash.Hash
		bParam hash.Hash
	}
}

// moqGenericInterfaceResult_Usual_results holds the results of the
// GenericInterfaceResult type
type moqGenericInterfaceResult_Usual_results[R testmoqs.MyReader] struct{ result1 R }

// moqGenericInterfaceResult_Usual_paramIndexing holds the parameter indexing
// runtime configuration for the GenericInterfaceResult type
type moqGenericInterfaceResult_Usual_paramIndexing struct {
	sParam moq.ParamIndexing
	bParam moq.ParamIndexing
}

// moqGenericInterfaceResult_Usual_doFn defines the type of function needed
// when calling andDo for the GenericInterfaceResult type
type moqGenericInterfaceResult_Usual_doFn[R testmoqs.MyReader] func(sParam string, bParam bool)

// moqGenericInterfaceResult_Usual_doReturnFn defines the type of function
// needed when calling doReturnResults for the GenericInterfaceResult type
type moqGenericInterfaceResult_Usual_doReturnFn[R testmoqs.MyReader] func(sParam string, bParam bool) (r R)

// moqGenericInterfaceResult_Usual_recorder routes recorded function calls to
// the moqGenericInterfaceResult moq
type moqGenericInterfaceResult_Usual_recorder[R testmoqs.MyReader] struct {
	recorder *impl.Recorder[
		*moqGenericInterfaceResult_Usual_adaptor[R],
		moqGenericInterfaceResult_Usual_params[R],
		moqGenericInterfaceResult_Usual_paramsKey[R],
		moqGenericInterfaceResult_Usual_results[R]]
}

// moqGenericInterfaceResult_Usual_anyParams isolates the any params functions
// of the GenericInterfaceResult type
type moqGenericInterfaceResult_Usual_anyParams[R testmoqs.MyReader] struct {
	recorder *moqGenericInterfaceResult_Usual_recorder[R]
}

// newMoqGenericInterfaceResult creates a new moq of the GenericInterfaceResult
// type
func newMoqGenericInterfaceResult[R testmoqs.MyReader](scene *moq.Scene, config *moq.Config) *moqGenericInterfaceResult[R] {
	adaptor1 := &moqGenericInterfaceResult_Usual_adaptor[R]{}
	m := &moqGenericInterfaceResult[R]{
		moq: &moqGenericInterfaceResult_mock[R]{},

		moq_Usual: impl.NewMoq[
			*moqGenericInterfaceResult_Usual_adaptor[R],
			moqGenericInterfaceResult_Usual_params[R],
			moqGenericInterfaceResult_Usual_paramsKey[R],
			moqGenericInterfaceResult_Usual_results[R]](scene, adaptor1, config),

		runtime: moqGenericInterfaceResult_runtime{parameterIndexing: struct {
			Usual moqGenericInterfaceResult_Usual_paramIndexing
		}{
			Usual: moqGenericInterfaceResult_Usual_paramIndexing{
				sParam: moq.ParamIndexByValue,
				bParam: moq.ParamIndexByValue,
			},
		}},
	}
	m.moq.moq = m

	adaptor1.moq = m

	scene.AddMoq(m)
	return m
}

// mock returns the mock implementation of the GenericInterfaceResult type
func (m *moqGenericInterfaceResult[R]) mock() *moqGenericInterfaceResult_mock[R] { return m.moq }

func (m *moqGenericInterfaceResult_mock[R]) Usual(sParam string, bParam bool) R {
	m.moq.moq_Usual.Scene.T.Helper()
	params := moqGenericInterfaceResult_Usual_params[R]{
		sParam: sParam,
		bParam: bParam,
	}

	var result1 R
	if result := m.moq.moq_Usual.Function(params); result != nil {
		result1 = result.result1
	}
	return result1
}

// onCall returns the recorder implementation of the GenericInterfaceResult
// type
func (m *moqGenericInterfaceResult[R]) onCall() *moqGenericInterfaceResult_recorder[R] {
	return &moqGenericInterfaceResult_recorder[R]{
		moq: m,
	}
}

func (m *moqGenericInterfaceResult_recorder[R]) Usual(sParam string, bParam bool) *moqGenericInterfaceResult_Usual_recorder[R] {
	return &moqGenericInterfaceResult_Usual_recorder[R]{
		recorder: m.moq.moq_Usual.OnCall(moqGenericInterfaceResult_Usual_params[R]{
			sParam: sParam,
			bParam: bParam,
		}),
	}
}

func (r *moqGenericInterfaceResult_Usual_recorder[R]) any() *moqGenericInterfaceResult_Usual_anyParams[R] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqGenericInterfaceResult_Usual_anyParams[R]{recorder: r}
}

func (a *moqGenericInterfaceResult_Usual_anyParams[R]) sParam() *moqGenericInterfaceResult_Usual_recorder[R] {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (a *moqGenericInterfaceResult_Usual_anyParams[R]) bParam() *moqGenericInterfaceResult_Usual_recorder[R] {
	a.recorder.recorder.AnyParam(2)
	return a.recorder
}

func (r *moqGenericInterfaceResult_Usual_recorder[R]) seq() *moqGenericInterfaceResult_Usual_recorder[R] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqGenericInterfaceResult_Usual_recorder[R]) noSeq() *moqGenericInterfaceResult_Usual_recorder[R] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqGenericInterfaceResult_Usual_recorder[R]) returnResults(result1 R) *moqGenericInterfaceResult_Usual_recorder[R] {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqGenericInterfaceResult_Usual_results[R]{
		result1: result1,
	})
	return r
}

func (r *moqGenericInterfaceResult_Usual_recorder[R]) andDo(fn moqGenericInterfaceResult_Usual_doFn[R]) *moqGenericInterfaceResult_Usual_recorder[R] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqGenericInterfaceResult_Usual_params[R]) {
		fn(params.sParam, params.bParam)
	}, false) {
		return nil
	}
	return r
}

func (r *moqGenericInterfaceResult_Usual_recorder[R]) doReturnResults(fn moqGenericInterfaceResult_Usual_doReturnFn[R]) *moqGenericInterfaceResult_Usual_recorder[R] {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqGenericInterfaceResult_Usual_params[R]) *moqGenericInterfaceResult_Usual_results[R] {
		result1 := fn(params.sParam, params.bParam)
		return &moqGenericInterfaceResult_Usual_results[R]{
			result1: result1,
		}
	})
	return r
}

func (r *moqGenericInterfaceResult_Usual_recorder[R]) repeat(repeaters ...moq.Repeater) *moqGenericInterfaceResult_Usual_recorder[R] {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqGenericInterfaceResult_Usual_adaptor[R]) PrettyParams(params moqGenericInterfaceResult_Usual_params[R]) string {
	return fmt.Sprintf("Usual(%#v, %#v)", params.sParam, params.bParam)
}

func (a *moqGenericInterfaceResult_Usual_adaptor[R]) ParamsKey(params moqGenericInterfaceResult_Usual_params[R], anyParams uint64) moqGenericInterfaceResult_Usual_paramsKey[R] {
	a.moq.moq_Usual.Scene.T.Helper()
	sParamUsed, sParamUsedHash := impl.ParamKey(
		params.sParam, 1, a.moq.runtime.parameterIndexing.Usual.sParam, anyParams)
	bParamUsed, bParamUsedHash := impl.ParamKey(
		params.bParam, 2, a.moq.runtime.parameterIndexing.Usual.bParam, anyParams)
	return moqGenericInterfaceResult_Usual_paramsKey[R]{
		params: struct {
			sParam string
			bParam bool
		}{
			sParam: sParamUsed,
			bParam: bParamUsed,
		},
		hashes: struct {
			sParam hash.Hash
			bParam hash.Hash
		}{
			sParam: sParamUsedHash,
			bParam: bParamUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *moqGenericInterfaceResult[R]) Reset() {
	m.moq_Usual.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *moqGenericInterfaceResult[R]) AssertExpectationsMet() {
	m.moq_Usual.Scene.T.Helper()
	m.moq_Usual.AssertExpectationsMet()
}

// moqUnsafePointerFn holds the state of a moq of the UnsafePointerFn type
type moqUnsafePointerFn struct {
	moq *impl.Moq[
		*moqUnsafePointerFn_adaptor,
		moqUnsafePointerFn_params,
		moqUnsafePointerFn_paramsKey,
		moqUnsafePointerFn_results,
	]

	runtime moqUnsafePointerFn_runtime
}

// moqUnsafePointerFn_runtime holds runtime configuration for the
// UnsafePointerFn type
type moqUnsafePointerFn_runtime struct {
	parameterIndexing moqUnsafePointerFn_paramIndexing
}

// moqUnsafePointerFn_adaptor adapts moqUnsafePointerFn as needed by the
// runtime
type moqUnsafePointerFn_adaptor struct {
	moq *moqUnsafePointerFn
}

// moqUnsafePointerFn_params holds the params of the UnsafePointerFn type
type moqUnsafePointerFn_params struct{}

// moqUnsafePointerFn_paramsKey holds the map key params of the UnsafePointerFn
// type
type moqUnsafePointerFn_paramsKey struct {
	params struct{}
	hashes struct{}
}

// moqUnsafePointerFn_results holds the results of the UnsafePointerFn type
type moqUnsafePointerFn_results struct {
	result1 unsafe.Pointer
}

// moqUnsafePointerFn_paramIndexing holds the parameter indexing runtime
// configuration for the UnsafePointerFn type
type moqUnsafePointerFn_paramIndexing struct{}

// moqUnsafePointerFn_doFn defines the type of function needed when calling
// andDo for the UnsafePointerFn type
type moqUnsafePointerFn_doFn func()

// moqUnsafePointerFn_doReturnFn defines the type of function needed when
// calling doReturnResults for the UnsafePointerFn type
type moqUnsafePointerFn_doReturnFn func() unsafe.Pointer

// moqUnsafePointerFn_recorder routes recorded function calls to the
// moqUnsafePointerFn moq
type moqUnsafePointerFn_recorder struct {
	recorder *impl.Recorder[
		*moqUnsafePointerFn_adaptor,
		moqUnsafePointerFn_params,
		moqUnsafePointerFn_paramsKey,
		moqUnsafePointerFn_results,
	]
}

// moqUnsafePointerFn_anyParams isolates the any params functions of the
// UnsafePointerFn type
type moqUnsafePointerFn_anyParams struct {
	recorder *moqUnsafePointerFn_recorder
}

// newMoqUnsafePointerFn creates a new moq of the UnsafePointerFn type
func newMoqUnsafePointerFn(scene *moq.Scene, config *moq.Config) *moqUnsafePointerFn {
	adaptor1 := &moqUnsafePointerFn_adaptor{}
	m := &moqUnsafePointerFn{
		moq: impl.NewMoq[
			*moqUnsafePointerFn_adaptor,
			moqUnsafePointerFn_params,
			moqUnsafePointerFn_paramsKey,
			moqUnsafePointerFn_results,
		](scene, adaptor1, config),

		runtime: moqUnsafePointerFn_runtime{parameterIndexing: moqUnsafePointerFn_paramIndexing{}},
	}
	adaptor1.moq = m

	scene.AddMoq(m)
	return m
}

// mock returns the moq implementation of the UnsafePointerFn type
func (m *moqUnsafePointerFn) mock() testmoqs.UnsafePointerFn {
	return func() unsafe.Pointer {
		m.moq.Scene.T.Helper()
		params := moqUnsafePointerFn_params{}

		var result1 unsafe.Pointer
		if result := m.moq.Function(params); result != nil {
			result1 = result.result1
		}
		return result1
	}
}

func (m *moqUnsafePointerFn) onCall() *moqUnsafePointerFn_recorder {
	return &moqUnsafePointerFn_recorder{
		recorder: m.moq.OnCall(moqUnsafePointerFn_params{}),
	}
}

func (r *moqUnsafePointerFn_recorder) any() *moqUnsafePointerFn_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqUnsafePointerFn_anyParams{recorder: r}
}

func (r *moqUnsafePointerFn_recorder) seq() *moqUnsafePointerFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqUnsafePointerFn_recorder) noSeq() *moqUnsafePointerFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqUnsafePointerFn_recorder) returnResults(result1 unsafe.Pointer) *moqUnsafePointerFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqUnsafePointerFn_results{
		result1: result1,
	})
	return r
}

func (r *moqUnsafePointerFn_recorder) andDo(fn moqUnsafePointerFn_doFn) *moqUnsafePointerFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqUnsafePointerFn_params) {
		fn()
	}, false) {
		return nil
	}
	return r
}

func (r *moqUnsafePointerFn_recorder) doReturnResults(fn moqUnsafePointerFn_doReturnFn) *moqUnsafePointerFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqUnsafePointerFn_params) *moqUnsafePointerFn_results {
		result1 := fn()
		return &moqUnsafePointerFn_results{
			result1: result1,
		}
	})
	return r
}

func (r *moqUnsafePointerFn_recorder) repeat(repeaters ...moq.Repeater) *moqUnsafePointerFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqUnsafePointerFn_adaptor) PrettyParams(params moqUnsafePointerFn_params) string {
	return fmt.Sprintf("UnsafePointerFn()")
}

func (a *moqUnsafePointerFn_adaptor) ParamsKey(params moqUnsafePointerFn_params, anyParams uint64) moqUnsafePointerFn_paramsKey {
	a.moq.moq.Scene.T.Helper()
	return moqUnsafePointerFn_paramsKey{
		params: struct{}{},
		hashes: struct{}{},
	}
}

// Reset resets the state of the moq
func (m *moqUnsafePointerFn) Reset() {
	m.moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *moqUnsafePointerFn) AssertExpectationsMet() {
	m.moq.Scene.T.Helper()
	m.moq.AssertExpectationsMet()
}
