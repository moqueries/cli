// Code generated by Moqueries - https://moqueries.org - DO NOT EDIT.

package exported

import (
	"fmt"
	"io"
	"unsafe"

	"moqueries.org/cli/generator/testmoqs"
	"moqueries.org/cli/generator/testmoqs/other"
	"moqueries.org/runtime/hash"
	"moqueries.org/runtime/impl"
	"moqueries.org/runtime/moq"
)

// MoqUsualFn holds the state of a moq of the UsualFn type
type MoqUsualFn struct {
	Moq *impl.Moq[
		*MoqUsualFn_adaptor,
		MoqUsualFn_params,
		MoqUsualFn_paramsKey,
		MoqUsualFn_results,
	]

	Runtime MoqUsualFn_runtime
}

// MoqUsualFn_runtime holds runtime configuration for the UsualFn type
type MoqUsualFn_runtime struct {
	ParameterIndexing MoqUsualFn_paramIndexing
}

// MoqUsualFn_adaptor adapts MoqUsualFn as needed by the runtime
type MoqUsualFn_adaptor struct {
	Moq *MoqUsualFn
}

// MoqUsualFn_params holds the params of the UsualFn type
type MoqUsualFn_params struct {
	SParam string
	BParam bool
}

// MoqUsualFn_paramsKey holds the map key params of the UsualFn type
type MoqUsualFn_paramsKey struct {
	Params struct {
		SParam string
		BParam bool
	}
	Hashes struct {
		SParam hash.Hash
		BParam hash.Hash
	}
}

// MoqUsualFn_results holds the results of the UsualFn type
type MoqUsualFn_results struct {
	SResult string
	Err     error
}

// MoqUsualFn_paramIndexing holds the parameter indexing runtime configuration
// for the UsualFn type
type MoqUsualFn_paramIndexing struct {
	SParam moq.ParamIndexing
	BParam moq.ParamIndexing
}

// MoqUsualFn_doFn defines the type of function needed when calling AndDo for
// the UsualFn type
type MoqUsualFn_doFn func(sParam string, bParam bool)

// MoqUsualFn_doReturnFn defines the type of function needed when calling
// DoReturnResults for the UsualFn type
type MoqUsualFn_doReturnFn func(sParam string, bParam bool) (sResult string, err error)

// MoqUsualFn_recorder routes recorded function calls to the MoqUsualFn moq
type MoqUsualFn_recorder struct {
	Recorder *impl.Recorder[
		*MoqUsualFn_adaptor,
		MoqUsualFn_params,
		MoqUsualFn_paramsKey,
		MoqUsualFn_results,
	]
}

// MoqUsualFn_anyParams isolates the any params functions of the UsualFn type
type MoqUsualFn_anyParams struct {
	Recorder *MoqUsualFn_recorder
}

// NewMoqUsualFn creates a new moq of the UsualFn type
func NewMoqUsualFn(scene *moq.Scene, config *moq.Config) *MoqUsualFn {
	adaptor1 := &MoqUsualFn_adaptor{}
	m := &MoqUsualFn{
		Moq: impl.NewMoq[
			*MoqUsualFn_adaptor,
			MoqUsualFn_params,
			MoqUsualFn_paramsKey,
			MoqUsualFn_results,
		](scene, adaptor1, config),

		Runtime: MoqUsualFn_runtime{ParameterIndexing: MoqUsualFn_paramIndexing{
			SParam: moq.ParamIndexByValue,
			BParam: moq.ParamIndexByValue,
		}},
	}
	adaptor1.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the moq implementation of the UsualFn type
func (m *MoqUsualFn) Mock() testmoqs.UsualFn {
	return func(sParam string, bParam bool) (string, error) {
		m.Moq.Scene.T.Helper()
		params := MoqUsualFn_params{
			SParam: sParam,
			BParam: bParam,
		}

		var result1 string
		var result2 error
		if result := m.Moq.Function(params); result != nil {
			result1 = result.SResult
			result2 = result.Err
		}
		return result1, result2
	}
}

func (m *MoqUsualFn) OnCall(sParam string, bParam bool) *MoqUsualFn_recorder {
	return &MoqUsualFn_recorder{
		Recorder: m.Moq.OnCall(MoqUsualFn_params{
			SParam: sParam,
			BParam: bParam,
		}),
	}
}

func (r *MoqUsualFn_recorder) Any() *MoqUsualFn_anyParams {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.IsAnyPermitted(true) {
		return nil
	}
	return &MoqUsualFn_anyParams{Recorder: r}
}

func (a *MoqUsualFn_anyParams) SParam() *MoqUsualFn_recorder {
	a.Recorder.Recorder.AnyParam(1)
	return a.Recorder
}

func (a *MoqUsualFn_anyParams) BParam() *MoqUsualFn_recorder {
	a.Recorder.Recorder.AnyParam(2)
	return a.Recorder
}

func (r *MoqUsualFn_recorder) Seq() *MoqUsualFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(true, "Seq", true) {
		return nil
	}
	return r
}

func (r *MoqUsualFn_recorder) NoSeq() *MoqUsualFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(false, "NoSeq", true) {
		return nil
	}
	return r
}

func (r *MoqUsualFn_recorder) ReturnResults(sResult string, err error) *MoqUsualFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.ReturnResults(MoqUsualFn_results{
		SResult: sResult,
		Err:     err,
	})
	return r
}

func (r *MoqUsualFn_recorder) AndDo(fn MoqUsualFn_doFn) *MoqUsualFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.AndDo(func(params MoqUsualFn_params) {
		fn(params.SParam, params.BParam)
	}, true) {
		return nil
	}
	return r
}

func (r *MoqUsualFn_recorder) DoReturnResults(fn MoqUsualFn_doReturnFn) *MoqUsualFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.DoReturnResults(func(params MoqUsualFn_params) *MoqUsualFn_results {
		sResult, err := fn(params.SParam, params.BParam)
		return &MoqUsualFn_results{
			SResult: sResult,
			Err:     err,
		}
	})
	return r
}

func (r *MoqUsualFn_recorder) Repeat(repeaters ...moq.Repeater) *MoqUsualFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Repeat(repeaters, true) {
		return nil
	}
	return r
}

func (*MoqUsualFn_adaptor) PrettyParams(params MoqUsualFn_params) string {
	return fmt.Sprintf("UsualFn(%#v, %#v)", params.SParam, params.BParam)
}

func (a *MoqUsualFn_adaptor) ParamsKey(params MoqUsualFn_params, anyParams uint64) MoqUsualFn_paramsKey {
	a.Moq.Moq.Scene.T.Helper()
	sParamUsed, sParamUsedHash := impl.ParamKey(
		params.SParam, 1, a.Moq.Runtime.ParameterIndexing.SParam, anyParams)
	bParamUsed, bParamUsedHash := impl.ParamKey(
		params.BParam, 2, a.Moq.Runtime.ParameterIndexing.BParam, anyParams)
	return MoqUsualFn_paramsKey{
		Params: struct {
			SParam string
			BParam bool
		}{
			SParam: sParamUsed,
			BParam: bParamUsed,
		},
		Hashes: struct {
			SParam hash.Hash
			BParam hash.Hash
		}{
			SParam: sParamUsedHash,
			BParam: bParamUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *MoqUsualFn) Reset() {
	m.Moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqUsualFn) AssertExpectationsMet() {
	m.Moq.Scene.T.Helper()
	m.Moq.AssertExpectationsMet()
}

// MoqNoNamesFn holds the state of a moq of the NoNamesFn type
type MoqNoNamesFn struct {
	Moq *impl.Moq[
		*MoqNoNamesFn_adaptor,
		MoqNoNamesFn_params,
		MoqNoNamesFn_paramsKey,
		MoqNoNamesFn_results,
	]

	Runtime MoqNoNamesFn_runtime
}

// MoqNoNamesFn_runtime holds runtime configuration for the NoNamesFn type
type MoqNoNamesFn_runtime struct {
	ParameterIndexing MoqNoNamesFn_paramIndexing
}

// MoqNoNamesFn_adaptor adapts MoqNoNamesFn as needed by the runtime
type MoqNoNamesFn_adaptor struct {
	Moq *MoqNoNamesFn
}

// MoqNoNamesFn_params holds the params of the NoNamesFn type
type MoqNoNamesFn_params struct {
	Param1 string
	Param2 bool
}

// MoqNoNamesFn_paramsKey holds the map key params of the NoNamesFn type
type MoqNoNamesFn_paramsKey struct {
	Params struct {
		Param1 string
		Param2 bool
	}
	Hashes struct {
		Param1 hash.Hash
		Param2 hash.Hash
	}
}

// MoqNoNamesFn_results holds the results of the NoNamesFn type
type MoqNoNamesFn_results struct {
	Result1 string
	Result2 error
}

// MoqNoNamesFn_paramIndexing holds the parameter indexing runtime
// configuration for the NoNamesFn type
type MoqNoNamesFn_paramIndexing struct {
	Param1 moq.ParamIndexing
	Param2 moq.ParamIndexing
}

// MoqNoNamesFn_doFn defines the type of function needed when calling AndDo for
// the NoNamesFn type
type MoqNoNamesFn_doFn func(string, bool)

// MoqNoNamesFn_doReturnFn defines the type of function needed when calling
// DoReturnResults for the NoNamesFn type
type MoqNoNamesFn_doReturnFn func(string, bool) (string, error)

// MoqNoNamesFn_recorder routes recorded function calls to the MoqNoNamesFn moq
type MoqNoNamesFn_recorder struct {
	Recorder *impl.Recorder[
		*MoqNoNamesFn_adaptor,
		MoqNoNamesFn_params,
		MoqNoNamesFn_paramsKey,
		MoqNoNamesFn_results,
	]
}

// MoqNoNamesFn_anyParams isolates the any params functions of the NoNamesFn
// type
type MoqNoNamesFn_anyParams struct {
	Recorder *MoqNoNamesFn_recorder
}

// NewMoqNoNamesFn creates a new moq of the NoNamesFn type
func NewMoqNoNamesFn(scene *moq.Scene, config *moq.Config) *MoqNoNamesFn {
	adaptor1 := &MoqNoNamesFn_adaptor{}
	m := &MoqNoNamesFn{
		Moq: impl.NewMoq[
			*MoqNoNamesFn_adaptor,
			MoqNoNamesFn_params,
			MoqNoNamesFn_paramsKey,
			MoqNoNamesFn_results,
		](scene, adaptor1, config),

		Runtime: MoqNoNamesFn_runtime{ParameterIndexing: MoqNoNamesFn_paramIndexing{
			Param1: moq.ParamIndexByValue,
			Param2: moq.ParamIndexByValue,
		}},
	}
	adaptor1.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the moq implementation of the NoNamesFn type
func (m *MoqNoNamesFn) Mock() testmoqs.NoNamesFn {
	return func(param1 string, param2 bool) (string, error) {
		m.Moq.Scene.T.Helper()
		params := MoqNoNamesFn_params{
			Param1: param1,
			Param2: param2,
		}

		var result1 string
		var result2 error
		if result := m.Moq.Function(params); result != nil {
			result1 = result.Result1
			result2 = result.Result2
		}
		return result1, result2
	}
}

func (m *MoqNoNamesFn) OnCall(param1 string, param2 bool) *MoqNoNamesFn_recorder {
	return &MoqNoNamesFn_recorder{
		Recorder: m.Moq.OnCall(MoqNoNamesFn_params{
			Param1: param1,
			Param2: param2,
		}),
	}
}

func (r *MoqNoNamesFn_recorder) Any() *MoqNoNamesFn_anyParams {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.IsAnyPermitted(true) {
		return nil
	}
	return &MoqNoNamesFn_anyParams{Recorder: r}
}

func (a *MoqNoNamesFn_anyParams) Param1() *MoqNoNamesFn_recorder {
	a.Recorder.Recorder.AnyParam(1)
	return a.Recorder
}

func (a *MoqNoNamesFn_anyParams) Param2() *MoqNoNamesFn_recorder {
	a.Recorder.Recorder.AnyParam(2)
	return a.Recorder
}

func (r *MoqNoNamesFn_recorder) Seq() *MoqNoNamesFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(true, "Seq", true) {
		return nil
	}
	return r
}

func (r *MoqNoNamesFn_recorder) NoSeq() *MoqNoNamesFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(false, "NoSeq", true) {
		return nil
	}
	return r
}

func (r *MoqNoNamesFn_recorder) ReturnResults(result1 string, result2 error) *MoqNoNamesFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.ReturnResults(MoqNoNamesFn_results{
		Result1: result1,
		Result2: result2,
	})
	return r
}

func (r *MoqNoNamesFn_recorder) AndDo(fn MoqNoNamesFn_doFn) *MoqNoNamesFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.AndDo(func(params MoqNoNamesFn_params) {
		fn(params.Param1, params.Param2)
	}, true) {
		return nil
	}
	return r
}

func (r *MoqNoNamesFn_recorder) DoReturnResults(fn MoqNoNamesFn_doReturnFn) *MoqNoNamesFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.DoReturnResults(func(params MoqNoNamesFn_params) *MoqNoNamesFn_results {
		result1, result2 := fn(params.Param1, params.Param2)
		return &MoqNoNamesFn_results{
			Result1: result1,
			Result2: result2,
		}
	})
	return r
}

func (r *MoqNoNamesFn_recorder) Repeat(repeaters ...moq.Repeater) *MoqNoNamesFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Repeat(repeaters, true) {
		return nil
	}
	return r
}

func (*MoqNoNamesFn_adaptor) PrettyParams(params MoqNoNamesFn_params) string {
	return fmt.Sprintf("NoNamesFn(%#v, %#v)", params.Param1, params.Param2)
}

func (a *MoqNoNamesFn_adaptor) ParamsKey(params MoqNoNamesFn_params, anyParams uint64) MoqNoNamesFn_paramsKey {
	a.Moq.Moq.Scene.T.Helper()
	param1Used, param1UsedHash := impl.ParamKey(
		params.Param1, 1, a.Moq.Runtime.ParameterIndexing.Param1, anyParams)
	param2Used, param2UsedHash := impl.ParamKey(
		params.Param2, 2, a.Moq.Runtime.ParameterIndexing.Param2, anyParams)
	return MoqNoNamesFn_paramsKey{
		Params: struct {
			Param1 string
			Param2 bool
		}{
			Param1: param1Used,
			Param2: param2Used,
		},
		Hashes: struct {
			Param1 hash.Hash
			Param2 hash.Hash
		}{
			Param1: param1UsedHash,
			Param2: param2UsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *MoqNoNamesFn) Reset() {
	m.Moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqNoNamesFn) AssertExpectationsMet() {
	m.Moq.Scene.T.Helper()
	m.Moq.AssertExpectationsMet()
}

// MoqNoResultsFn holds the state of a moq of the NoResultsFn type
type MoqNoResultsFn struct {
	Moq *impl.Moq[
		*MoqNoResultsFn_adaptor,
		MoqNoResultsFn_params,
		MoqNoResultsFn_paramsKey,
		MoqNoResultsFn_results,
	]

	Runtime MoqNoResultsFn_runtime
}

// MoqNoResultsFn_runtime holds runtime configuration for the NoResultsFn type
type MoqNoResultsFn_runtime struct {
	ParameterIndexing MoqNoResultsFn_paramIndexing
}

// MoqNoResultsFn_adaptor adapts MoqNoResultsFn as needed by the runtime
type MoqNoResultsFn_adaptor struct {
	Moq *MoqNoResultsFn
}

// MoqNoResultsFn_params holds the params of the NoResultsFn type
type MoqNoResultsFn_params struct {
	SParam string
	BParam bool
}

// MoqNoResultsFn_paramsKey holds the map key params of the NoResultsFn type
type MoqNoResultsFn_paramsKey struct {
	Params struct {
		SParam string
		BParam bool
	}
	Hashes struct {
		SParam hash.Hash
		BParam hash.Hash
	}
}

// MoqNoResultsFn_results holds the results of the NoResultsFn type
type MoqNoResultsFn_results struct{}

// MoqNoResultsFn_paramIndexing holds the parameter indexing runtime
// configuration for the NoResultsFn type
type MoqNoResultsFn_paramIndexing struct {
	SParam moq.ParamIndexing
	BParam moq.ParamIndexing
}

// MoqNoResultsFn_doFn defines the type of function needed when calling AndDo
// for the NoResultsFn type
type MoqNoResultsFn_doFn func(sParam string, bParam bool)

// MoqNoResultsFn_doReturnFn defines the type of function needed when calling
// DoReturnResults for the NoResultsFn type
type MoqNoResultsFn_doReturnFn func(sParam string, bParam bool)

// MoqNoResultsFn_recorder routes recorded function calls to the MoqNoResultsFn
// moq
type MoqNoResultsFn_recorder struct {
	Recorder *impl.Recorder[
		*MoqNoResultsFn_adaptor,
		MoqNoResultsFn_params,
		MoqNoResultsFn_paramsKey,
		MoqNoResultsFn_results,
	]
}

// MoqNoResultsFn_anyParams isolates the any params functions of the
// NoResultsFn type
type MoqNoResultsFn_anyParams struct {
	Recorder *MoqNoResultsFn_recorder
}

// NewMoqNoResultsFn creates a new moq of the NoResultsFn type
func NewMoqNoResultsFn(scene *moq.Scene, config *moq.Config) *MoqNoResultsFn {
	adaptor1 := &MoqNoResultsFn_adaptor{}
	m := &MoqNoResultsFn{
		Moq: impl.NewMoq[
			*MoqNoResultsFn_adaptor,
			MoqNoResultsFn_params,
			MoqNoResultsFn_paramsKey,
			MoqNoResultsFn_results,
		](scene, adaptor1, config),

		Runtime: MoqNoResultsFn_runtime{ParameterIndexing: MoqNoResultsFn_paramIndexing{
			SParam: moq.ParamIndexByValue,
			BParam: moq.ParamIndexByValue,
		}},
	}
	adaptor1.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the moq implementation of the NoResultsFn type
func (m *MoqNoResultsFn) Mock() testmoqs.NoResultsFn {
	return func(sParam string, bParam bool) {
		m.Moq.Scene.T.Helper()
		params := MoqNoResultsFn_params{
			SParam: sParam,
			BParam: bParam,
		}

		m.Moq.Function(params)
	}
}

func (m *MoqNoResultsFn) OnCall(sParam string, bParam bool) *MoqNoResultsFn_recorder {
	return &MoqNoResultsFn_recorder{
		Recorder: m.Moq.OnCall(MoqNoResultsFn_params{
			SParam: sParam,
			BParam: bParam,
		}),
	}
}

func (r *MoqNoResultsFn_recorder) Any() *MoqNoResultsFn_anyParams {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.IsAnyPermitted(true) {
		return nil
	}
	return &MoqNoResultsFn_anyParams{Recorder: r}
}

func (a *MoqNoResultsFn_anyParams) SParam() *MoqNoResultsFn_recorder {
	a.Recorder.Recorder.AnyParam(1)
	return a.Recorder
}

func (a *MoqNoResultsFn_anyParams) BParam() *MoqNoResultsFn_recorder {
	a.Recorder.Recorder.AnyParam(2)
	return a.Recorder
}

func (r *MoqNoResultsFn_recorder) Seq() *MoqNoResultsFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(true, "Seq", true) {
		return nil
	}
	return r
}

func (r *MoqNoResultsFn_recorder) NoSeq() *MoqNoResultsFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(false, "NoSeq", true) {
		return nil
	}
	return r
}

func (r *MoqNoResultsFn_recorder) ReturnResults() *MoqNoResultsFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.ReturnResults(MoqNoResultsFn_results{})
	return r
}

func (r *MoqNoResultsFn_recorder) AndDo(fn MoqNoResultsFn_doFn) *MoqNoResultsFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.AndDo(func(params MoqNoResultsFn_params) {
		fn(params.SParam, params.BParam)
	}, true) {
		return nil
	}
	return r
}

func (r *MoqNoResultsFn_recorder) DoReturnResults(fn MoqNoResultsFn_doReturnFn) *MoqNoResultsFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.DoReturnResults(func(params MoqNoResultsFn_params) *MoqNoResultsFn_results {
		fn(params.SParam, params.BParam)
		return &MoqNoResultsFn_results{}
	})
	return r
}

func (r *MoqNoResultsFn_recorder) Repeat(repeaters ...moq.Repeater) *MoqNoResultsFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Repeat(repeaters, true) {
		return nil
	}
	return r
}

func (*MoqNoResultsFn_adaptor) PrettyParams(params MoqNoResultsFn_params) string {
	return fmt.Sprintf("NoResultsFn(%#v, %#v)", params.SParam, params.BParam)
}

func (a *MoqNoResultsFn_adaptor) ParamsKey(params MoqNoResultsFn_params, anyParams uint64) MoqNoResultsFn_paramsKey {
	a.Moq.Moq.Scene.T.Helper()
	sParamUsed, sParamUsedHash := impl.ParamKey(
		params.SParam, 1, a.Moq.Runtime.ParameterIndexing.SParam, anyParams)
	bParamUsed, bParamUsedHash := impl.ParamKey(
		params.BParam, 2, a.Moq.Runtime.ParameterIndexing.BParam, anyParams)
	return MoqNoResultsFn_paramsKey{
		Params: struct {
			SParam string
			BParam bool
		}{
			SParam: sParamUsed,
			BParam: bParamUsed,
		},
		Hashes: struct {
			SParam hash.Hash
			BParam hash.Hash
		}{
			SParam: sParamUsedHash,
			BParam: bParamUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *MoqNoResultsFn) Reset() {
	m.Moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqNoResultsFn) AssertExpectationsMet() {
	m.Moq.Scene.T.Helper()
	m.Moq.AssertExpectationsMet()
}

// MoqNoParamsFn holds the state of a moq of the NoParamsFn type
type MoqNoParamsFn struct {
	Moq *impl.Moq[
		*MoqNoParamsFn_adaptor,
		MoqNoParamsFn_params,
		MoqNoParamsFn_paramsKey,
		MoqNoParamsFn_results,
	]

	Runtime MoqNoParamsFn_runtime
}

// MoqNoParamsFn_runtime holds runtime configuration for the NoParamsFn type
type MoqNoParamsFn_runtime struct {
	ParameterIndexing MoqNoParamsFn_paramIndexing
}

// MoqNoParamsFn_adaptor adapts MoqNoParamsFn as needed by the runtime
type MoqNoParamsFn_adaptor struct {
	Moq *MoqNoParamsFn
}

// MoqNoParamsFn_params holds the params of the NoParamsFn type
type MoqNoParamsFn_params struct{}

// MoqNoParamsFn_paramsKey holds the map key params of the NoParamsFn type
type MoqNoParamsFn_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqNoParamsFn_results holds the results of the NoParamsFn type
type MoqNoParamsFn_results struct {
	SResult string
	Err     error
}

// MoqNoParamsFn_paramIndexing holds the parameter indexing runtime
// configuration for the NoParamsFn type
type MoqNoParamsFn_paramIndexing struct{}

// MoqNoParamsFn_doFn defines the type of function needed when calling AndDo
// for the NoParamsFn type
type MoqNoParamsFn_doFn func()

// MoqNoParamsFn_doReturnFn defines the type of function needed when calling
// DoReturnResults for the NoParamsFn type
type MoqNoParamsFn_doReturnFn func() (sResult string, err error)

// MoqNoParamsFn_recorder routes recorded function calls to the MoqNoParamsFn
// moq
type MoqNoParamsFn_recorder struct {
	Recorder *impl.Recorder[
		*MoqNoParamsFn_adaptor,
		MoqNoParamsFn_params,
		MoqNoParamsFn_paramsKey,
		MoqNoParamsFn_results,
	]
}

// MoqNoParamsFn_anyParams isolates the any params functions of the NoParamsFn
// type
type MoqNoParamsFn_anyParams struct {
	Recorder *MoqNoParamsFn_recorder
}

// NewMoqNoParamsFn creates a new moq of the NoParamsFn type
func NewMoqNoParamsFn(scene *moq.Scene, config *moq.Config) *MoqNoParamsFn {
	adaptor1 := &MoqNoParamsFn_adaptor{}
	m := &MoqNoParamsFn{
		Moq: impl.NewMoq[
			*MoqNoParamsFn_adaptor,
			MoqNoParamsFn_params,
			MoqNoParamsFn_paramsKey,
			MoqNoParamsFn_results,
		](scene, adaptor1, config),

		Runtime: MoqNoParamsFn_runtime{ParameterIndexing: MoqNoParamsFn_paramIndexing{}},
	}
	adaptor1.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the moq implementation of the NoParamsFn type
func (m *MoqNoParamsFn) Mock() testmoqs.NoParamsFn {
	return func() (string, error) {
		m.Moq.Scene.T.Helper()
		params := MoqNoParamsFn_params{}

		var result1 string
		var result2 error
		if result := m.Moq.Function(params); result != nil {
			result1 = result.SResult
			result2 = result.Err
		}
		return result1, result2
	}
}

func (m *MoqNoParamsFn) OnCall() *MoqNoParamsFn_recorder {
	return &MoqNoParamsFn_recorder{
		Recorder: m.Moq.OnCall(MoqNoParamsFn_params{}),
	}
}

func (r *MoqNoParamsFn_recorder) Any() *MoqNoParamsFn_anyParams {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.IsAnyPermitted(true) {
		return nil
	}
	return &MoqNoParamsFn_anyParams{Recorder: r}
}

func (r *MoqNoParamsFn_recorder) Seq() *MoqNoParamsFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(true, "Seq", true) {
		return nil
	}
	return r
}

func (r *MoqNoParamsFn_recorder) NoSeq() *MoqNoParamsFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(false, "NoSeq", true) {
		return nil
	}
	return r
}

func (r *MoqNoParamsFn_recorder) ReturnResults(sResult string, err error) *MoqNoParamsFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.ReturnResults(MoqNoParamsFn_results{
		SResult: sResult,
		Err:     err,
	})
	return r
}

func (r *MoqNoParamsFn_recorder) AndDo(fn MoqNoParamsFn_doFn) *MoqNoParamsFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.AndDo(func(params MoqNoParamsFn_params) {
		fn()
	}, true) {
		return nil
	}
	return r
}

func (r *MoqNoParamsFn_recorder) DoReturnResults(fn MoqNoParamsFn_doReturnFn) *MoqNoParamsFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.DoReturnResults(func(params MoqNoParamsFn_params) *MoqNoParamsFn_results {
		sResult, err := fn()
		return &MoqNoParamsFn_results{
			SResult: sResult,
			Err:     err,
		}
	})
	return r
}

func (r *MoqNoParamsFn_recorder) Repeat(repeaters ...moq.Repeater) *MoqNoParamsFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Repeat(repeaters, true) {
		return nil
	}
	return r
}

func (*MoqNoParamsFn_adaptor) PrettyParams(params MoqNoParamsFn_params) string {
	return fmt.Sprintf("NoParamsFn()")
}

func (a *MoqNoParamsFn_adaptor) ParamsKey(params MoqNoParamsFn_params, anyParams uint64) MoqNoParamsFn_paramsKey {
	a.Moq.Moq.Scene.T.Helper()
	return MoqNoParamsFn_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

// Reset resets the state of the moq
func (m *MoqNoParamsFn) Reset() {
	m.Moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqNoParamsFn) AssertExpectationsMet() {
	m.Moq.Scene.T.Helper()
	m.Moq.AssertExpectationsMet()
}

// MoqNothingFn holds the state of a moq of the NothingFn type
type MoqNothingFn struct {
	Moq *impl.Moq[
		*MoqNothingFn_adaptor,
		MoqNothingFn_params,
		MoqNothingFn_paramsKey,
		MoqNothingFn_results,
	]

	Runtime MoqNothingFn_runtime
}

// MoqNothingFn_runtime holds runtime configuration for the NothingFn type
type MoqNothingFn_runtime struct {
	ParameterIndexing MoqNothingFn_paramIndexing
}

// MoqNothingFn_adaptor adapts MoqNothingFn as needed by the runtime
type MoqNothingFn_adaptor struct {
	Moq *MoqNothingFn
}

// MoqNothingFn_params holds the params of the NothingFn type
type MoqNothingFn_params struct{}

// MoqNothingFn_paramsKey holds the map key params of the NothingFn type
type MoqNothingFn_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqNothingFn_results holds the results of the NothingFn type
type MoqNothingFn_results struct{}

// MoqNothingFn_paramIndexing holds the parameter indexing runtime
// configuration for the NothingFn type
type MoqNothingFn_paramIndexing struct{}

// MoqNothingFn_doFn defines the type of function needed when calling AndDo for
// the NothingFn type
type MoqNothingFn_doFn func()

// MoqNothingFn_doReturnFn defines the type of function needed when calling
// DoReturnResults for the NothingFn type
type MoqNothingFn_doReturnFn func()

// MoqNothingFn_recorder routes recorded function calls to the MoqNothingFn moq
type MoqNothingFn_recorder struct {
	Recorder *impl.Recorder[
		*MoqNothingFn_adaptor,
		MoqNothingFn_params,
		MoqNothingFn_paramsKey,
		MoqNothingFn_results,
	]
}

// MoqNothingFn_anyParams isolates the any params functions of the NothingFn
// type
type MoqNothingFn_anyParams struct {
	Recorder *MoqNothingFn_recorder
}

// NewMoqNothingFn creates a new moq of the NothingFn type
func NewMoqNothingFn(scene *moq.Scene, config *moq.Config) *MoqNothingFn {
	adaptor1 := &MoqNothingFn_adaptor{}
	m := &MoqNothingFn{
		Moq: impl.NewMoq[
			*MoqNothingFn_adaptor,
			MoqNothingFn_params,
			MoqNothingFn_paramsKey,
			MoqNothingFn_results,
		](scene, adaptor1, config),

		Runtime: MoqNothingFn_runtime{ParameterIndexing: MoqNothingFn_paramIndexing{}},
	}
	adaptor1.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the moq implementation of the NothingFn type
func (m *MoqNothingFn) Mock() testmoqs.NothingFn {
	return func() {
		m.Moq.Scene.T.Helper()
		params := MoqNothingFn_params{}

		m.Moq.Function(params)
	}
}

func (m *MoqNothingFn) OnCall() *MoqNothingFn_recorder {
	return &MoqNothingFn_recorder{
		Recorder: m.Moq.OnCall(MoqNothingFn_params{}),
	}
}

func (r *MoqNothingFn_recorder) Any() *MoqNothingFn_anyParams {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.IsAnyPermitted(true) {
		return nil
	}
	return &MoqNothingFn_anyParams{Recorder: r}
}

func (r *MoqNothingFn_recorder) Seq() *MoqNothingFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(true, "Seq", true) {
		return nil
	}
	return r
}

func (r *MoqNothingFn_recorder) NoSeq() *MoqNothingFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(false, "NoSeq", true) {
		return nil
	}
	return r
}

func (r *MoqNothingFn_recorder) ReturnResults() *MoqNothingFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.ReturnResults(MoqNothingFn_results{})
	return r
}

func (r *MoqNothingFn_recorder) AndDo(fn MoqNothingFn_doFn) *MoqNothingFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.AndDo(func(params MoqNothingFn_params) {
		fn()
	}, true) {
		return nil
	}
	return r
}

func (r *MoqNothingFn_recorder) DoReturnResults(fn MoqNothingFn_doReturnFn) *MoqNothingFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.DoReturnResults(func(params MoqNothingFn_params) *MoqNothingFn_results {
		fn()
		return &MoqNothingFn_results{}
	})
	return r
}

func (r *MoqNothingFn_recorder) Repeat(repeaters ...moq.Repeater) *MoqNothingFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Repeat(repeaters, true) {
		return nil
	}
	return r
}

func (*MoqNothingFn_adaptor) PrettyParams(params MoqNothingFn_params) string {
	return fmt.Sprintf("NothingFn()")
}

func (a *MoqNothingFn_adaptor) ParamsKey(params MoqNothingFn_params, anyParams uint64) MoqNothingFn_paramsKey {
	a.Moq.Moq.Scene.T.Helper()
	return MoqNothingFn_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

// Reset resets the state of the moq
func (m *MoqNothingFn) Reset() {
	m.Moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqNothingFn) AssertExpectationsMet() {
	m.Moq.Scene.T.Helper()
	m.Moq.AssertExpectationsMet()
}

// MoqVariadicFn holds the state of a moq of the VariadicFn type
type MoqVariadicFn struct {
	Moq *impl.Moq[
		*MoqVariadicFn_adaptor,
		MoqVariadicFn_params,
		MoqVariadicFn_paramsKey,
		MoqVariadicFn_results,
	]

	Runtime MoqVariadicFn_runtime
}

// MoqVariadicFn_runtime holds runtime configuration for the VariadicFn type
type MoqVariadicFn_runtime struct {
	ParameterIndexing MoqVariadicFn_paramIndexing
}

// MoqVariadicFn_adaptor adapts MoqVariadicFn as needed by the runtime
type MoqVariadicFn_adaptor struct {
	Moq *MoqVariadicFn
}

// MoqVariadicFn_params holds the params of the VariadicFn type
type MoqVariadicFn_params struct {
	Other bool
	Args  []string
}

// MoqVariadicFn_paramsKey holds the map key params of the VariadicFn type
type MoqVariadicFn_paramsKey struct {
	Params struct{ Other bool }
	Hashes struct {
		Other hash.Hash
		Args  hash.Hash
	}
}

// MoqVariadicFn_results holds the results of the VariadicFn type
type MoqVariadicFn_results struct {
	SResult string
	Err     error
}

// MoqVariadicFn_paramIndexing holds the parameter indexing runtime
// configuration for the VariadicFn type
type MoqVariadicFn_paramIndexing struct {
	Other moq.ParamIndexing
	Args  moq.ParamIndexing
}

// MoqVariadicFn_doFn defines the type of function needed when calling AndDo
// for the VariadicFn type
type MoqVariadicFn_doFn func(other bool, args ...string)

// MoqVariadicFn_doReturnFn defines the type of function needed when calling
// DoReturnResults for the VariadicFn type
type MoqVariadicFn_doReturnFn func(other bool, args ...string) (sResult string, err error)

// MoqVariadicFn_recorder routes recorded function calls to the MoqVariadicFn
// moq
type MoqVariadicFn_recorder struct {
	Recorder *impl.Recorder[
		*MoqVariadicFn_adaptor,
		MoqVariadicFn_params,
		MoqVariadicFn_paramsKey,
		MoqVariadicFn_results,
	]
}

// MoqVariadicFn_anyParams isolates the any params functions of the VariadicFn
// type
type MoqVariadicFn_anyParams struct {
	Recorder *MoqVariadicFn_recorder
}

// NewMoqVariadicFn creates a new moq of the VariadicFn type
func NewMoqVariadicFn(scene *moq.Scene, config *moq.Config) *MoqVariadicFn {
	adaptor1 := &MoqVariadicFn_adaptor{}
	m := &MoqVariadicFn{
		Moq: impl.NewMoq[
			*MoqVariadicFn_adaptor,
			MoqVariadicFn_params,
			MoqVariadicFn_paramsKey,
			MoqVariadicFn_results,
		](scene, adaptor1, config),

		Runtime: MoqVariadicFn_runtime{ParameterIndexing: MoqVariadicFn_paramIndexing{
			Other: moq.ParamIndexByValue,
			Args:  moq.ParamIndexByHash,
		}},
	}
	adaptor1.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the moq implementation of the VariadicFn type
func (m *MoqVariadicFn) Mock() testmoqs.VariadicFn {
	return func(other bool, args ...string) (string, error) {
		m.Moq.Scene.T.Helper()
		params := MoqVariadicFn_params{
			Other: other,
			Args:  args,
		}

		var result1 string
		var result2 error
		if result := m.Moq.Function(params); result != nil {
			result1 = result.SResult
			result2 = result.Err
		}
		return result1, result2
	}
}

func (m *MoqVariadicFn) OnCall(other bool, args ...string) *MoqVariadicFn_recorder {
	return &MoqVariadicFn_recorder{
		Recorder: m.Moq.OnCall(MoqVariadicFn_params{
			Other: other,
			Args:  args,
		}),
	}
}

func (r *MoqVariadicFn_recorder) Any() *MoqVariadicFn_anyParams {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.IsAnyPermitted(true) {
		return nil
	}
	return &MoqVariadicFn_anyParams{Recorder: r}
}

func (a *MoqVariadicFn_anyParams) Other() *MoqVariadicFn_recorder {
	a.Recorder.Recorder.AnyParam(1)
	return a.Recorder
}

func (a *MoqVariadicFn_anyParams) Args() *MoqVariadicFn_recorder {
	a.Recorder.Recorder.AnyParam(2)
	return a.Recorder
}

func (r *MoqVariadicFn_recorder) Seq() *MoqVariadicFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(true, "Seq", true) {
		return nil
	}
	return r
}

func (r *MoqVariadicFn_recorder) NoSeq() *MoqVariadicFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(false, "NoSeq", true) {
		return nil
	}
	return r
}

func (r *MoqVariadicFn_recorder) ReturnResults(sResult string, err error) *MoqVariadicFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.ReturnResults(MoqVariadicFn_results{
		SResult: sResult,
		Err:     err,
	})
	return r
}

func (r *MoqVariadicFn_recorder) AndDo(fn MoqVariadicFn_doFn) *MoqVariadicFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.AndDo(func(params MoqVariadicFn_params) {
		fn(params.Other, params.Args...)
	}, true) {
		return nil
	}
	return r
}

func (r *MoqVariadicFn_recorder) DoReturnResults(fn MoqVariadicFn_doReturnFn) *MoqVariadicFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.DoReturnResults(func(params MoqVariadicFn_params) *MoqVariadicFn_results {
		sResult, err := fn(params.Other, params.Args...)
		return &MoqVariadicFn_results{
			SResult: sResult,
			Err:     err,
		}
	})
	return r
}

func (r *MoqVariadicFn_recorder) Repeat(repeaters ...moq.Repeater) *MoqVariadicFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Repeat(repeaters, true) {
		return nil
	}
	return r
}

func (*MoqVariadicFn_adaptor) PrettyParams(params MoqVariadicFn_params) string {
	return fmt.Sprintf("VariadicFn(%#v, %#v)", params.Other, params.Args)
}

func (a *MoqVariadicFn_adaptor) ParamsKey(params MoqVariadicFn_params, anyParams uint64) MoqVariadicFn_paramsKey {
	a.Moq.Moq.Scene.T.Helper()
	otherUsed, otherUsedHash := impl.ParamKey(
		params.Other, 1, a.Moq.Runtime.ParameterIndexing.Other, anyParams)
	argsUsedHash := impl.HashOnlyParamKey(a.Moq.Moq.Scene.T,
		params.Args, "args", 2, a.Moq.Runtime.ParameterIndexing.Args, anyParams)
	return MoqVariadicFn_paramsKey{
		Params: struct{ Other bool }{
			Other: otherUsed,
		},
		Hashes: struct {
			Other hash.Hash
			Args  hash.Hash
		}{
			Other: otherUsedHash,
			Args:  argsUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *MoqVariadicFn) Reset() {
	m.Moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqVariadicFn) AssertExpectationsMet() {
	m.Moq.Scene.T.Helper()
	m.Moq.AssertExpectationsMet()
}

// MoqRepeatedIdsFn holds the state of a moq of the RepeatedIdsFn type
type MoqRepeatedIdsFn struct {
	Moq *impl.Moq[
		*MoqRepeatedIdsFn_adaptor,
		MoqRepeatedIdsFn_params,
		MoqRepeatedIdsFn_paramsKey,
		MoqRepeatedIdsFn_results,
	]

	Runtime MoqRepeatedIdsFn_runtime
}

// MoqRepeatedIdsFn_runtime holds runtime configuration for the RepeatedIdsFn
// type
type MoqRepeatedIdsFn_runtime struct {
	ParameterIndexing MoqRepeatedIdsFn_paramIndexing
}

// MoqRepeatedIdsFn_adaptor adapts MoqRepeatedIdsFn as needed by the runtime
type MoqRepeatedIdsFn_adaptor struct {
	Moq *MoqRepeatedIdsFn
}

// MoqRepeatedIdsFn_params holds the params of the RepeatedIdsFn type
type MoqRepeatedIdsFn_params struct {
	SParam1, SParam2 string
	BParam           bool
}

// MoqRepeatedIdsFn_paramsKey holds the map key params of the RepeatedIdsFn
// type
type MoqRepeatedIdsFn_paramsKey struct {
	Params struct {
		SParam1, SParam2 string
		BParam           bool
	}
	Hashes struct {
		SParam1, SParam2 hash.Hash
		BParam           hash.Hash
	}
}

// MoqRepeatedIdsFn_results holds the results of the RepeatedIdsFn type
type MoqRepeatedIdsFn_results struct {
	SResult1, SResult2 string
	Err                error
}

// MoqRepeatedIdsFn_paramIndexing holds the parameter indexing runtime
// configuration for the RepeatedIdsFn type
type MoqRepeatedIdsFn_paramIndexing struct {
	SParam1, SParam2 moq.ParamIndexing
	BParam           moq.ParamIndexing
}

// MoqRepeatedIdsFn_doFn defines the type of function needed when calling AndDo
// for the RepeatedIdsFn type
type MoqRepeatedIdsFn_doFn func(sParam1, sParam2 string, bParam bool)

// MoqRepeatedIdsFn_doReturnFn defines the type of function needed when calling
// DoReturnResults for the RepeatedIdsFn type
type MoqRepeatedIdsFn_doReturnFn func(sParam1, sParam2 string, bParam bool) (sResult1, sResult2 string, err error)

// MoqRepeatedIdsFn_recorder routes recorded function calls to the
// MoqRepeatedIdsFn moq
type MoqRepeatedIdsFn_recorder struct {
	Recorder *impl.Recorder[
		*MoqRepeatedIdsFn_adaptor,
		MoqRepeatedIdsFn_params,
		MoqRepeatedIdsFn_paramsKey,
		MoqRepeatedIdsFn_results,
	]
}

// MoqRepeatedIdsFn_anyParams isolates the any params functions of the
// RepeatedIdsFn type
type MoqRepeatedIdsFn_anyParams struct {
	Recorder *MoqRepeatedIdsFn_recorder
}

// NewMoqRepeatedIdsFn creates a new moq of the RepeatedIdsFn type
func NewMoqRepeatedIdsFn(scene *moq.Scene, config *moq.Config) *MoqRepeatedIdsFn {
	adaptor1 := &MoqRepeatedIdsFn_adaptor{}
	m := &MoqRepeatedIdsFn{
		Moq: impl.NewMoq[
			*MoqRepeatedIdsFn_adaptor,
			MoqRepeatedIdsFn_params,
			MoqRepeatedIdsFn_paramsKey,
			MoqRepeatedIdsFn_results,
		](scene, adaptor1, config),

		Runtime: MoqRepeatedIdsFn_runtime{ParameterIndexing: MoqRepeatedIdsFn_paramIndexing{
			SParam1: moq.ParamIndexByValue,
			SParam2: moq.ParamIndexByValue,
			BParam:  moq.ParamIndexByValue,
		}},
	}
	adaptor1.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the moq implementation of the RepeatedIdsFn type
func (m *MoqRepeatedIdsFn) Mock() testmoqs.RepeatedIdsFn {
	return func(sParam1, sParam2 string, bParam bool) (string, string, error) {
		m.Moq.Scene.T.Helper()
		params := MoqRepeatedIdsFn_params{
			SParam1: sParam1,
			SParam2: sParam2,
			BParam:  bParam,
		}

		var result1 string
		var result2 string
		var result3 error
		if result := m.Moq.Function(params); result != nil {
			result1 = result.SResult1
			result2 = result.SResult2
			result3 = result.Err
		}
		return result1, result2, result3
	}
}

func (m *MoqRepeatedIdsFn) OnCall(sParam1, sParam2 string, bParam bool) *MoqRepeatedIdsFn_recorder {
	return &MoqRepeatedIdsFn_recorder{
		Recorder: m.Moq.OnCall(MoqRepeatedIdsFn_params{
			SParam1: sParam1,
			SParam2: sParam2,
			BParam:  bParam,
		}),
	}
}

func (r *MoqRepeatedIdsFn_recorder) Any() *MoqRepeatedIdsFn_anyParams {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.IsAnyPermitted(true) {
		return nil
	}
	return &MoqRepeatedIdsFn_anyParams{Recorder: r}
}

func (a *MoqRepeatedIdsFn_anyParams) SParam1() *MoqRepeatedIdsFn_recorder {
	a.Recorder.Recorder.AnyParam(1)
	return a.Recorder
}

func (a *MoqRepeatedIdsFn_anyParams) SParam2() *MoqRepeatedIdsFn_recorder {
	a.Recorder.Recorder.AnyParam(2)
	return a.Recorder
}

func (a *MoqRepeatedIdsFn_anyParams) BParam() *MoqRepeatedIdsFn_recorder {
	a.Recorder.Recorder.AnyParam(3)
	return a.Recorder
}

func (r *MoqRepeatedIdsFn_recorder) Seq() *MoqRepeatedIdsFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(true, "Seq", true) {
		return nil
	}
	return r
}

func (r *MoqRepeatedIdsFn_recorder) NoSeq() *MoqRepeatedIdsFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(false, "NoSeq", true) {
		return nil
	}
	return r
}

func (r *MoqRepeatedIdsFn_recorder) ReturnResults(sResult1, sResult2 string, err error) *MoqRepeatedIdsFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.ReturnResults(MoqRepeatedIdsFn_results{
		SResult1: sResult1,
		SResult2: sResult2,
		Err:      err,
	})
	return r
}

func (r *MoqRepeatedIdsFn_recorder) AndDo(fn MoqRepeatedIdsFn_doFn) *MoqRepeatedIdsFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.AndDo(func(params MoqRepeatedIdsFn_params) {
		fn(params.SParam1, params.SParam2, params.BParam)
	}, true) {
		return nil
	}
	return r
}

func (r *MoqRepeatedIdsFn_recorder) DoReturnResults(fn MoqRepeatedIdsFn_doReturnFn) *MoqRepeatedIdsFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.DoReturnResults(func(params MoqRepeatedIdsFn_params) *MoqRepeatedIdsFn_results {
		sResult1, sResult2, err := fn(params.SParam1, params.SParam2, params.BParam)
		return &MoqRepeatedIdsFn_results{
			SResult1: sResult1,
			SResult2: sResult2,
			Err:      err,
		}
	})
	return r
}

func (r *MoqRepeatedIdsFn_recorder) Repeat(repeaters ...moq.Repeater) *MoqRepeatedIdsFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Repeat(repeaters, true) {
		return nil
	}
	return r
}

func (*MoqRepeatedIdsFn_adaptor) PrettyParams(params MoqRepeatedIdsFn_params) string {
	return fmt.Sprintf("RepeatedIdsFn(%#v, %#v, %#v)", params.SParam1, params.SParam2, params.BParam)
}

func (a *MoqRepeatedIdsFn_adaptor) ParamsKey(params MoqRepeatedIdsFn_params, anyParams uint64) MoqRepeatedIdsFn_paramsKey {
	a.Moq.Moq.Scene.T.Helper()
	sParam1Used, sParam1UsedHash := impl.ParamKey(
		params.SParam1, 1, a.Moq.Runtime.ParameterIndexing.SParam1, anyParams)
	sParam2Used, sParam2UsedHash := impl.ParamKey(
		params.SParam2, 2, a.Moq.Runtime.ParameterIndexing.SParam2, anyParams)
	bParamUsed, bParamUsedHash := impl.ParamKey(
		params.BParam, 3, a.Moq.Runtime.ParameterIndexing.BParam, anyParams)
	return MoqRepeatedIdsFn_paramsKey{
		Params: struct {
			SParam1, SParam2 string
			BParam           bool
		}{
			SParam1: sParam1Used,
			SParam2: sParam2Used,
			BParam:  bParamUsed,
		},
		Hashes: struct {
			SParam1, SParam2 hash.Hash
			BParam           hash.Hash
		}{
			SParam1: sParam1UsedHash,
			SParam2: sParam2UsedHash,
			BParam:  bParamUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *MoqRepeatedIdsFn) Reset() {
	m.Moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqRepeatedIdsFn) AssertExpectationsMet() {
	m.Moq.Scene.T.Helper()
	m.Moq.AssertExpectationsMet()
}

// MoqTimesFn holds the state of a moq of the TimesFn type
type MoqTimesFn struct {
	Moq *impl.Moq[
		*MoqTimesFn_adaptor,
		MoqTimesFn_params,
		MoqTimesFn_paramsKey,
		MoqTimesFn_results,
	]

	Runtime MoqTimesFn_runtime
}

// MoqTimesFn_runtime holds runtime configuration for the TimesFn type
type MoqTimesFn_runtime struct {
	ParameterIndexing MoqTimesFn_paramIndexing
}

// MoqTimesFn_adaptor adapts MoqTimesFn as needed by the runtime
type MoqTimesFn_adaptor struct {
	Moq *MoqTimesFn
}

// MoqTimesFn_params holds the params of the TimesFn type
type MoqTimesFn_params struct {
	Times  string
	BParam bool
}

// MoqTimesFn_paramsKey holds the map key params of the TimesFn type
type MoqTimesFn_paramsKey struct {
	Params struct {
		Times  string
		BParam bool
	}
	Hashes struct {
		Times  hash.Hash
		BParam hash.Hash
	}
}

// MoqTimesFn_results holds the results of the TimesFn type
type MoqTimesFn_results struct {
	SResult string
	Err     error
}

// MoqTimesFn_paramIndexing holds the parameter indexing runtime configuration
// for the TimesFn type
type MoqTimesFn_paramIndexing struct {
	Times  moq.ParamIndexing
	BParam moq.ParamIndexing
}

// MoqTimesFn_doFn defines the type of function needed when calling AndDo for
// the TimesFn type
type MoqTimesFn_doFn func(times string, bParam bool)

// MoqTimesFn_doReturnFn defines the type of function needed when calling
// DoReturnResults for the TimesFn type
type MoqTimesFn_doReturnFn func(times string, bParam bool) (sResult string, err error)

// MoqTimesFn_recorder routes recorded function calls to the MoqTimesFn moq
type MoqTimesFn_recorder struct {
	Recorder *impl.Recorder[
		*MoqTimesFn_adaptor,
		MoqTimesFn_params,
		MoqTimesFn_paramsKey,
		MoqTimesFn_results,
	]
}

// MoqTimesFn_anyParams isolates the any params functions of the TimesFn type
type MoqTimesFn_anyParams struct {
	Recorder *MoqTimesFn_recorder
}

// NewMoqTimesFn creates a new moq of the TimesFn type
func NewMoqTimesFn(scene *moq.Scene, config *moq.Config) *MoqTimesFn {
	adaptor1 := &MoqTimesFn_adaptor{}
	m := &MoqTimesFn{
		Moq: impl.NewMoq[
			*MoqTimesFn_adaptor,
			MoqTimesFn_params,
			MoqTimesFn_paramsKey,
			MoqTimesFn_results,
		](scene, adaptor1, config),

		Runtime: MoqTimesFn_runtime{ParameterIndexing: MoqTimesFn_paramIndexing{
			Times:  moq.ParamIndexByValue,
			BParam: moq.ParamIndexByValue,
		}},
	}
	adaptor1.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the moq implementation of the TimesFn type
func (m *MoqTimesFn) Mock() testmoqs.TimesFn {
	return func(times string, bParam bool) (string, error) {
		m.Moq.Scene.T.Helper()
		params := MoqTimesFn_params{
			Times:  times,
			BParam: bParam,
		}

		var result1 string
		var result2 error
		if result := m.Moq.Function(params); result != nil {
			result1 = result.SResult
			result2 = result.Err
		}
		return result1, result2
	}
}

func (m *MoqTimesFn) OnCall(times string, bParam bool) *MoqTimesFn_recorder {
	return &MoqTimesFn_recorder{
		Recorder: m.Moq.OnCall(MoqTimesFn_params{
			Times:  times,
			BParam: bParam,
		}),
	}
}

func (r *MoqTimesFn_recorder) Any() *MoqTimesFn_anyParams {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.IsAnyPermitted(true) {
		return nil
	}
	return &MoqTimesFn_anyParams{Recorder: r}
}

func (a *MoqTimesFn_anyParams) Times() *MoqTimesFn_recorder {
	a.Recorder.Recorder.AnyParam(1)
	return a.Recorder
}

func (a *MoqTimesFn_anyParams) BParam() *MoqTimesFn_recorder {
	a.Recorder.Recorder.AnyParam(2)
	return a.Recorder
}

func (r *MoqTimesFn_recorder) Seq() *MoqTimesFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(true, "Seq", true) {
		return nil
	}
	return r
}

func (r *MoqTimesFn_recorder) NoSeq() *MoqTimesFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(false, "NoSeq", true) {
		return nil
	}
	return r
}

func (r *MoqTimesFn_recorder) ReturnResults(sResult string, err error) *MoqTimesFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.ReturnResults(MoqTimesFn_results{
		SResult: sResult,
		Err:     err,
	})
	return r
}

func (r *MoqTimesFn_recorder) AndDo(fn MoqTimesFn_doFn) *MoqTimesFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.AndDo(func(params MoqTimesFn_params) {
		fn(params.Times, params.BParam)
	}, true) {
		return nil
	}
	return r
}

func (r *MoqTimesFn_recorder) DoReturnResults(fn MoqTimesFn_doReturnFn) *MoqTimesFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.DoReturnResults(func(params MoqTimesFn_params) *MoqTimesFn_results {
		sResult, err := fn(params.Times, params.BParam)
		return &MoqTimesFn_results{
			SResult: sResult,
			Err:     err,
		}
	})
	return r
}

func (r *MoqTimesFn_recorder) Repeat(repeaters ...moq.Repeater) *MoqTimesFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Repeat(repeaters, true) {
		return nil
	}
	return r
}

func (*MoqTimesFn_adaptor) PrettyParams(params MoqTimesFn_params) string {
	return fmt.Sprintf("TimesFn(%#v, %#v)", params.Times, params.BParam)
}

func (a *MoqTimesFn_adaptor) ParamsKey(params MoqTimesFn_params, anyParams uint64) MoqTimesFn_paramsKey {
	a.Moq.Moq.Scene.T.Helper()
	timesUsed, timesUsedHash := impl.ParamKey(
		params.Times, 1, a.Moq.Runtime.ParameterIndexing.Times, anyParams)
	bParamUsed, bParamUsedHash := impl.ParamKey(
		params.BParam, 2, a.Moq.Runtime.ParameterIndexing.BParam, anyParams)
	return MoqTimesFn_paramsKey{
		Params: struct {
			Times  string
			BParam bool
		}{
			Times:  timesUsed,
			BParam: bParamUsed,
		},
		Hashes: struct {
			Times  hash.Hash
			BParam hash.Hash
		}{
			Times:  timesUsedHash,
			BParam: bParamUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *MoqTimesFn) Reset() {
	m.Moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqTimesFn) AssertExpectationsMet() {
	m.Moq.Scene.T.Helper()
	m.Moq.AssertExpectationsMet()
}

// MoqDifficultParamNamesFn holds the state of a moq of the
// DifficultParamNamesFn type
type MoqDifficultParamNamesFn struct {
	Moq *impl.Moq[
		*MoqDifficultParamNamesFn_adaptor,
		MoqDifficultParamNamesFn_params,
		MoqDifficultParamNamesFn_paramsKey,
		MoqDifficultParamNamesFn_results,
	]

	Runtime MoqDifficultParamNamesFn_runtime
}

// MoqDifficultParamNamesFn_runtime holds runtime configuration for the
// DifficultParamNamesFn type
type MoqDifficultParamNamesFn_runtime struct {
	ParameterIndexing MoqDifficultParamNamesFn_paramIndexing
}

// MoqDifficultParamNamesFn_adaptor adapts MoqDifficultParamNamesFn as needed
// by the runtime
type MoqDifficultParamNamesFn_adaptor struct {
	Moq *MoqDifficultParamNamesFn
}

// MoqDifficultParamNamesFn_params holds the params of the
// DifficultParamNamesFn type
type MoqDifficultParamNamesFn_params struct {
	Param1, Param2         bool
	Param3                 string
	Param, Param5, Param6  int
	Param7, Param8, Param9 float32
}

// MoqDifficultParamNamesFn_paramsKey holds the map key params of the
// DifficultParamNamesFn type
type MoqDifficultParamNamesFn_paramsKey struct {
	Params struct {
		Param1, Param2         bool
		Param3                 string
		Param, Param5, Param6  int
		Param7, Param8, Param9 float32
	}
	Hashes struct {
		Param1, Param2         hash.Hash
		Param3                 hash.Hash
		Param, Param5, Param6  hash.Hash
		Param7, Param8, Param9 hash.Hash
	}
}

// MoqDifficultParamNamesFn_results holds the results of the
// DifficultParamNamesFn type
type MoqDifficultParamNamesFn_results struct{}

// MoqDifficultParamNamesFn_paramIndexing holds the parameter indexing runtime
// configuration for the DifficultParamNamesFn type
type MoqDifficultParamNamesFn_paramIndexing struct {
	Param1, Param2         moq.ParamIndexing
	Param3                 moq.ParamIndexing
	Param, Param5, Param6  moq.ParamIndexing
	Param7, Param8, Param9 moq.ParamIndexing
}

// MoqDifficultParamNamesFn_doFn defines the type of function needed when
// calling AndDo for the DifficultParamNamesFn type
type MoqDifficultParamNamesFn_doFn func(m, r bool, sequence string, param, params, i int, result, results, _ float32)

// MoqDifficultParamNamesFn_doReturnFn defines the type of function needed when
// calling DoReturnResults for the DifficultParamNamesFn type
type MoqDifficultParamNamesFn_doReturnFn func(m, r bool, sequence string, param, params, i int, result, results, _ float32)

// MoqDifficultParamNamesFn_recorder routes recorded function calls to the
// MoqDifficultParamNamesFn moq
type MoqDifficultParamNamesFn_recorder struct {
	Recorder *impl.Recorder[
		*MoqDifficultParamNamesFn_adaptor,
		MoqDifficultParamNamesFn_params,
		MoqDifficultParamNamesFn_paramsKey,
		MoqDifficultParamNamesFn_results,
	]
}

// MoqDifficultParamNamesFn_anyParams isolates the any params functions of the
// DifficultParamNamesFn type
type MoqDifficultParamNamesFn_anyParams struct {
	Recorder *MoqDifficultParamNamesFn_recorder
}

// NewMoqDifficultParamNamesFn creates a new moq of the DifficultParamNamesFn
// type
func NewMoqDifficultParamNamesFn(scene *moq.Scene, config *moq.Config) *MoqDifficultParamNamesFn {
	adaptor1 := &MoqDifficultParamNamesFn_adaptor{}
	m := &MoqDifficultParamNamesFn{
		Moq: impl.NewMoq[
			*MoqDifficultParamNamesFn_adaptor,
			MoqDifficultParamNamesFn_params,
			MoqDifficultParamNamesFn_paramsKey,
			MoqDifficultParamNamesFn_results,
		](scene, adaptor1, config),

		Runtime: MoqDifficultParamNamesFn_runtime{ParameterIndexing: MoqDifficultParamNamesFn_paramIndexing{
			Param1: moq.ParamIndexByValue,
			Param2: moq.ParamIndexByValue,
			Param3: moq.ParamIndexByValue,
			Param:  moq.ParamIndexByValue,
			Param5: moq.ParamIndexByValue,
			Param6: moq.ParamIndexByValue,
			Param7: moq.ParamIndexByValue,
			Param8: moq.ParamIndexByValue,
			Param9: moq.ParamIndexByValue,
		}},
	}
	adaptor1.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the moq implementation of the DifficultParamNamesFn type
func (m *MoqDifficultParamNamesFn) Mock() testmoqs.DifficultParamNamesFn {
	return func(param1, param2 bool, param3 string, param, param5, param6 int, param7, param8, param9 float32) {
		m.Moq.Scene.T.Helper()
		params := MoqDifficultParamNamesFn_params{
			Param1: param1,
			Param2: param2,
			Param3: param3,
			Param:  param,
			Param5: param5,
			Param6: param6,
			Param7: param7,
			Param8: param8,
			Param9: param9,
		}

		m.Moq.Function(params)
	}
}

func (m *MoqDifficultParamNamesFn) OnCall(param1, param2 bool, param3 string, param, param5, param6 int, param7, param8, param9 float32) *MoqDifficultParamNamesFn_recorder {
	return &MoqDifficultParamNamesFn_recorder{
		Recorder: m.Moq.OnCall(MoqDifficultParamNamesFn_params{
			Param1: param1,
			Param2: param2,
			Param3: param3,
			Param:  param,
			Param5: param5,
			Param6: param6,
			Param7: param7,
			Param8: param8,
			Param9: param9,
		}),
	}
}

func (r *MoqDifficultParamNamesFn_recorder) Any() *MoqDifficultParamNamesFn_anyParams {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.IsAnyPermitted(true) {
		return nil
	}
	return &MoqDifficultParamNamesFn_anyParams{Recorder: r}
}

func (a *MoqDifficultParamNamesFn_anyParams) Param1() *MoqDifficultParamNamesFn_recorder {
	a.Recorder.Recorder.AnyParam(1)
	return a.Recorder
}

func (a *MoqDifficultParamNamesFn_anyParams) Param2() *MoqDifficultParamNamesFn_recorder {
	a.Recorder.Recorder.AnyParam(2)
	return a.Recorder
}

func (a *MoqDifficultParamNamesFn_anyParams) Param3() *MoqDifficultParamNamesFn_recorder {
	a.Recorder.Recorder.AnyParam(3)
	return a.Recorder
}

func (a *MoqDifficultParamNamesFn_anyParams) Param() *MoqDifficultParamNamesFn_recorder {
	a.Recorder.Recorder.AnyParam(4)
	return a.Recorder
}

func (a *MoqDifficultParamNamesFn_anyParams) Param5() *MoqDifficultParamNamesFn_recorder {
	a.Recorder.Recorder.AnyParam(5)
	return a.Recorder
}

func (a *MoqDifficultParamNamesFn_anyParams) Param6() *MoqDifficultParamNamesFn_recorder {
	a.Recorder.Recorder.AnyParam(6)
	return a.Recorder
}

func (a *MoqDifficultParamNamesFn_anyParams) Param7() *MoqDifficultParamNamesFn_recorder {
	a.Recorder.Recorder.AnyParam(7)
	return a.Recorder
}

func (a *MoqDifficultParamNamesFn_anyParams) Param8() *MoqDifficultParamNamesFn_recorder {
	a.Recorder.Recorder.AnyParam(8)
	return a.Recorder
}

func (a *MoqDifficultParamNamesFn_anyParams) Param9() *MoqDifficultParamNamesFn_recorder {
	a.Recorder.Recorder.AnyParam(9)
	return a.Recorder
}

func (r *MoqDifficultParamNamesFn_recorder) Seq() *MoqDifficultParamNamesFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(true, "Seq", true) {
		return nil
	}
	return r
}

func (r *MoqDifficultParamNamesFn_recorder) NoSeq() *MoqDifficultParamNamesFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(false, "NoSeq", true) {
		return nil
	}
	return r
}

func (r *MoqDifficultParamNamesFn_recorder) ReturnResults() *MoqDifficultParamNamesFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.ReturnResults(MoqDifficultParamNamesFn_results{})
	return r
}

func (r *MoqDifficultParamNamesFn_recorder) AndDo(fn MoqDifficultParamNamesFn_doFn) *MoqDifficultParamNamesFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.AndDo(func(params MoqDifficultParamNamesFn_params) {
		fn(params.Param1, params.Param2, params.Param3, params.Param, params.Param5, params.Param6, params.Param7, params.Param8, params.Param9)
	}, true) {
		return nil
	}
	return r
}

func (r *MoqDifficultParamNamesFn_recorder) DoReturnResults(fn MoqDifficultParamNamesFn_doReturnFn) *MoqDifficultParamNamesFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.DoReturnResults(func(params MoqDifficultParamNamesFn_params) *MoqDifficultParamNamesFn_results {
		fn(params.Param1, params.Param2, params.Param3, params.Param, params.Param5, params.Param6, params.Param7, params.Param8, params.Param9)
		return &MoqDifficultParamNamesFn_results{}
	})
	return r
}

func (r *MoqDifficultParamNamesFn_recorder) Repeat(repeaters ...moq.Repeater) *MoqDifficultParamNamesFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Repeat(repeaters, true) {
		return nil
	}
	return r
}

func (*MoqDifficultParamNamesFn_adaptor) PrettyParams(params MoqDifficultParamNamesFn_params) string {
	return fmt.Sprintf("DifficultParamNamesFn(%#v, %#v, %#v, %#v, %#v, %#v, %#v, %#v, %#v)", params.Param1, params.Param2, params.Param3, params.Param, params.Param5, params.Param6, params.Param7, params.Param8, params.Param9)
}

func (a *MoqDifficultParamNamesFn_adaptor) ParamsKey(params MoqDifficultParamNamesFn_params, anyParams uint64) MoqDifficultParamNamesFn_paramsKey {
	a.Moq.Moq.Scene.T.Helper()
	param1Used, param1UsedHash := impl.ParamKey(
		params.Param1, 1, a.Moq.Runtime.ParameterIndexing.Param1, anyParams)
	param2Used, param2UsedHash := impl.ParamKey(
		params.Param2, 2, a.Moq.Runtime.ParameterIndexing.Param2, anyParams)
	param3Used, param3UsedHash := impl.ParamKey(
		params.Param3, 3, a.Moq.Runtime.ParameterIndexing.Param3, anyParams)
	paramUsed, paramUsedHash := impl.ParamKey(
		params.Param, 4, a.Moq.Runtime.ParameterIndexing.Param, anyParams)
	param5Used, param5UsedHash := impl.ParamKey(
		params.Param5, 5, a.Moq.Runtime.ParameterIndexing.Param5, anyParams)
	param6Used, param6UsedHash := impl.ParamKey(
		params.Param6, 6, a.Moq.Runtime.ParameterIndexing.Param6, anyParams)
	param7Used, param7UsedHash := impl.ParamKey(
		params.Param7, 7, a.Moq.Runtime.ParameterIndexing.Param7, anyParams)
	param8Used, param8UsedHash := impl.ParamKey(
		params.Param8, 8, a.Moq.Runtime.ParameterIndexing.Param8, anyParams)
	param9Used, param9UsedHash := impl.ParamKey(
		params.Param9, 9, a.Moq.Runtime.ParameterIndexing.Param9, anyParams)
	return MoqDifficultParamNamesFn_paramsKey{
		Params: struct {
			Param1, Param2         bool
			Param3                 string
			Param, Param5, Param6  int
			Param7, Param8, Param9 float32
		}{
			Param1: param1Used,
			Param2: param2Used,
			Param3: param3Used,
			Param:  paramUsed,
			Param5: param5Used,
			Param6: param6Used,
			Param7: param7Used,
			Param8: param8Used,
			Param9: param9Used,
		},
		Hashes: struct {
			Param1, Param2         hash.Hash
			Param3                 hash.Hash
			Param, Param5, Param6  hash.Hash
			Param7, Param8, Param9 hash.Hash
		}{
			Param1: param1UsedHash,
			Param2: param2UsedHash,
			Param3: param3UsedHash,
			Param:  paramUsedHash,
			Param5: param5UsedHash,
			Param6: param6UsedHash,
			Param7: param7UsedHash,
			Param8: param8UsedHash,
			Param9: param9UsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *MoqDifficultParamNamesFn) Reset() {
	m.Moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqDifficultParamNamesFn) AssertExpectationsMet() {
	m.Moq.Scene.T.Helper()
	m.Moq.AssertExpectationsMet()
}

// MoqDifficultResultNamesFn holds the state of a moq of the
// DifficultResultNamesFn type
type MoqDifficultResultNamesFn struct {
	Moq *impl.Moq[
		*MoqDifficultResultNamesFn_adaptor,
		MoqDifficultResultNamesFn_params,
		MoqDifficultResultNamesFn_paramsKey,
		MoqDifficultResultNamesFn_results,
	]

	Runtime MoqDifficultResultNamesFn_runtime
}

// MoqDifficultResultNamesFn_runtime holds runtime configuration for the
// DifficultResultNamesFn type
type MoqDifficultResultNamesFn_runtime struct {
	ParameterIndexing MoqDifficultResultNamesFn_paramIndexing
}

// MoqDifficultResultNamesFn_adaptor adapts MoqDifficultResultNamesFn as needed
// by the runtime
type MoqDifficultResultNamesFn_adaptor struct {
	Moq *MoqDifficultResultNamesFn
}

// MoqDifficultResultNamesFn_params holds the params of the
// DifficultResultNamesFn type
type MoqDifficultResultNamesFn_params struct{}

// MoqDifficultResultNamesFn_paramsKey holds the map key params of the
// DifficultResultNamesFn type
type MoqDifficultResultNamesFn_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqDifficultResultNamesFn_results holds the results of the
// DifficultResultNamesFn type
type MoqDifficultResultNamesFn_results struct {
	Result1, Result2          string
	Result3                   error
	Param, Result5, Result6   int
	Result7, Result8, Result9 float32
}

// MoqDifficultResultNamesFn_paramIndexing holds the parameter indexing runtime
// configuration for the DifficultResultNamesFn type
type MoqDifficultResultNamesFn_paramIndexing struct{}

// MoqDifficultResultNamesFn_doFn defines the type of function needed when
// calling AndDo for the DifficultResultNamesFn type
type MoqDifficultResultNamesFn_doFn func()

// MoqDifficultResultNamesFn_doReturnFn defines the type of function needed
// when calling DoReturnResults for the DifficultResultNamesFn type
type MoqDifficultResultNamesFn_doReturnFn func() (m, r string, sequence error, param, params, i int, result, results, _ float32)

// MoqDifficultResultNamesFn_recorder routes recorded function calls to the
// MoqDifficultResultNamesFn moq
type MoqDifficultResultNamesFn_recorder struct {
	Recorder *impl.Recorder[
		*MoqDifficultResultNamesFn_adaptor,
		MoqDifficultResultNamesFn_params,
		MoqDifficultResultNamesFn_paramsKey,
		MoqDifficultResultNamesFn_results,
	]
}

// MoqDifficultResultNamesFn_anyParams isolates the any params functions of the
// DifficultResultNamesFn type
type MoqDifficultResultNamesFn_anyParams struct {
	Recorder *MoqDifficultResultNamesFn_recorder
}

// NewMoqDifficultResultNamesFn creates a new moq of the DifficultResultNamesFn
// type
func NewMoqDifficultResultNamesFn(scene *moq.Scene, config *moq.Config) *MoqDifficultResultNamesFn {
	adaptor1 := &MoqDifficultResultNamesFn_adaptor{}
	m := &MoqDifficultResultNamesFn{
		Moq: impl.NewMoq[
			*MoqDifficultResultNamesFn_adaptor,
			MoqDifficultResultNamesFn_params,
			MoqDifficultResultNamesFn_paramsKey,
			MoqDifficultResultNamesFn_results,
		](scene, adaptor1, config),

		Runtime: MoqDifficultResultNamesFn_runtime{ParameterIndexing: MoqDifficultResultNamesFn_paramIndexing{}},
	}
	adaptor1.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the moq implementation of the DifficultResultNamesFn type
func (m *MoqDifficultResultNamesFn) Mock() testmoqs.DifficultResultNamesFn {
	return func() (string, string, error, int, int, int, float32, float32, float32) {
		m.Moq.Scene.T.Helper()
		params := MoqDifficultResultNamesFn_params{}

		var result1 string
		var result2 string
		var result3 error
		var result4 int
		var result5 int
		var result6 int
		var result7 float32
		var result8 float32
		var result9 float32
		if result := m.Moq.Function(params); result != nil {
			result1 = result.Result1
			result2 = result.Result2
			result3 = result.Result3
			result4 = result.Param
			result5 = result.Result5
			result6 = result.Result6
			result7 = result.Result7
			result8 = result.Result8
			result9 = result.Result9
		}
		return result1, result2, result3, result4, result5, result6, result7, result8, result9
	}
}

func (m *MoqDifficultResultNamesFn) OnCall() *MoqDifficultResultNamesFn_recorder {
	return &MoqDifficultResultNamesFn_recorder{
		Recorder: m.Moq.OnCall(MoqDifficultResultNamesFn_params{}),
	}
}

func (r *MoqDifficultResultNamesFn_recorder) Any() *MoqDifficultResultNamesFn_anyParams {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.IsAnyPermitted(true) {
		return nil
	}
	return &MoqDifficultResultNamesFn_anyParams{Recorder: r}
}

func (r *MoqDifficultResultNamesFn_recorder) Seq() *MoqDifficultResultNamesFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(true, "Seq", true) {
		return nil
	}
	return r
}

func (r *MoqDifficultResultNamesFn_recorder) NoSeq() *MoqDifficultResultNamesFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(false, "NoSeq", true) {
		return nil
	}
	return r
}

func (r *MoqDifficultResultNamesFn_recorder) ReturnResults(result1, result2 string, result3 error, param, result5, result6 int, result7, result8, result9 float32) *MoqDifficultResultNamesFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.ReturnResults(MoqDifficultResultNamesFn_results{
		Result1: result1,
		Result2: result2,
		Result3: result3,
		Param:   param,
		Result5: result5,
		Result6: result6,
		Result7: result7,
		Result8: result8,
		Result9: result9,
	})
	return r
}

func (r *MoqDifficultResultNamesFn_recorder) AndDo(fn MoqDifficultResultNamesFn_doFn) *MoqDifficultResultNamesFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.AndDo(func(params MoqDifficultResultNamesFn_params) {
		fn()
	}, true) {
		return nil
	}
	return r
}

func (r *MoqDifficultResultNamesFn_recorder) DoReturnResults(fn MoqDifficultResultNamesFn_doReturnFn) *MoqDifficultResultNamesFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.DoReturnResults(func(params MoqDifficultResultNamesFn_params) *MoqDifficultResultNamesFn_results {
		result1, result2, result3, param, result5, result6, result7, result8, result9 := fn()
		return &MoqDifficultResultNamesFn_results{
			Result1: result1,
			Result2: result2,
			Result3: result3,
			Param:   param,
			Result5: result5,
			Result6: result6,
			Result7: result7,
			Result8: result8,
			Result9: result9,
		}
	})
	return r
}

func (r *MoqDifficultResultNamesFn_recorder) Repeat(repeaters ...moq.Repeater) *MoqDifficultResultNamesFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Repeat(repeaters, true) {
		return nil
	}
	return r
}

func (*MoqDifficultResultNamesFn_adaptor) PrettyParams(params MoqDifficultResultNamesFn_params) string {
	return fmt.Sprintf("DifficultResultNamesFn()")
}

func (a *MoqDifficultResultNamesFn_adaptor) ParamsKey(params MoqDifficultResultNamesFn_params, anyParams uint64) MoqDifficultResultNamesFn_paramsKey {
	a.Moq.Moq.Scene.T.Helper()
	return MoqDifficultResultNamesFn_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

// Reset resets the state of the moq
func (m *MoqDifficultResultNamesFn) Reset() {
	m.Moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqDifficultResultNamesFn) AssertExpectationsMet() {
	m.Moq.Scene.T.Helper()
	m.Moq.AssertExpectationsMet()
}

// MoqPassByArrayFn holds the state of a moq of the PassByArrayFn type
type MoqPassByArrayFn struct {
	Moq *impl.Moq[
		*MoqPassByArrayFn_adaptor,
		MoqPassByArrayFn_params,
		MoqPassByArrayFn_paramsKey,
		MoqPassByArrayFn_results,
	]

	Runtime MoqPassByArrayFn_runtime
}

// MoqPassByArrayFn_runtime holds runtime configuration for the PassByArrayFn
// type
type MoqPassByArrayFn_runtime struct {
	ParameterIndexing MoqPassByArrayFn_paramIndexing
}

// MoqPassByArrayFn_adaptor adapts MoqPassByArrayFn as needed by the runtime
type MoqPassByArrayFn_adaptor struct {
	Moq *MoqPassByArrayFn
}

// MoqPassByArrayFn_params holds the params of the PassByArrayFn type
type MoqPassByArrayFn_params struct{ P [3]testmoqs.Params }

// MoqPassByArrayFn_paramsKey holds the map key params of the PassByArrayFn
// type
type MoqPassByArrayFn_paramsKey struct {
	Params struct{ P [3]testmoqs.Params }
	Hashes struct{ P hash.Hash }
}

// MoqPassByArrayFn_results holds the results of the PassByArrayFn type
type MoqPassByArrayFn_results struct {
	Result1 [3]testmoqs.Results
}

// MoqPassByArrayFn_paramIndexing holds the parameter indexing runtime
// configuration for the PassByArrayFn type
type MoqPassByArrayFn_paramIndexing struct {
	P moq.ParamIndexing
}

// MoqPassByArrayFn_doFn defines the type of function needed when calling AndDo
// for the PassByArrayFn type
type MoqPassByArrayFn_doFn func(p [3]testmoqs.Params)

// MoqPassByArrayFn_doReturnFn defines the type of function needed when calling
// DoReturnResults for the PassByArrayFn type
type MoqPassByArrayFn_doReturnFn func(p [3]testmoqs.Params) [3]testmoqs.Results

// MoqPassByArrayFn_recorder routes recorded function calls to the
// MoqPassByArrayFn moq
type MoqPassByArrayFn_recorder struct {
	Recorder *impl.Recorder[
		*MoqPassByArrayFn_adaptor,
		MoqPassByArrayFn_params,
		MoqPassByArrayFn_paramsKey,
		MoqPassByArrayFn_results,
	]
}

// MoqPassByArrayFn_anyParams isolates the any params functions of the
// PassByArrayFn type
type MoqPassByArrayFn_anyParams struct {
	Recorder *MoqPassByArrayFn_recorder
}

// NewMoqPassByArrayFn creates a new moq of the PassByArrayFn type
func NewMoqPassByArrayFn(scene *moq.Scene, config *moq.Config) *MoqPassByArrayFn {
	adaptor1 := &MoqPassByArrayFn_adaptor{}
	m := &MoqPassByArrayFn{
		Moq: impl.NewMoq[
			*MoqPassByArrayFn_adaptor,
			MoqPassByArrayFn_params,
			MoqPassByArrayFn_paramsKey,
			MoqPassByArrayFn_results,
		](scene, adaptor1, config),

		Runtime: MoqPassByArrayFn_runtime{ParameterIndexing: MoqPassByArrayFn_paramIndexing{
			P: moq.ParamIndexByValue,
		}},
	}
	adaptor1.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the moq implementation of the PassByArrayFn type
func (m *MoqPassByArrayFn) Mock() testmoqs.PassByArrayFn {
	return func(p [3]testmoqs.Params) [3]testmoqs.Results {
		m.Moq.Scene.T.Helper()
		params := MoqPassByArrayFn_params{
			P: p,
		}

		var result1 [3]testmoqs.Results
		if result := m.Moq.Function(params); result != nil {
			result1 = result.Result1
		}
		return result1
	}
}

func (m *MoqPassByArrayFn) OnCall(p [3]testmoqs.Params) *MoqPassByArrayFn_recorder {
	return &MoqPassByArrayFn_recorder{
		Recorder: m.Moq.OnCall(MoqPassByArrayFn_params{
			P: p,
		}),
	}
}

func (r *MoqPassByArrayFn_recorder) Any() *MoqPassByArrayFn_anyParams {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.IsAnyPermitted(true) {
		return nil
	}
	return &MoqPassByArrayFn_anyParams{Recorder: r}
}

func (a *MoqPassByArrayFn_anyParams) P() *MoqPassByArrayFn_recorder {
	a.Recorder.Recorder.AnyParam(1)
	return a.Recorder
}

func (r *MoqPassByArrayFn_recorder) Seq() *MoqPassByArrayFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(true, "Seq", true) {
		return nil
	}
	return r
}

func (r *MoqPassByArrayFn_recorder) NoSeq() *MoqPassByArrayFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(false, "NoSeq", true) {
		return nil
	}
	return r
}

func (r *MoqPassByArrayFn_recorder) ReturnResults(result1 [3]testmoqs.Results) *MoqPassByArrayFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.ReturnResults(MoqPassByArrayFn_results{
		Result1: result1,
	})
	return r
}

func (r *MoqPassByArrayFn_recorder) AndDo(fn MoqPassByArrayFn_doFn) *MoqPassByArrayFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.AndDo(func(params MoqPassByArrayFn_params) {
		fn(params.P)
	}, true) {
		return nil
	}
	return r
}

func (r *MoqPassByArrayFn_recorder) DoReturnResults(fn MoqPassByArrayFn_doReturnFn) *MoqPassByArrayFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.DoReturnResults(func(params MoqPassByArrayFn_params) *MoqPassByArrayFn_results {
		result1 := fn(params.P)
		return &MoqPassByArrayFn_results{
			Result1: result1,
		}
	})
	return r
}

func (r *MoqPassByArrayFn_recorder) Repeat(repeaters ...moq.Repeater) *MoqPassByArrayFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Repeat(repeaters, true) {
		return nil
	}
	return r
}

func (*MoqPassByArrayFn_adaptor) PrettyParams(params MoqPassByArrayFn_params) string {
	return fmt.Sprintf("PassByArrayFn(%#v)", params.P)
}

func (a *MoqPassByArrayFn_adaptor) ParamsKey(params MoqPassByArrayFn_params, anyParams uint64) MoqPassByArrayFn_paramsKey {
	a.Moq.Moq.Scene.T.Helper()
	pUsed, pUsedHash := impl.ParamKey(
		params.P, 1, a.Moq.Runtime.ParameterIndexing.P, anyParams)
	return MoqPassByArrayFn_paramsKey{
		Params: struct{ P [3]testmoqs.Params }{
			P: pUsed,
		},
		Hashes: struct{ P hash.Hash }{
			P: pUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *MoqPassByArrayFn) Reset() {
	m.Moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqPassByArrayFn) AssertExpectationsMet() {
	m.Moq.Scene.T.Helper()
	m.Moq.AssertExpectationsMet()
}

// MoqPassByChanFn holds the state of a moq of the PassByChanFn type
type MoqPassByChanFn struct {
	Moq *impl.Moq[
		*MoqPassByChanFn_adaptor,
		MoqPassByChanFn_params,
		MoqPassByChanFn_paramsKey,
		MoqPassByChanFn_results,
	]

	Runtime MoqPassByChanFn_runtime
}

// MoqPassByChanFn_runtime holds runtime configuration for the PassByChanFn
// type
type MoqPassByChanFn_runtime struct {
	ParameterIndexing MoqPassByChanFn_paramIndexing
}

// MoqPassByChanFn_adaptor adapts MoqPassByChanFn as needed by the runtime
type MoqPassByChanFn_adaptor struct {
	Moq *MoqPassByChanFn
}

// MoqPassByChanFn_params holds the params of the PassByChanFn type
type MoqPassByChanFn_params struct{ P chan testmoqs.Params }

// MoqPassByChanFn_paramsKey holds the map key params of the PassByChanFn type
type MoqPassByChanFn_paramsKey struct {
	Params struct{ P chan testmoqs.Params }
	Hashes struct{ P hash.Hash }
}

// MoqPassByChanFn_results holds the results of the PassByChanFn type
type MoqPassByChanFn_results struct {
	Result1 chan testmoqs.Results
}

// MoqPassByChanFn_paramIndexing holds the parameter indexing runtime
// configuration for the PassByChanFn type
type MoqPassByChanFn_paramIndexing struct {
	P moq.ParamIndexing
}

// MoqPassByChanFn_doFn defines the type of function needed when calling AndDo
// for the PassByChanFn type
type MoqPassByChanFn_doFn func(p chan testmoqs.Params)

// MoqPassByChanFn_doReturnFn defines the type of function needed when calling
// DoReturnResults for the PassByChanFn type
type MoqPassByChanFn_doReturnFn func(p chan testmoqs.Params) chan testmoqs.Results

// MoqPassByChanFn_recorder routes recorded function calls to the
// MoqPassByChanFn moq
type MoqPassByChanFn_recorder struct {
	Recorder *impl.Recorder[
		*MoqPassByChanFn_adaptor,
		MoqPassByChanFn_params,
		MoqPassByChanFn_paramsKey,
		MoqPassByChanFn_results,
	]
}

// MoqPassByChanFn_anyParams isolates the any params functions of the
// PassByChanFn type
type MoqPassByChanFn_anyParams struct {
	Recorder *MoqPassByChanFn_recorder
}

// NewMoqPassByChanFn creates a new moq of the PassByChanFn type
func NewMoqPassByChanFn(scene *moq.Scene, config *moq.Config) *MoqPassByChanFn {
	adaptor1 := &MoqPassByChanFn_adaptor{}
	m := &MoqPassByChanFn{
		Moq: impl.NewMoq[
			*MoqPassByChanFn_adaptor,
			MoqPassByChanFn_params,
			MoqPassByChanFn_paramsKey,
			MoqPassByChanFn_results,
		](scene, adaptor1, config),

		Runtime: MoqPassByChanFn_runtime{ParameterIndexing: MoqPassByChanFn_paramIndexing{
			P: moq.ParamIndexByValue,
		}},
	}
	adaptor1.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the moq implementation of the PassByChanFn type
func (m *MoqPassByChanFn) Mock() testmoqs.PassByChanFn {
	return func(p chan testmoqs.Params) chan testmoqs.Results {
		m.Moq.Scene.T.Helper()
		params := MoqPassByChanFn_params{
			P: p,
		}

		var result1 chan testmoqs.Results
		if result := m.Moq.Function(params); result != nil {
			result1 = result.Result1
		}
		return result1
	}
}

func (m *MoqPassByChanFn) OnCall(p chan testmoqs.Params) *MoqPassByChanFn_recorder {
	return &MoqPassByChanFn_recorder{
		Recorder: m.Moq.OnCall(MoqPassByChanFn_params{
			P: p,
		}),
	}
}

func (r *MoqPassByChanFn_recorder) Any() *MoqPassByChanFn_anyParams {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.IsAnyPermitted(true) {
		return nil
	}
	return &MoqPassByChanFn_anyParams{Recorder: r}
}

func (a *MoqPassByChanFn_anyParams) P() *MoqPassByChanFn_recorder {
	a.Recorder.Recorder.AnyParam(1)
	return a.Recorder
}

func (r *MoqPassByChanFn_recorder) Seq() *MoqPassByChanFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(true, "Seq", true) {
		return nil
	}
	return r
}

func (r *MoqPassByChanFn_recorder) NoSeq() *MoqPassByChanFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(false, "NoSeq", true) {
		return nil
	}
	return r
}

func (r *MoqPassByChanFn_recorder) ReturnResults(result1 chan testmoqs.Results) *MoqPassByChanFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.ReturnResults(MoqPassByChanFn_results{
		Result1: result1,
	})
	return r
}

func (r *MoqPassByChanFn_recorder) AndDo(fn MoqPassByChanFn_doFn) *MoqPassByChanFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.AndDo(func(params MoqPassByChanFn_params) {
		fn(params.P)
	}, true) {
		return nil
	}
	return r
}

func (r *MoqPassByChanFn_recorder) DoReturnResults(fn MoqPassByChanFn_doReturnFn) *MoqPassByChanFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.DoReturnResults(func(params MoqPassByChanFn_params) *MoqPassByChanFn_results {
		result1 := fn(params.P)
		return &MoqPassByChanFn_results{
			Result1: result1,
		}
	})
	return r
}

func (r *MoqPassByChanFn_recorder) Repeat(repeaters ...moq.Repeater) *MoqPassByChanFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Repeat(repeaters, true) {
		return nil
	}
	return r
}

func (*MoqPassByChanFn_adaptor) PrettyParams(params MoqPassByChanFn_params) string {
	return fmt.Sprintf("PassByChanFn(%#v)", params.P)
}

func (a *MoqPassByChanFn_adaptor) ParamsKey(params MoqPassByChanFn_params, anyParams uint64) MoqPassByChanFn_paramsKey {
	a.Moq.Moq.Scene.T.Helper()
	pUsed, pUsedHash := impl.ParamKey(
		params.P, 1, a.Moq.Runtime.ParameterIndexing.P, anyParams)
	return MoqPassByChanFn_paramsKey{
		Params: struct{ P chan testmoqs.Params }{
			P: pUsed,
		},
		Hashes: struct{ P hash.Hash }{
			P: pUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *MoqPassByChanFn) Reset() {
	m.Moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqPassByChanFn) AssertExpectationsMet() {
	m.Moq.Scene.T.Helper()
	m.Moq.AssertExpectationsMet()
}

// MoqPassByEllipsisFn holds the state of a moq of the PassByEllipsisFn type
type MoqPassByEllipsisFn struct {
	Moq *impl.Moq[
		*MoqPassByEllipsisFn_adaptor,
		MoqPassByEllipsisFn_params,
		MoqPassByEllipsisFn_paramsKey,
		MoqPassByEllipsisFn_results,
	]

	Runtime MoqPassByEllipsisFn_runtime
}

// MoqPassByEllipsisFn_runtime holds runtime configuration for the
// PassByEllipsisFn type
type MoqPassByEllipsisFn_runtime struct {
	ParameterIndexing MoqPassByEllipsisFn_paramIndexing
}

// MoqPassByEllipsisFn_adaptor adapts MoqPassByEllipsisFn as needed by the
// runtime
type MoqPassByEllipsisFn_adaptor struct {
	Moq *MoqPassByEllipsisFn
}

// MoqPassByEllipsisFn_params holds the params of the PassByEllipsisFn type
type MoqPassByEllipsisFn_params struct{ P []testmoqs.Params }

// MoqPassByEllipsisFn_paramsKey holds the map key params of the
// PassByEllipsisFn type
type MoqPassByEllipsisFn_paramsKey struct {
	Params struct{}
	Hashes struct{ P hash.Hash }
}

// MoqPassByEllipsisFn_results holds the results of the PassByEllipsisFn type
type MoqPassByEllipsisFn_results struct {
	Result1 string
	Result2 error
}

// MoqPassByEllipsisFn_paramIndexing holds the parameter indexing runtime
// configuration for the PassByEllipsisFn type
type MoqPassByEllipsisFn_paramIndexing struct {
	P moq.ParamIndexing
}

// MoqPassByEllipsisFn_doFn defines the type of function needed when calling
// AndDo for the PassByEllipsisFn type
type MoqPassByEllipsisFn_doFn func(p ...testmoqs.Params)

// MoqPassByEllipsisFn_doReturnFn defines the type of function needed when
// calling DoReturnResults for the PassByEllipsisFn type
type MoqPassByEllipsisFn_doReturnFn func(p ...testmoqs.Params) (string, error)

// MoqPassByEllipsisFn_recorder routes recorded function calls to the
// MoqPassByEllipsisFn moq
type MoqPassByEllipsisFn_recorder struct {
	Recorder *impl.Recorder[
		*MoqPassByEllipsisFn_adaptor,
		MoqPassByEllipsisFn_params,
		MoqPassByEllipsisFn_paramsKey,
		MoqPassByEllipsisFn_results,
	]
}

// MoqPassByEllipsisFn_anyParams isolates the any params functions of the
// PassByEllipsisFn type
type MoqPassByEllipsisFn_anyParams struct {
	Recorder *MoqPassByEllipsisFn_recorder
}

// NewMoqPassByEllipsisFn creates a new moq of the PassByEllipsisFn type
func NewMoqPassByEllipsisFn(scene *moq.Scene, config *moq.Config) *MoqPassByEllipsisFn {
	adaptor1 := &MoqPassByEllipsisFn_adaptor{}
	m := &MoqPassByEllipsisFn{
		Moq: impl.NewMoq[
			*MoqPassByEllipsisFn_adaptor,
			MoqPassByEllipsisFn_params,
			MoqPassByEllipsisFn_paramsKey,
			MoqPassByEllipsisFn_results,
		](scene, adaptor1, config),

		Runtime: MoqPassByEllipsisFn_runtime{ParameterIndexing: MoqPassByEllipsisFn_paramIndexing{
			P: moq.ParamIndexByHash,
		}},
	}
	adaptor1.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the moq implementation of the PassByEllipsisFn type
func (m *MoqPassByEllipsisFn) Mock() testmoqs.PassByEllipsisFn {
	return func(p ...testmoqs.Params) (string, error) {
		m.Moq.Scene.T.Helper()
		params := MoqPassByEllipsisFn_params{
			P: p,
		}

		var result1 string
		var result2 error
		if result := m.Moq.Function(params); result != nil {
			result1 = result.Result1
			result2 = result.Result2
		}
		return result1, result2
	}
}

func (m *MoqPassByEllipsisFn) OnCall(p ...testmoqs.Params) *MoqPassByEllipsisFn_recorder {
	return &MoqPassByEllipsisFn_recorder{
		Recorder: m.Moq.OnCall(MoqPassByEllipsisFn_params{
			P: p,
		}),
	}
}

func (r *MoqPassByEllipsisFn_recorder) Any() *MoqPassByEllipsisFn_anyParams {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.IsAnyPermitted(true) {
		return nil
	}
	return &MoqPassByEllipsisFn_anyParams{Recorder: r}
}

func (a *MoqPassByEllipsisFn_anyParams) P() *MoqPassByEllipsisFn_recorder {
	a.Recorder.Recorder.AnyParam(1)
	return a.Recorder
}

func (r *MoqPassByEllipsisFn_recorder) Seq() *MoqPassByEllipsisFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(true, "Seq", true) {
		return nil
	}
	return r
}

func (r *MoqPassByEllipsisFn_recorder) NoSeq() *MoqPassByEllipsisFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(false, "NoSeq", true) {
		return nil
	}
	return r
}

func (r *MoqPassByEllipsisFn_recorder) ReturnResults(result1 string, result2 error) *MoqPassByEllipsisFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.ReturnResults(MoqPassByEllipsisFn_results{
		Result1: result1,
		Result2: result2,
	})
	return r
}

func (r *MoqPassByEllipsisFn_recorder) AndDo(fn MoqPassByEllipsisFn_doFn) *MoqPassByEllipsisFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.AndDo(func(params MoqPassByEllipsisFn_params) {
		fn(params.P...)
	}, true) {
		return nil
	}
	return r
}

func (r *MoqPassByEllipsisFn_recorder) DoReturnResults(fn MoqPassByEllipsisFn_doReturnFn) *MoqPassByEllipsisFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.DoReturnResults(func(params MoqPassByEllipsisFn_params) *MoqPassByEllipsisFn_results {
		result1, result2 := fn(params.P...)
		return &MoqPassByEllipsisFn_results{
			Result1: result1,
			Result2: result2,
		}
	})
	return r
}

func (r *MoqPassByEllipsisFn_recorder) Repeat(repeaters ...moq.Repeater) *MoqPassByEllipsisFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Repeat(repeaters, true) {
		return nil
	}
	return r
}

func (*MoqPassByEllipsisFn_adaptor) PrettyParams(params MoqPassByEllipsisFn_params) string {
	return fmt.Sprintf("PassByEllipsisFn(%#v)", params.P)
}

func (a *MoqPassByEllipsisFn_adaptor) ParamsKey(params MoqPassByEllipsisFn_params, anyParams uint64) MoqPassByEllipsisFn_paramsKey {
	a.Moq.Moq.Scene.T.Helper()
	pUsedHash := impl.HashOnlyParamKey(a.Moq.Moq.Scene.T,
		params.P, "p", 1, a.Moq.Runtime.ParameterIndexing.P, anyParams)
	return MoqPassByEllipsisFn_paramsKey{
		Params: struct{}{},
		Hashes: struct{ P hash.Hash }{
			P: pUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *MoqPassByEllipsisFn) Reset() {
	m.Moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqPassByEllipsisFn) AssertExpectationsMet() {
	m.Moq.Scene.T.Helper()
	m.Moq.AssertExpectationsMet()
}

// MoqPassByMapFn holds the state of a moq of the PassByMapFn type
type MoqPassByMapFn struct {
	Moq *impl.Moq[
		*MoqPassByMapFn_adaptor,
		MoqPassByMapFn_params,
		MoqPassByMapFn_paramsKey,
		MoqPassByMapFn_results,
	]

	Runtime MoqPassByMapFn_runtime
}

// MoqPassByMapFn_runtime holds runtime configuration for the PassByMapFn type
type MoqPassByMapFn_runtime struct {
	ParameterIndexing MoqPassByMapFn_paramIndexing
}

// MoqPassByMapFn_adaptor adapts MoqPassByMapFn as needed by the runtime
type MoqPassByMapFn_adaptor struct {
	Moq *MoqPassByMapFn
}

// MoqPassByMapFn_params holds the params of the PassByMapFn type
type MoqPassByMapFn_params struct{ P map[string]testmoqs.Params }

// MoqPassByMapFn_paramsKey holds the map key params of the PassByMapFn type
type MoqPassByMapFn_paramsKey struct {
	Params struct{}
	Hashes struct{ P hash.Hash }
}

// MoqPassByMapFn_results holds the results of the PassByMapFn type
type MoqPassByMapFn_results struct {
	Result1 map[string]testmoqs.Results
}

// MoqPassByMapFn_paramIndexing holds the parameter indexing runtime
// configuration for the PassByMapFn type
type MoqPassByMapFn_paramIndexing struct {
	P moq.ParamIndexing
}

// MoqPassByMapFn_doFn defines the type of function needed when calling AndDo
// for the PassByMapFn type
type MoqPassByMapFn_doFn func(p map[string]testmoqs.Params)

// MoqPassByMapFn_doReturnFn defines the type of function needed when calling
// DoReturnResults for the PassByMapFn type
type MoqPassByMapFn_doReturnFn func(p map[string]testmoqs.Params) map[string]testmoqs.Results

// MoqPassByMapFn_recorder routes recorded function calls to the MoqPassByMapFn
// moq
type MoqPassByMapFn_recorder struct {
	Recorder *impl.Recorder[
		*MoqPassByMapFn_adaptor,
		MoqPassByMapFn_params,
		MoqPassByMapFn_paramsKey,
		MoqPassByMapFn_results,
	]
}

// MoqPassByMapFn_anyParams isolates the any params functions of the
// PassByMapFn type
type MoqPassByMapFn_anyParams struct {
	Recorder *MoqPassByMapFn_recorder
}

// NewMoqPassByMapFn creates a new moq of the PassByMapFn type
func NewMoqPassByMapFn(scene *moq.Scene, config *moq.Config) *MoqPassByMapFn {
	adaptor1 := &MoqPassByMapFn_adaptor{}
	m := &MoqPassByMapFn{
		Moq: impl.NewMoq[
			*MoqPassByMapFn_adaptor,
			MoqPassByMapFn_params,
			MoqPassByMapFn_paramsKey,
			MoqPassByMapFn_results,
		](scene, adaptor1, config),

		Runtime: MoqPassByMapFn_runtime{ParameterIndexing: MoqPassByMapFn_paramIndexing{
			P: moq.ParamIndexByHash,
		}},
	}
	adaptor1.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the moq implementation of the PassByMapFn type
func (m *MoqPassByMapFn) Mock() testmoqs.PassByMapFn {
	return func(p map[string]testmoqs.Params) map[string]testmoqs.Results {
		m.Moq.Scene.T.Helper()
		params := MoqPassByMapFn_params{
			P: p,
		}

		var result1 map[string]testmoqs.Results
		if result := m.Moq.Function(params); result != nil {
			result1 = result.Result1
		}
		return result1
	}
}

func (m *MoqPassByMapFn) OnCall(p map[string]testmoqs.Params) *MoqPassByMapFn_recorder {
	return &MoqPassByMapFn_recorder{
		Recorder: m.Moq.OnCall(MoqPassByMapFn_params{
			P: p,
		}),
	}
}

func (r *MoqPassByMapFn_recorder) Any() *MoqPassByMapFn_anyParams {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.IsAnyPermitted(true) {
		return nil
	}
	return &MoqPassByMapFn_anyParams{Recorder: r}
}

func (a *MoqPassByMapFn_anyParams) P() *MoqPassByMapFn_recorder {
	a.Recorder.Recorder.AnyParam(1)
	return a.Recorder
}

func (r *MoqPassByMapFn_recorder) Seq() *MoqPassByMapFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(true, "Seq", true) {
		return nil
	}
	return r
}

func (r *MoqPassByMapFn_recorder) NoSeq() *MoqPassByMapFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(false, "NoSeq", true) {
		return nil
	}
	return r
}

func (r *MoqPassByMapFn_recorder) ReturnResults(result1 map[string]testmoqs.Results) *MoqPassByMapFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.ReturnResults(MoqPassByMapFn_results{
		Result1: result1,
	})
	return r
}

func (r *MoqPassByMapFn_recorder) AndDo(fn MoqPassByMapFn_doFn) *MoqPassByMapFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.AndDo(func(params MoqPassByMapFn_params) {
		fn(params.P)
	}, true) {
		return nil
	}
	return r
}

func (r *MoqPassByMapFn_recorder) DoReturnResults(fn MoqPassByMapFn_doReturnFn) *MoqPassByMapFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.DoReturnResults(func(params MoqPassByMapFn_params) *MoqPassByMapFn_results {
		result1 := fn(params.P)
		return &MoqPassByMapFn_results{
			Result1: result1,
		}
	})
	return r
}

func (r *MoqPassByMapFn_recorder) Repeat(repeaters ...moq.Repeater) *MoqPassByMapFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Repeat(repeaters, true) {
		return nil
	}
	return r
}

func (*MoqPassByMapFn_adaptor) PrettyParams(params MoqPassByMapFn_params) string {
	return fmt.Sprintf("PassByMapFn(%#v)", params.P)
}

func (a *MoqPassByMapFn_adaptor) ParamsKey(params MoqPassByMapFn_params, anyParams uint64) MoqPassByMapFn_paramsKey {
	a.Moq.Moq.Scene.T.Helper()
	pUsedHash := impl.HashOnlyParamKey(a.Moq.Moq.Scene.T,
		params.P, "p", 1, a.Moq.Runtime.ParameterIndexing.P, anyParams)
	return MoqPassByMapFn_paramsKey{
		Params: struct{}{},
		Hashes: struct{ P hash.Hash }{
			P: pUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *MoqPassByMapFn) Reset() {
	m.Moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqPassByMapFn) AssertExpectationsMet() {
	m.Moq.Scene.T.Helper()
	m.Moq.AssertExpectationsMet()
}

// MoqPassByReferenceFn holds the state of a moq of the PassByReferenceFn type
type MoqPassByReferenceFn struct {
	Moq *impl.Moq[
		*MoqPassByReferenceFn_adaptor,
		MoqPassByReferenceFn_params,
		MoqPassByReferenceFn_paramsKey,
		MoqPassByReferenceFn_results,
	]

	Runtime MoqPassByReferenceFn_runtime
}

// MoqPassByReferenceFn_runtime holds runtime configuration for the
// PassByReferenceFn type
type MoqPassByReferenceFn_runtime struct {
	ParameterIndexing MoqPassByReferenceFn_paramIndexing
}

// MoqPassByReferenceFn_adaptor adapts MoqPassByReferenceFn as needed by the
// runtime
type MoqPassByReferenceFn_adaptor struct {
	Moq *MoqPassByReferenceFn
}

// MoqPassByReferenceFn_params holds the params of the PassByReferenceFn type
type MoqPassByReferenceFn_params struct{ P *testmoqs.Params }

// MoqPassByReferenceFn_paramsKey holds the map key params of the
// PassByReferenceFn type
type MoqPassByReferenceFn_paramsKey struct {
	Params struct{ P *testmoqs.Params }
	Hashes struct{ P hash.Hash }
}

// MoqPassByReferenceFn_results holds the results of the PassByReferenceFn type
type MoqPassByReferenceFn_results struct {
	Result1 *testmoqs.Results
}

// MoqPassByReferenceFn_paramIndexing holds the parameter indexing runtime
// configuration for the PassByReferenceFn type
type MoqPassByReferenceFn_paramIndexing struct {
	P moq.ParamIndexing
}

// MoqPassByReferenceFn_doFn defines the type of function needed when calling
// AndDo for the PassByReferenceFn type
type MoqPassByReferenceFn_doFn func(p *testmoqs.Params)

// MoqPassByReferenceFn_doReturnFn defines the type of function needed when
// calling DoReturnResults for the PassByReferenceFn type
type MoqPassByReferenceFn_doReturnFn func(p *testmoqs.Params) *testmoqs.Results

// MoqPassByReferenceFn_recorder routes recorded function calls to the
// MoqPassByReferenceFn moq
type MoqPassByReferenceFn_recorder struct {
	Recorder *impl.Recorder[
		*MoqPassByReferenceFn_adaptor,
		MoqPassByReferenceFn_params,
		MoqPassByReferenceFn_paramsKey,
		MoqPassByReferenceFn_results,
	]
}

// MoqPassByReferenceFn_anyParams isolates the any params functions of the
// PassByReferenceFn type
type MoqPassByReferenceFn_anyParams struct {
	Recorder *MoqPassByReferenceFn_recorder
}

// NewMoqPassByReferenceFn creates a new moq of the PassByReferenceFn type
func NewMoqPassByReferenceFn(scene *moq.Scene, config *moq.Config) *MoqPassByReferenceFn {
	adaptor1 := &MoqPassByReferenceFn_adaptor{}
	m := &MoqPassByReferenceFn{
		Moq: impl.NewMoq[
			*MoqPassByReferenceFn_adaptor,
			MoqPassByReferenceFn_params,
			MoqPassByReferenceFn_paramsKey,
			MoqPassByReferenceFn_results,
		](scene, adaptor1, config),

		Runtime: MoqPassByReferenceFn_runtime{ParameterIndexing: MoqPassByReferenceFn_paramIndexing{
			P: moq.ParamIndexByHash,
		}},
	}
	adaptor1.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the moq implementation of the PassByReferenceFn type
func (m *MoqPassByReferenceFn) Mock() testmoqs.PassByReferenceFn {
	return func(p *testmoqs.Params) *testmoqs.Results {
		m.Moq.Scene.T.Helper()
		params := MoqPassByReferenceFn_params{
			P: p,
		}

		var result1 *testmoqs.Results
		if result := m.Moq.Function(params); result != nil {
			result1 = result.Result1
		}
		return result1
	}
}

func (m *MoqPassByReferenceFn) OnCall(p *testmoqs.Params) *MoqPassByReferenceFn_recorder {
	return &MoqPassByReferenceFn_recorder{
		Recorder: m.Moq.OnCall(MoqPassByReferenceFn_params{
			P: p,
		}),
	}
}

func (r *MoqPassByReferenceFn_recorder) Any() *MoqPassByReferenceFn_anyParams {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.IsAnyPermitted(true) {
		return nil
	}
	return &MoqPassByReferenceFn_anyParams{Recorder: r}
}

func (a *MoqPassByReferenceFn_anyParams) P() *MoqPassByReferenceFn_recorder {
	a.Recorder.Recorder.AnyParam(1)
	return a.Recorder
}

func (r *MoqPassByReferenceFn_recorder) Seq() *MoqPassByReferenceFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(true, "Seq", true) {
		return nil
	}
	return r
}

func (r *MoqPassByReferenceFn_recorder) NoSeq() *MoqPassByReferenceFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(false, "NoSeq", true) {
		return nil
	}
	return r
}

func (r *MoqPassByReferenceFn_recorder) ReturnResults(result1 *testmoqs.Results) *MoqPassByReferenceFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.ReturnResults(MoqPassByReferenceFn_results{
		Result1: result1,
	})
	return r
}

func (r *MoqPassByReferenceFn_recorder) AndDo(fn MoqPassByReferenceFn_doFn) *MoqPassByReferenceFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.AndDo(func(params MoqPassByReferenceFn_params) {
		fn(params.P)
	}, true) {
		return nil
	}
	return r
}

func (r *MoqPassByReferenceFn_recorder) DoReturnResults(fn MoqPassByReferenceFn_doReturnFn) *MoqPassByReferenceFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.DoReturnResults(func(params MoqPassByReferenceFn_params) *MoqPassByReferenceFn_results {
		result1 := fn(params.P)
		return &MoqPassByReferenceFn_results{
			Result1: result1,
		}
	})
	return r
}

func (r *MoqPassByReferenceFn_recorder) Repeat(repeaters ...moq.Repeater) *MoqPassByReferenceFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Repeat(repeaters, true) {
		return nil
	}
	return r
}

func (*MoqPassByReferenceFn_adaptor) PrettyParams(params MoqPassByReferenceFn_params) string {
	return fmt.Sprintf("PassByReferenceFn(%#v)", params.P)
}

func (a *MoqPassByReferenceFn_adaptor) ParamsKey(params MoqPassByReferenceFn_params, anyParams uint64) MoqPassByReferenceFn_paramsKey {
	a.Moq.Moq.Scene.T.Helper()
	pUsed, pUsedHash := impl.ParamKey(
		params.P, 1, a.Moq.Runtime.ParameterIndexing.P, anyParams)
	return MoqPassByReferenceFn_paramsKey{
		Params: struct{ P *testmoqs.Params }{
			P: pUsed,
		},
		Hashes: struct{ P hash.Hash }{
			P: pUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *MoqPassByReferenceFn) Reset() {
	m.Moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqPassByReferenceFn) AssertExpectationsMet() {
	m.Moq.Scene.T.Helper()
	m.Moq.AssertExpectationsMet()
}

// MoqPassBySliceFn holds the state of a moq of the PassBySliceFn type
type MoqPassBySliceFn struct {
	Moq *impl.Moq[
		*MoqPassBySliceFn_adaptor,
		MoqPassBySliceFn_params,
		MoqPassBySliceFn_paramsKey,
		MoqPassBySliceFn_results,
	]

	Runtime MoqPassBySliceFn_runtime
}

// MoqPassBySliceFn_runtime holds runtime configuration for the PassBySliceFn
// type
type MoqPassBySliceFn_runtime struct {
	ParameterIndexing MoqPassBySliceFn_paramIndexing
}

// MoqPassBySliceFn_adaptor adapts MoqPassBySliceFn as needed by the runtime
type MoqPassBySliceFn_adaptor struct {
	Moq *MoqPassBySliceFn
}

// MoqPassBySliceFn_params holds the params of the PassBySliceFn type
type MoqPassBySliceFn_params struct{ P []testmoqs.Params }

// MoqPassBySliceFn_paramsKey holds the map key params of the PassBySliceFn
// type
type MoqPassBySliceFn_paramsKey struct {
	Params struct{}
	Hashes struct{ P hash.Hash }
}

// MoqPassBySliceFn_results holds the results of the PassBySliceFn type
type MoqPassBySliceFn_results struct {
	Result1 []testmoqs.Results
}

// MoqPassBySliceFn_paramIndexing holds the parameter indexing runtime
// configuration for the PassBySliceFn type
type MoqPassBySliceFn_paramIndexing struct {
	P moq.ParamIndexing
}

// MoqPassBySliceFn_doFn defines the type of function needed when calling AndDo
// for the PassBySliceFn type
type MoqPassBySliceFn_doFn func(p []testmoqs.Params)

// MoqPassBySliceFn_doReturnFn defines the type of function needed when calling
// DoReturnResults for the PassBySliceFn type
type MoqPassBySliceFn_doReturnFn func(p []testmoqs.Params) []testmoqs.Results

// MoqPassBySliceFn_recorder routes recorded function calls to the
// MoqPassBySliceFn moq
type MoqPassBySliceFn_recorder struct {
	Recorder *impl.Recorder[
		*MoqPassBySliceFn_adaptor,
		MoqPassBySliceFn_params,
		MoqPassBySliceFn_paramsKey,
		MoqPassBySliceFn_results,
	]
}

// MoqPassBySliceFn_anyParams isolates the any params functions of the
// PassBySliceFn type
type MoqPassBySliceFn_anyParams struct {
	Recorder *MoqPassBySliceFn_recorder
}

// NewMoqPassBySliceFn creates a new moq of the PassBySliceFn type
func NewMoqPassBySliceFn(scene *moq.Scene, config *moq.Config) *MoqPassBySliceFn {
	adaptor1 := &MoqPassBySliceFn_adaptor{}
	m := &MoqPassBySliceFn{
		Moq: impl.NewMoq[
			*MoqPassBySliceFn_adaptor,
			MoqPassBySliceFn_params,
			MoqPassBySliceFn_paramsKey,
			MoqPassBySliceFn_results,
		](scene, adaptor1, config),

		Runtime: MoqPassBySliceFn_runtime{ParameterIndexing: MoqPassBySliceFn_paramIndexing{
			P: moq.ParamIndexByHash,
		}},
	}
	adaptor1.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the moq implementation of the PassBySliceFn type
func (m *MoqPassBySliceFn) Mock() testmoqs.PassBySliceFn {
	return func(p []testmoqs.Params) []testmoqs.Results {
		m.Moq.Scene.T.Helper()
		params := MoqPassBySliceFn_params{
			P: p,
		}

		var result1 []testmoqs.Results
		if result := m.Moq.Function(params); result != nil {
			result1 = result.Result1
		}
		return result1
	}
}

func (m *MoqPassBySliceFn) OnCall(p []testmoqs.Params) *MoqPassBySliceFn_recorder {
	return &MoqPassBySliceFn_recorder{
		Recorder: m.Moq.OnCall(MoqPassBySliceFn_params{
			P: p,
		}),
	}
}

func (r *MoqPassBySliceFn_recorder) Any() *MoqPassBySliceFn_anyParams {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.IsAnyPermitted(true) {
		return nil
	}
	return &MoqPassBySliceFn_anyParams{Recorder: r}
}

func (a *MoqPassBySliceFn_anyParams) P() *MoqPassBySliceFn_recorder {
	a.Recorder.Recorder.AnyParam(1)
	return a.Recorder
}

func (r *MoqPassBySliceFn_recorder) Seq() *MoqPassBySliceFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(true, "Seq", true) {
		return nil
	}
	return r
}

func (r *MoqPassBySliceFn_recorder) NoSeq() *MoqPassBySliceFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(false, "NoSeq", true) {
		return nil
	}
	return r
}

func (r *MoqPassBySliceFn_recorder) ReturnResults(result1 []testmoqs.Results) *MoqPassBySliceFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.ReturnResults(MoqPassBySliceFn_results{
		Result1: result1,
	})
	return r
}

func (r *MoqPassBySliceFn_recorder) AndDo(fn MoqPassBySliceFn_doFn) *MoqPassBySliceFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.AndDo(func(params MoqPassBySliceFn_params) {
		fn(params.P)
	}, true) {
		return nil
	}
	return r
}

func (r *MoqPassBySliceFn_recorder) DoReturnResults(fn MoqPassBySliceFn_doReturnFn) *MoqPassBySliceFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.DoReturnResults(func(params MoqPassBySliceFn_params) *MoqPassBySliceFn_results {
		result1 := fn(params.P)
		return &MoqPassBySliceFn_results{
			Result1: result1,
		}
	})
	return r
}

func (r *MoqPassBySliceFn_recorder) Repeat(repeaters ...moq.Repeater) *MoqPassBySliceFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Repeat(repeaters, true) {
		return nil
	}
	return r
}

func (*MoqPassBySliceFn_adaptor) PrettyParams(params MoqPassBySliceFn_params) string {
	return fmt.Sprintf("PassBySliceFn(%#v)", params.P)
}

func (a *MoqPassBySliceFn_adaptor) ParamsKey(params MoqPassBySliceFn_params, anyParams uint64) MoqPassBySliceFn_paramsKey {
	a.Moq.Moq.Scene.T.Helper()
	pUsedHash := impl.HashOnlyParamKey(a.Moq.Moq.Scene.T,
		params.P, "p", 1, a.Moq.Runtime.ParameterIndexing.P, anyParams)
	return MoqPassBySliceFn_paramsKey{
		Params: struct{}{},
		Hashes: struct{ P hash.Hash }{
			P: pUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *MoqPassBySliceFn) Reset() {
	m.Moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqPassBySliceFn) AssertExpectationsMet() {
	m.Moq.Scene.T.Helper()
	m.Moq.AssertExpectationsMet()
}

// MoqPassByValueFn holds the state of a moq of the PassByValueFn type
type MoqPassByValueFn struct {
	Moq *impl.Moq[
		*MoqPassByValueFn_adaptor,
		MoqPassByValueFn_params,
		MoqPassByValueFn_paramsKey,
		MoqPassByValueFn_results,
	]

	Runtime MoqPassByValueFn_runtime
}

// MoqPassByValueFn_runtime holds runtime configuration for the PassByValueFn
// type
type MoqPassByValueFn_runtime struct {
	ParameterIndexing MoqPassByValueFn_paramIndexing
}

// MoqPassByValueFn_adaptor adapts MoqPassByValueFn as needed by the runtime
type MoqPassByValueFn_adaptor struct {
	Moq *MoqPassByValueFn
}

// MoqPassByValueFn_params holds the params of the PassByValueFn type
type MoqPassByValueFn_params struct{ P testmoqs.Params }

// MoqPassByValueFn_paramsKey holds the map key params of the PassByValueFn
// type
type MoqPassByValueFn_paramsKey struct {
	Params struct{ P testmoqs.Params }
	Hashes struct{ P hash.Hash }
}

// MoqPassByValueFn_results holds the results of the PassByValueFn type
type MoqPassByValueFn_results struct {
	Result1 testmoqs.Results
}

// MoqPassByValueFn_paramIndexing holds the parameter indexing runtime
// configuration for the PassByValueFn type
type MoqPassByValueFn_paramIndexing struct {
	P moq.ParamIndexing
}

// MoqPassByValueFn_doFn defines the type of function needed when calling AndDo
// for the PassByValueFn type
type MoqPassByValueFn_doFn func(p testmoqs.Params)

// MoqPassByValueFn_doReturnFn defines the type of function needed when calling
// DoReturnResults for the PassByValueFn type
type MoqPassByValueFn_doReturnFn func(p testmoqs.Params) testmoqs.Results

// MoqPassByValueFn_recorder routes recorded function calls to the
// MoqPassByValueFn moq
type MoqPassByValueFn_recorder struct {
	Recorder *impl.Recorder[
		*MoqPassByValueFn_adaptor,
		MoqPassByValueFn_params,
		MoqPassByValueFn_paramsKey,
		MoqPassByValueFn_results,
	]
}

// MoqPassByValueFn_anyParams isolates the any params functions of the
// PassByValueFn type
type MoqPassByValueFn_anyParams struct {
	Recorder *MoqPassByValueFn_recorder
}

// NewMoqPassByValueFn creates a new moq of the PassByValueFn type
func NewMoqPassByValueFn(scene *moq.Scene, config *moq.Config) *MoqPassByValueFn {
	adaptor1 := &MoqPassByValueFn_adaptor{}
	m := &MoqPassByValueFn{
		Moq: impl.NewMoq[
			*MoqPassByValueFn_adaptor,
			MoqPassByValueFn_params,
			MoqPassByValueFn_paramsKey,
			MoqPassByValueFn_results,
		](scene, adaptor1, config),

		Runtime: MoqPassByValueFn_runtime{ParameterIndexing: MoqPassByValueFn_paramIndexing{
			P: moq.ParamIndexByValue,
		}},
	}
	adaptor1.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the moq implementation of the PassByValueFn type
func (m *MoqPassByValueFn) Mock() testmoqs.PassByValueFn {
	return func(p testmoqs.Params) testmoqs.Results {
		m.Moq.Scene.T.Helper()
		params := MoqPassByValueFn_params{
			P: p,
		}

		var result1 testmoqs.Results
		if result := m.Moq.Function(params); result != nil {
			result1 = result.Result1
		}
		return result1
	}
}

func (m *MoqPassByValueFn) OnCall(p testmoqs.Params) *MoqPassByValueFn_recorder {
	return &MoqPassByValueFn_recorder{
		Recorder: m.Moq.OnCall(MoqPassByValueFn_params{
			P: p,
		}),
	}
}

func (r *MoqPassByValueFn_recorder) Any() *MoqPassByValueFn_anyParams {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.IsAnyPermitted(true) {
		return nil
	}
	return &MoqPassByValueFn_anyParams{Recorder: r}
}

func (a *MoqPassByValueFn_anyParams) P() *MoqPassByValueFn_recorder {
	a.Recorder.Recorder.AnyParam(1)
	return a.Recorder
}

func (r *MoqPassByValueFn_recorder) Seq() *MoqPassByValueFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(true, "Seq", true) {
		return nil
	}
	return r
}

func (r *MoqPassByValueFn_recorder) NoSeq() *MoqPassByValueFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(false, "NoSeq", true) {
		return nil
	}
	return r
}

func (r *MoqPassByValueFn_recorder) ReturnResults(result1 testmoqs.Results) *MoqPassByValueFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.ReturnResults(MoqPassByValueFn_results{
		Result1: result1,
	})
	return r
}

func (r *MoqPassByValueFn_recorder) AndDo(fn MoqPassByValueFn_doFn) *MoqPassByValueFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.AndDo(func(params MoqPassByValueFn_params) {
		fn(params.P)
	}, true) {
		return nil
	}
	return r
}

func (r *MoqPassByValueFn_recorder) DoReturnResults(fn MoqPassByValueFn_doReturnFn) *MoqPassByValueFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.DoReturnResults(func(params MoqPassByValueFn_params) *MoqPassByValueFn_results {
		result1 := fn(params.P)
		return &MoqPassByValueFn_results{
			Result1: result1,
		}
	})
	return r
}

func (r *MoqPassByValueFn_recorder) Repeat(repeaters ...moq.Repeater) *MoqPassByValueFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Repeat(repeaters, true) {
		return nil
	}
	return r
}

func (*MoqPassByValueFn_adaptor) PrettyParams(params MoqPassByValueFn_params) string {
	return fmt.Sprintf("PassByValueFn(%#v)", params.P)
}

func (a *MoqPassByValueFn_adaptor) ParamsKey(params MoqPassByValueFn_params, anyParams uint64) MoqPassByValueFn_paramsKey {
	a.Moq.Moq.Scene.T.Helper()
	pUsed, pUsedHash := impl.ParamKey(
		params.P, 1, a.Moq.Runtime.ParameterIndexing.P, anyParams)
	return MoqPassByValueFn_paramsKey{
		Params: struct{ P testmoqs.Params }{
			P: pUsed,
		},
		Hashes: struct{ P hash.Hash }{
			P: pUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *MoqPassByValueFn) Reset() {
	m.Moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqPassByValueFn) AssertExpectationsMet() {
	m.Moq.Scene.T.Helper()
	m.Moq.AssertExpectationsMet()
}

// MoqInterfaceParamFn holds the state of a moq of the InterfaceParamFn type
type MoqInterfaceParamFn struct {
	Moq *impl.Moq[
		*MoqInterfaceParamFn_adaptor,
		MoqInterfaceParamFn_params,
		MoqInterfaceParamFn_paramsKey,
		MoqInterfaceParamFn_results,
	]

	Runtime MoqInterfaceParamFn_runtime
}

// MoqInterfaceParamFn_runtime holds runtime configuration for the
// InterfaceParamFn type
type MoqInterfaceParamFn_runtime struct {
	ParameterIndexing MoqInterfaceParamFn_paramIndexing
}

// MoqInterfaceParamFn_adaptor adapts MoqInterfaceParamFn as needed by the
// runtime
type MoqInterfaceParamFn_adaptor struct {
	Moq *MoqInterfaceParamFn
}

// MoqInterfaceParamFn_params holds the params of the InterfaceParamFn type
type MoqInterfaceParamFn_params struct{ W io.Writer }

// MoqInterfaceParamFn_paramsKey holds the map key params of the
// InterfaceParamFn type
type MoqInterfaceParamFn_paramsKey struct {
	Params struct{ W io.Writer }
	Hashes struct{ W hash.Hash }
}

// MoqInterfaceParamFn_results holds the results of the InterfaceParamFn type
type MoqInterfaceParamFn_results struct {
	SResult string
	Err     error
}

// MoqInterfaceParamFn_paramIndexing holds the parameter indexing runtime
// configuration for the InterfaceParamFn type
type MoqInterfaceParamFn_paramIndexing struct {
	W moq.ParamIndexing
}

// MoqInterfaceParamFn_doFn defines the type of function needed when calling
// AndDo for the InterfaceParamFn type
type MoqInterfaceParamFn_doFn func(w io.Writer)

// MoqInterfaceParamFn_doReturnFn defines the type of function needed when
// calling DoReturnResults for the InterfaceParamFn type
type MoqInterfaceParamFn_doReturnFn func(w io.Writer) (sResult string, err error)

// MoqInterfaceParamFn_recorder routes recorded function calls to the
// MoqInterfaceParamFn moq
type MoqInterfaceParamFn_recorder struct {
	Recorder *impl.Recorder[
		*MoqInterfaceParamFn_adaptor,
		MoqInterfaceParamFn_params,
		MoqInterfaceParamFn_paramsKey,
		MoqInterfaceParamFn_results,
	]
}

// MoqInterfaceParamFn_anyParams isolates the any params functions of the
// InterfaceParamFn type
type MoqInterfaceParamFn_anyParams struct {
	Recorder *MoqInterfaceParamFn_recorder
}

// NewMoqInterfaceParamFn creates a new moq of the InterfaceParamFn type
func NewMoqInterfaceParamFn(scene *moq.Scene, config *moq.Config) *MoqInterfaceParamFn {
	adaptor1 := &MoqInterfaceParamFn_adaptor{}
	m := &MoqInterfaceParamFn{
		Moq: impl.NewMoq[
			*MoqInterfaceParamFn_adaptor,
			MoqInterfaceParamFn_params,
			MoqInterfaceParamFn_paramsKey,
			MoqInterfaceParamFn_results,
		](scene, adaptor1, config),

		Runtime: MoqInterfaceParamFn_runtime{ParameterIndexing: MoqInterfaceParamFn_paramIndexing{
			W: moq.ParamIndexByHash,
		}},
	}
	adaptor1.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the moq implementation of the InterfaceParamFn type
func (m *MoqInterfaceParamFn) Mock() testmoqs.InterfaceParamFn {
	return func(w io.Writer) (string, error) {
		m.Moq.Scene.T.Helper()
		params := MoqInterfaceParamFn_params{
			W: w,
		}

		var result1 string
		var result2 error
		if result := m.Moq.Function(params); result != nil {
			result1 = result.SResult
			result2 = result.Err
		}
		return result1, result2
	}
}

func (m *MoqInterfaceParamFn) OnCall(w io.Writer) *MoqInterfaceParamFn_recorder {
	return &MoqInterfaceParamFn_recorder{
		Recorder: m.Moq.OnCall(MoqInterfaceParamFn_params{
			W: w,
		}),
	}
}

func (r *MoqInterfaceParamFn_recorder) Any() *MoqInterfaceParamFn_anyParams {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.IsAnyPermitted(true) {
		return nil
	}
	return &MoqInterfaceParamFn_anyParams{Recorder: r}
}

func (a *MoqInterfaceParamFn_anyParams) W() *MoqInterfaceParamFn_recorder {
	a.Recorder.Recorder.AnyParam(1)
	return a.Recorder
}

func (r *MoqInterfaceParamFn_recorder) Seq() *MoqInterfaceParamFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(true, "Seq", true) {
		return nil
	}
	return r
}

func (r *MoqInterfaceParamFn_recorder) NoSeq() *MoqInterfaceParamFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(false, "NoSeq", true) {
		return nil
	}
	return r
}

func (r *MoqInterfaceParamFn_recorder) ReturnResults(sResult string, err error) *MoqInterfaceParamFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.ReturnResults(MoqInterfaceParamFn_results{
		SResult: sResult,
		Err:     err,
	})
	return r
}

func (r *MoqInterfaceParamFn_recorder) AndDo(fn MoqInterfaceParamFn_doFn) *MoqInterfaceParamFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.AndDo(func(params MoqInterfaceParamFn_params) {
		fn(params.W)
	}, true) {
		return nil
	}
	return r
}

func (r *MoqInterfaceParamFn_recorder) DoReturnResults(fn MoqInterfaceParamFn_doReturnFn) *MoqInterfaceParamFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.DoReturnResults(func(params MoqInterfaceParamFn_params) *MoqInterfaceParamFn_results {
		sResult, err := fn(params.W)
		return &MoqInterfaceParamFn_results{
			SResult: sResult,
			Err:     err,
		}
	})
	return r
}

func (r *MoqInterfaceParamFn_recorder) Repeat(repeaters ...moq.Repeater) *MoqInterfaceParamFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Repeat(repeaters, true) {
		return nil
	}
	return r
}

func (*MoqInterfaceParamFn_adaptor) PrettyParams(params MoqInterfaceParamFn_params) string {
	return fmt.Sprintf("InterfaceParamFn(%#v)", params.W)
}

func (a *MoqInterfaceParamFn_adaptor) ParamsKey(params MoqInterfaceParamFn_params, anyParams uint64) MoqInterfaceParamFn_paramsKey {
	a.Moq.Moq.Scene.T.Helper()
	wUsed, wUsedHash := impl.ParamKey(
		params.W, 1, a.Moq.Runtime.ParameterIndexing.W, anyParams)
	return MoqInterfaceParamFn_paramsKey{
		Params: struct{ W io.Writer }{
			W: wUsed,
		},
		Hashes: struct{ W hash.Hash }{
			W: wUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *MoqInterfaceParamFn) Reset() {
	m.Moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqInterfaceParamFn) AssertExpectationsMet() {
	m.Moq.Scene.T.Helper()
	m.Moq.AssertExpectationsMet()
}

// MoqInterfaceResultFn holds the state of a moq of the InterfaceResultFn type
type MoqInterfaceResultFn struct {
	Moq *impl.Moq[
		*MoqInterfaceResultFn_adaptor,
		MoqInterfaceResultFn_params,
		MoqInterfaceResultFn_paramsKey,
		MoqInterfaceResultFn_results,
	]

	Runtime MoqInterfaceResultFn_runtime
}

// MoqInterfaceResultFn_runtime holds runtime configuration for the
// InterfaceResultFn type
type MoqInterfaceResultFn_runtime struct {
	ParameterIndexing MoqInterfaceResultFn_paramIndexing
}

// MoqInterfaceResultFn_adaptor adapts MoqInterfaceResultFn as needed by the
// runtime
type MoqInterfaceResultFn_adaptor struct {
	Moq *MoqInterfaceResultFn
}

// MoqInterfaceResultFn_params holds the params of the InterfaceResultFn type
type MoqInterfaceResultFn_params struct {
	SParam string
	BParam bool
}

// MoqInterfaceResultFn_paramsKey holds the map key params of the
// InterfaceResultFn type
type MoqInterfaceResultFn_paramsKey struct {
	Params struct {
		SParam string
		BParam bool
	}
	Hashes struct {
		SParam hash.Hash
		BParam hash.Hash
	}
}

// MoqInterfaceResultFn_results holds the results of the InterfaceResultFn type
type MoqInterfaceResultFn_results struct{ Result1 io.Reader }

// MoqInterfaceResultFn_paramIndexing holds the parameter indexing runtime
// configuration for the InterfaceResultFn type
type MoqInterfaceResultFn_paramIndexing struct {
	SParam moq.ParamIndexing
	BParam moq.ParamIndexing
}

// MoqInterfaceResultFn_doFn defines the type of function needed when calling
// AndDo for the InterfaceResultFn type
type MoqInterfaceResultFn_doFn func(sParam string, bParam bool)

// MoqInterfaceResultFn_doReturnFn defines the type of function needed when
// calling DoReturnResults for the InterfaceResultFn type
type MoqInterfaceResultFn_doReturnFn func(sParam string, bParam bool) (r io.Reader)

// MoqInterfaceResultFn_recorder routes recorded function calls to the
// MoqInterfaceResultFn moq
type MoqInterfaceResultFn_recorder struct {
	Recorder *impl.Recorder[
		*MoqInterfaceResultFn_adaptor,
		MoqInterfaceResultFn_params,
		MoqInterfaceResultFn_paramsKey,
		MoqInterfaceResultFn_results,
	]
}

// MoqInterfaceResultFn_anyParams isolates the any params functions of the
// InterfaceResultFn type
type MoqInterfaceResultFn_anyParams struct {
	Recorder *MoqInterfaceResultFn_recorder
}

// NewMoqInterfaceResultFn creates a new moq of the InterfaceResultFn type
func NewMoqInterfaceResultFn(scene *moq.Scene, config *moq.Config) *MoqInterfaceResultFn {
	adaptor1 := &MoqInterfaceResultFn_adaptor{}
	m := &MoqInterfaceResultFn{
		Moq: impl.NewMoq[
			*MoqInterfaceResultFn_adaptor,
			MoqInterfaceResultFn_params,
			MoqInterfaceResultFn_paramsKey,
			MoqInterfaceResultFn_results,
		](scene, adaptor1, config),

		Runtime: MoqInterfaceResultFn_runtime{ParameterIndexing: MoqInterfaceResultFn_paramIndexing{
			SParam: moq.ParamIndexByValue,
			BParam: moq.ParamIndexByValue,
		}},
	}
	adaptor1.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the moq implementation of the InterfaceResultFn type
func (m *MoqInterfaceResultFn) Mock() testmoqs.InterfaceResultFn {
	return func(sParam string, bParam bool) io.Reader {
		m.Moq.Scene.T.Helper()
		params := MoqInterfaceResultFn_params{
			SParam: sParam,
			BParam: bParam,
		}

		var result1 io.Reader
		if result := m.Moq.Function(params); result != nil {
			result1 = result.Result1
		}
		return result1
	}
}

func (m *MoqInterfaceResultFn) OnCall(sParam string, bParam bool) *MoqInterfaceResultFn_recorder {
	return &MoqInterfaceResultFn_recorder{
		Recorder: m.Moq.OnCall(MoqInterfaceResultFn_params{
			SParam: sParam,
			BParam: bParam,
		}),
	}
}

func (r *MoqInterfaceResultFn_recorder) Any() *MoqInterfaceResultFn_anyParams {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.IsAnyPermitted(true) {
		return nil
	}
	return &MoqInterfaceResultFn_anyParams{Recorder: r}
}

func (a *MoqInterfaceResultFn_anyParams) SParam() *MoqInterfaceResultFn_recorder {
	a.Recorder.Recorder.AnyParam(1)
	return a.Recorder
}

func (a *MoqInterfaceResultFn_anyParams) BParam() *MoqInterfaceResultFn_recorder {
	a.Recorder.Recorder.AnyParam(2)
	return a.Recorder
}

func (r *MoqInterfaceResultFn_recorder) Seq() *MoqInterfaceResultFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(true, "Seq", true) {
		return nil
	}
	return r
}

func (r *MoqInterfaceResultFn_recorder) NoSeq() *MoqInterfaceResultFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(false, "NoSeq", true) {
		return nil
	}
	return r
}

func (r *MoqInterfaceResultFn_recorder) ReturnResults(result1 io.Reader) *MoqInterfaceResultFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.ReturnResults(MoqInterfaceResultFn_results{
		Result1: result1,
	})
	return r
}

func (r *MoqInterfaceResultFn_recorder) AndDo(fn MoqInterfaceResultFn_doFn) *MoqInterfaceResultFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.AndDo(func(params MoqInterfaceResultFn_params) {
		fn(params.SParam, params.BParam)
	}, true) {
		return nil
	}
	return r
}

func (r *MoqInterfaceResultFn_recorder) DoReturnResults(fn MoqInterfaceResultFn_doReturnFn) *MoqInterfaceResultFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.DoReturnResults(func(params MoqInterfaceResultFn_params) *MoqInterfaceResultFn_results {
		result1 := fn(params.SParam, params.BParam)
		return &MoqInterfaceResultFn_results{
			Result1: result1,
		}
	})
	return r
}

func (r *MoqInterfaceResultFn_recorder) Repeat(repeaters ...moq.Repeater) *MoqInterfaceResultFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Repeat(repeaters, true) {
		return nil
	}
	return r
}

func (*MoqInterfaceResultFn_adaptor) PrettyParams(params MoqInterfaceResultFn_params) string {
	return fmt.Sprintf("InterfaceResultFn(%#v, %#v)", params.SParam, params.BParam)
}

func (a *MoqInterfaceResultFn_adaptor) ParamsKey(params MoqInterfaceResultFn_params, anyParams uint64) MoqInterfaceResultFn_paramsKey {
	a.Moq.Moq.Scene.T.Helper()
	sParamUsed, sParamUsedHash := impl.ParamKey(
		params.SParam, 1, a.Moq.Runtime.ParameterIndexing.SParam, anyParams)
	bParamUsed, bParamUsedHash := impl.ParamKey(
		params.BParam, 2, a.Moq.Runtime.ParameterIndexing.BParam, anyParams)
	return MoqInterfaceResultFn_paramsKey{
		Params: struct {
			SParam string
			BParam bool
		}{
			SParam: sParamUsed,
			BParam: bParamUsed,
		},
		Hashes: struct {
			SParam hash.Hash
			BParam hash.Hash
		}{
			SParam: sParamUsedHash,
			BParam: bParamUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *MoqInterfaceResultFn) Reset() {
	m.Moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqInterfaceResultFn) AssertExpectationsMet() {
	m.Moq.Scene.T.Helper()
	m.Moq.AssertExpectationsMet()
}

// MoqGenericParamsFn holds the state of a moq of the GenericParamsFn type
type MoqGenericParamsFn[S, B any] struct {
	Moq *impl.Moq[
		*MoqGenericParamsFn_adaptor[S, B],
		MoqGenericParamsFn_params[S, B],
		MoqGenericParamsFn_paramsKey[S, B],
		MoqGenericParamsFn_results[S, B]]

	Runtime MoqGenericParamsFn_runtime
}

// MoqGenericParamsFn_runtime holds runtime configuration for the
// GenericParamsFn type
type MoqGenericParamsFn_runtime struct {
	ParameterIndexing MoqGenericParamsFn_paramIndexing
}

// MoqGenericParamsFn_adaptor adapts MoqGenericParamsFn as needed by the
// runtime
type MoqGenericParamsFn_adaptor[S, B any] struct {
	Moq *MoqGenericParamsFn[S, B]
}

// MoqGenericParamsFn_params holds the params of the GenericParamsFn type
type MoqGenericParamsFn_params[S, B any] struct {
	Param1 S
	Param2 B
}

// MoqGenericParamsFn_paramsKey holds the map key params of the GenericParamsFn
// type
type MoqGenericParamsFn_paramsKey[S, B any] struct {
	Params struct{}
	Hashes struct {
		Param1 hash.Hash
		Param2 hash.Hash
	}
}

// MoqGenericParamsFn_results holds the results of the GenericParamsFn type
type MoqGenericParamsFn_results[S, B any] struct {
	Result1 string
	Result2 error
}

// MoqGenericParamsFn_paramIndexing holds the parameter indexing runtime
// configuration for the GenericParamsFn type
type MoqGenericParamsFn_paramIndexing struct {
	Param1 moq.ParamIndexing
	Param2 moq.ParamIndexing
}

// MoqGenericParamsFn_doFn defines the type of function needed when calling
// AndDo for the GenericParamsFn type
type MoqGenericParamsFn_doFn[S, B any] func(S, B)

// MoqGenericParamsFn_doReturnFn defines the type of function needed when
// calling DoReturnResults for the GenericParamsFn type
type MoqGenericParamsFn_doReturnFn[S, B any] func(S, B) (string, error)

// MoqGenericParamsFn_recorder routes recorded function calls to the
// MoqGenericParamsFn moq
type MoqGenericParamsFn_recorder[S, B any] struct {
	Recorder *impl.Recorder[
		*MoqGenericParamsFn_adaptor[S, B],
		MoqGenericParamsFn_params[S, B],
		MoqGenericParamsFn_paramsKey[S, B],
		MoqGenericParamsFn_results[S, B]]
}

// MoqGenericParamsFn_anyParams isolates the any params functions of the
// GenericParamsFn type
type MoqGenericParamsFn_anyParams[S, B any] struct {
	Recorder *MoqGenericParamsFn_recorder[S, B]
}

// NewMoqGenericParamsFn creates a new moq of the GenericParamsFn type
func NewMoqGenericParamsFn[S, B any](scene *moq.Scene, config *moq.Config) *MoqGenericParamsFn[S, B] {
	adaptor1 := &MoqGenericParamsFn_adaptor[S, B]{}
	m := &MoqGenericParamsFn[S, B]{
		Moq: impl.NewMoq[
			*MoqGenericParamsFn_adaptor[S, B],
			MoqGenericParamsFn_params[S, B],
			MoqGenericParamsFn_paramsKey[S, B],
			MoqGenericParamsFn_results[S, B]](scene, adaptor1, config),

		Runtime: MoqGenericParamsFn_runtime{ParameterIndexing: MoqGenericParamsFn_paramIndexing{
			Param1: moq.ParamIndexByHash,
			Param2: moq.ParamIndexByHash,
		}},
	}
	adaptor1.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the moq implementation of the GenericParamsFn type
func (m *MoqGenericParamsFn[S, B]) Mock() testmoqs.GenericParamsFn[S, B] {
	return func(param1 S, param2 B) (string, error) {
		m.Moq.Scene.T.Helper()
		params := MoqGenericParamsFn_params[S, B]{
			Param1: param1,
			Param2: param2,
		}

		var result1 string
		var result2 error
		if result := m.Moq.Function(params); result != nil {
			result1 = result.Result1
			result2 = result.Result2
		}
		return result1, result2
	}
}

func (m *MoqGenericParamsFn[S, B]) OnCall(param1 S, param2 B) *MoqGenericParamsFn_recorder[S, B] {
	return &MoqGenericParamsFn_recorder[S, B]{
		Recorder: m.Moq.OnCall(MoqGenericParamsFn_params[S, B]{
			Param1: param1,
			Param2: param2,
		}),
	}
}

func (r *MoqGenericParamsFn_recorder[S, B]) Any() *MoqGenericParamsFn_anyParams[S, B] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.IsAnyPermitted(true) {
		return nil
	}
	return &MoqGenericParamsFn_anyParams[S, B]{Recorder: r}
}

func (a *MoqGenericParamsFn_anyParams[S, B]) Param1() *MoqGenericParamsFn_recorder[S, B] {
	a.Recorder.Recorder.AnyParam(1)
	return a.Recorder
}

func (a *MoqGenericParamsFn_anyParams[S, B]) Param2() *MoqGenericParamsFn_recorder[S, B] {
	a.Recorder.Recorder.AnyParam(2)
	return a.Recorder
}

func (r *MoqGenericParamsFn_recorder[S, B]) Seq() *MoqGenericParamsFn_recorder[S, B] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(true, "Seq", true) {
		return nil
	}
	return r
}

func (r *MoqGenericParamsFn_recorder[S, B]) NoSeq() *MoqGenericParamsFn_recorder[S, B] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(false, "NoSeq", true) {
		return nil
	}
	return r
}

func (r *MoqGenericParamsFn_recorder[S, B]) ReturnResults(result1 string, result2 error) *MoqGenericParamsFn_recorder[S, B] {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.ReturnResults(MoqGenericParamsFn_results[S, B]{
		Result1: result1,
		Result2: result2,
	})
	return r
}

func (r *MoqGenericParamsFn_recorder[S, B]) AndDo(fn MoqGenericParamsFn_doFn[S, B]) *MoqGenericParamsFn_recorder[S, B] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.AndDo(func(params MoqGenericParamsFn_params[S, B]) {
		fn(params.Param1, params.Param2)
	}, true) {
		return nil
	}
	return r
}

func (r *MoqGenericParamsFn_recorder[S, B]) DoReturnResults(fn MoqGenericParamsFn_doReturnFn[S, B]) *MoqGenericParamsFn_recorder[S, B] {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.DoReturnResults(func(params MoqGenericParamsFn_params[S, B]) *MoqGenericParamsFn_results[S, B] {
		result1, result2 := fn(params.Param1, params.Param2)
		return &MoqGenericParamsFn_results[S, B]{
			Result1: result1,
			Result2: result2,
		}
	})
	return r
}

func (r *MoqGenericParamsFn_recorder[S, B]) Repeat(repeaters ...moq.Repeater) *MoqGenericParamsFn_recorder[S, B] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Repeat(repeaters, true) {
		return nil
	}
	return r
}

func (*MoqGenericParamsFn_adaptor[S, B]) PrettyParams(params MoqGenericParamsFn_params[S, B]) string {
	return fmt.Sprintf("GenericParamsFn(%#v, %#v)", params.Param1, params.Param2)
}

func (a *MoqGenericParamsFn_adaptor[S, B]) ParamsKey(params MoqGenericParamsFn_params[S, B], anyParams uint64) MoqGenericParamsFn_paramsKey[S, B] {
	a.Moq.Moq.Scene.T.Helper()
	param1UsedHash := impl.HashOnlyParamKey(a.Moq.Moq.Scene.T,
		params.Param1, "param1", 1, a.Moq.Runtime.ParameterIndexing.Param1, anyParams)
	param2UsedHash := impl.HashOnlyParamKey(a.Moq.Moq.Scene.T,
		params.Param2, "param2", 2, a.Moq.Runtime.ParameterIndexing.Param2, anyParams)
	return MoqGenericParamsFn_paramsKey[S, B]{
		Params: struct{}{},
		Hashes: struct {
			Param1 hash.Hash
			Param2 hash.Hash
		}{
			Param1: param1UsedHash,
			Param2: param2UsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *MoqGenericParamsFn[S, B]) Reset() {
	m.Moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqGenericParamsFn[S, B]) AssertExpectationsMet() {
	m.Moq.Scene.T.Helper()
	m.Moq.AssertExpectationsMet()
}

// MoqPartialGenericParamsFn holds the state of a moq of the
// PartialGenericParamsFn type
type MoqPartialGenericParamsFn[S any] struct {
	Moq *impl.Moq[
		*MoqPartialGenericParamsFn_adaptor[S],
		MoqPartialGenericParamsFn_params[S],
		MoqPartialGenericParamsFn_paramsKey[S],
		MoqPartialGenericParamsFn_results[S]]

	Runtime MoqPartialGenericParamsFn_runtime
}

// MoqPartialGenericParamsFn_runtime holds runtime configuration for the
// PartialGenericParamsFn type
type MoqPartialGenericParamsFn_runtime struct {
	ParameterIndexing MoqPartialGenericParamsFn_paramIndexing
}

// MoqPartialGenericParamsFn_adaptor adapts MoqPartialGenericParamsFn as needed
// by the runtime
type MoqPartialGenericParamsFn_adaptor[S any] struct {
	Moq *MoqPartialGenericParamsFn[S]
}

// MoqPartialGenericParamsFn_params holds the params of the
// PartialGenericParamsFn type
type MoqPartialGenericParamsFn_params[S any] struct {
	Param1 S
	Param2 bool
}

// MoqPartialGenericParamsFn_paramsKey holds the map key params of the
// PartialGenericParamsFn type
type MoqPartialGenericParamsFn_paramsKey[S any] struct {
	Params struct{ Param2 bool }
	Hashes struct {
		Param1 hash.Hash
		Param2 hash.Hash
	}
}

// MoqPartialGenericParamsFn_results holds the results of the
// PartialGenericParamsFn type
type MoqPartialGenericParamsFn_results[S any] struct {
	Result1 string
	Result2 error
}

// MoqPartialGenericParamsFn_paramIndexing holds the parameter indexing runtime
// configuration for the PartialGenericParamsFn type
type MoqPartialGenericParamsFn_paramIndexing struct {
	Param1 moq.ParamIndexing
	Param2 moq.ParamIndexing
}

// MoqPartialGenericParamsFn_doFn defines the type of function needed when
// calling AndDo for the PartialGenericParamsFn type
type MoqPartialGenericParamsFn_doFn[S any] func(S, bool)

// MoqPartialGenericParamsFn_doReturnFn defines the type of function needed
// when calling DoReturnResults for the PartialGenericParamsFn type
type MoqPartialGenericParamsFn_doReturnFn[S any] func(S, bool) (string, error)

// MoqPartialGenericParamsFn_recorder routes recorded function calls to the
// MoqPartialGenericParamsFn moq
type MoqPartialGenericParamsFn_recorder[S any] struct {
	Recorder *impl.Recorder[
		*MoqPartialGenericParamsFn_adaptor[S],
		MoqPartialGenericParamsFn_params[S],
		MoqPartialGenericParamsFn_paramsKey[S],
		MoqPartialGenericParamsFn_results[S]]
}

// MoqPartialGenericParamsFn_anyParams isolates the any params functions of the
// PartialGenericParamsFn type
type MoqPartialGenericParamsFn_anyParams[S any] struct {
	Recorder *MoqPartialGenericParamsFn_recorder[S]
}

// NewMoqPartialGenericParamsFn creates a new moq of the PartialGenericParamsFn
// type
func NewMoqPartialGenericParamsFn[S any](scene *moq.Scene, config *moq.Config) *MoqPartialGenericParamsFn[S] {
	adaptor1 := &MoqPartialGenericParamsFn_adaptor[S]{}
	m := &MoqPartialGenericParamsFn[S]{
		Moq: impl.NewMoq[
			*MoqPartialGenericParamsFn_adaptor[S],
			MoqPartialGenericParamsFn_params[S],
			MoqPartialGenericParamsFn_paramsKey[S],
			MoqPartialGenericParamsFn_results[S]](scene, adaptor1, config),

		Runtime: MoqPartialGenericParamsFn_runtime{ParameterIndexing: MoqPartialGenericParamsFn_paramIndexing{
			Param1: moq.ParamIndexByHash,
			Param2: moq.ParamIndexByValue,
		}},
	}
	adaptor1.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the moq implementation of the PartialGenericParamsFn type
func (m *MoqPartialGenericParamsFn[S]) Mock() testmoqs.PartialGenericParamsFn[S] {
	return func(param1 S, param2 bool) (string, error) {
		m.Moq.Scene.T.Helper()
		params := MoqPartialGenericParamsFn_params[S]{
			Param1: param1,
			Param2: param2,
		}

		var result1 string
		var result2 error
		if result := m.Moq.Function(params); result != nil {
			result1 = result.Result1
			result2 = result.Result2
		}
		return result1, result2
	}
}

func (m *MoqPartialGenericParamsFn[S]) OnCall(param1 S, param2 bool) *MoqPartialGenericParamsFn_recorder[S] {
	return &MoqPartialGenericParamsFn_recorder[S]{
		Recorder: m.Moq.OnCall(MoqPartialGenericParamsFn_params[S]{
			Param1: param1,
			Param2: param2,
		}),
	}
}

func (r *MoqPartialGenericParamsFn_recorder[S]) Any() *MoqPartialGenericParamsFn_anyParams[S] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.IsAnyPermitted(true) {
		return nil
	}
	return &MoqPartialGenericParamsFn_anyParams[S]{Recorder: r}
}

func (a *MoqPartialGenericParamsFn_anyParams[S]) Param1() *MoqPartialGenericParamsFn_recorder[S] {
	a.Recorder.Recorder.AnyParam(1)
	return a.Recorder
}

func (a *MoqPartialGenericParamsFn_anyParams[S]) Param2() *MoqPartialGenericParamsFn_recorder[S] {
	a.Recorder.Recorder.AnyParam(2)
	return a.Recorder
}

func (r *MoqPartialGenericParamsFn_recorder[S]) Seq() *MoqPartialGenericParamsFn_recorder[S] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(true, "Seq", true) {
		return nil
	}
	return r
}

func (r *MoqPartialGenericParamsFn_recorder[S]) NoSeq() *MoqPartialGenericParamsFn_recorder[S] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(false, "NoSeq", true) {
		return nil
	}
	return r
}

func (r *MoqPartialGenericParamsFn_recorder[S]) ReturnResults(result1 string, result2 error) *MoqPartialGenericParamsFn_recorder[S] {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.ReturnResults(MoqPartialGenericParamsFn_results[S]{
		Result1: result1,
		Result2: result2,
	})
	return r
}

func (r *MoqPartialGenericParamsFn_recorder[S]) AndDo(fn MoqPartialGenericParamsFn_doFn[S]) *MoqPartialGenericParamsFn_recorder[S] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.AndDo(func(params MoqPartialGenericParamsFn_params[S]) {
		fn(params.Param1, params.Param2)
	}, true) {
		return nil
	}
	return r
}

func (r *MoqPartialGenericParamsFn_recorder[S]) DoReturnResults(fn MoqPartialGenericParamsFn_doReturnFn[S]) *MoqPartialGenericParamsFn_recorder[S] {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.DoReturnResults(func(params MoqPartialGenericParamsFn_params[S]) *MoqPartialGenericParamsFn_results[S] {
		result1, result2 := fn(params.Param1, params.Param2)
		return &MoqPartialGenericParamsFn_results[S]{
			Result1: result1,
			Result2: result2,
		}
	})
	return r
}

func (r *MoqPartialGenericParamsFn_recorder[S]) Repeat(repeaters ...moq.Repeater) *MoqPartialGenericParamsFn_recorder[S] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Repeat(repeaters, true) {
		return nil
	}
	return r
}

func (*MoqPartialGenericParamsFn_adaptor[S]) PrettyParams(params MoqPartialGenericParamsFn_params[S]) string {
	return fmt.Sprintf("PartialGenericParamsFn(%#v, %#v)", params.Param1, params.Param2)
}

func (a *MoqPartialGenericParamsFn_adaptor[S]) ParamsKey(params MoqPartialGenericParamsFn_params[S], anyParams uint64) MoqPartialGenericParamsFn_paramsKey[S] {
	a.Moq.Moq.Scene.T.Helper()
	param1UsedHash := impl.HashOnlyParamKey(a.Moq.Moq.Scene.T,
		params.Param1, "param1", 1, a.Moq.Runtime.ParameterIndexing.Param1, anyParams)
	param2Used, param2UsedHash := impl.ParamKey(
		params.Param2, 2, a.Moq.Runtime.ParameterIndexing.Param2, anyParams)
	return MoqPartialGenericParamsFn_paramsKey[S]{
		Params: struct{ Param2 bool }{
			Param2: param2Used,
		},
		Hashes: struct {
			Param1 hash.Hash
			Param2 hash.Hash
		}{
			Param1: param1UsedHash,
			Param2: param2UsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *MoqPartialGenericParamsFn[S]) Reset() {
	m.Moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqPartialGenericParamsFn[S]) AssertExpectationsMet() {
	m.Moq.Scene.T.Helper()
	m.Moq.AssertExpectationsMet()
}

// MoqGenericResultsFn holds the state of a moq of the GenericResultsFn type
type MoqGenericResultsFn[S ~string, E error] struct {
	Moq *impl.Moq[
		*MoqGenericResultsFn_adaptor[S, E],
		MoqGenericResultsFn_params[S, E],
		MoqGenericResultsFn_paramsKey[S, E],
		MoqGenericResultsFn_results[S, E]]

	Runtime MoqGenericResultsFn_runtime
}

// MoqGenericResultsFn_runtime holds runtime configuration for the
// GenericResultsFn type
type MoqGenericResultsFn_runtime struct {
	ParameterIndexing MoqGenericResultsFn_paramIndexing
}

// MoqGenericResultsFn_adaptor adapts MoqGenericResultsFn as needed by the
// runtime
type MoqGenericResultsFn_adaptor[S ~string, E error] struct {
	Moq *MoqGenericResultsFn[S, E]
}

// MoqGenericResultsFn_params holds the params of the GenericResultsFn type
type MoqGenericResultsFn_params[S ~string, E error] struct {
	Param1 string
	Param2 bool
}

// MoqGenericResultsFn_paramsKey holds the map key params of the
// GenericResultsFn type
type MoqGenericResultsFn_paramsKey[S ~string, E error] struct {
	Params struct {
		Param1 string
		Param2 bool
	}
	Hashes struct {
		Param1 hash.Hash
		Param2 hash.Hash
	}
}

// MoqGenericResultsFn_results holds the results of the GenericResultsFn type
type MoqGenericResultsFn_results[S ~string, E error] struct {
	Result1 S
	Result2 E
}

// MoqGenericResultsFn_paramIndexing holds the parameter indexing runtime
// configuration for the GenericResultsFn type
type MoqGenericResultsFn_paramIndexing struct {
	Param1 moq.ParamIndexing
	Param2 moq.ParamIndexing
}

// MoqGenericResultsFn_doFn defines the type of function needed when calling
// AndDo for the GenericResultsFn type
type MoqGenericResultsFn_doFn[S ~string, E error] func(string, bool)

// MoqGenericResultsFn_doReturnFn defines the type of function needed when
// calling DoReturnResults for the GenericResultsFn type
type MoqGenericResultsFn_doReturnFn[S ~string, E error] func(string, bool) (S, E)

// MoqGenericResultsFn_recorder routes recorded function calls to the
// MoqGenericResultsFn moq
type MoqGenericResultsFn_recorder[S ~string, E error] struct {
	Recorder *impl.Recorder[
		*MoqGenericResultsFn_adaptor[S, E],
		MoqGenericResultsFn_params[S, E],
		MoqGenericResultsFn_paramsKey[S, E],
		MoqGenericResultsFn_results[S, E]]
}

// MoqGenericResultsFn_anyParams isolates the any params functions of the
// GenericResultsFn type
type MoqGenericResultsFn_anyParams[S ~string, E error] struct {
	Recorder *MoqGenericResultsFn_recorder[S, E]
}

// NewMoqGenericResultsFn creates a new moq of the GenericResultsFn type
func NewMoqGenericResultsFn[S ~string, E error](scene *moq.Scene, config *moq.Config) *MoqGenericResultsFn[S, E] {
	adaptor1 := &MoqGenericResultsFn_adaptor[S, E]{}
	m := &MoqGenericResultsFn[S, E]{
		Moq: impl.NewMoq[
			*MoqGenericResultsFn_adaptor[S, E],
			MoqGenericResultsFn_params[S, E],
			MoqGenericResultsFn_paramsKey[S, E],
			MoqGenericResultsFn_results[S, E]](scene, adaptor1, config),

		Runtime: MoqGenericResultsFn_runtime{ParameterIndexing: MoqGenericResultsFn_paramIndexing{
			Param1: moq.ParamIndexByValue,
			Param2: moq.ParamIndexByValue,
		}},
	}
	adaptor1.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the moq implementation of the GenericResultsFn type
func (m *MoqGenericResultsFn[S, E]) Mock() testmoqs.GenericResultsFn[S, E] {
	return func(param1 string, param2 bool) (S, E) {
		m.Moq.Scene.T.Helper()
		params := MoqGenericResultsFn_params[S, E]{
			Param1: param1,
			Param2: param2,
		}

		var result1 S
		var result2 E
		if result := m.Moq.Function(params); result != nil {
			result1 = result.Result1
			result2 = result.Result2
		}
		return result1, result2
	}
}

func (m *MoqGenericResultsFn[S, E]) OnCall(param1 string, param2 bool) *MoqGenericResultsFn_recorder[S, E] {
	return &MoqGenericResultsFn_recorder[S, E]{
		Recorder: m.Moq.OnCall(MoqGenericResultsFn_params[S, E]{
			Param1: param1,
			Param2: param2,
		}),
	}
}

func (r *MoqGenericResultsFn_recorder[S, E]) Any() *MoqGenericResultsFn_anyParams[S, E] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.IsAnyPermitted(true) {
		return nil
	}
	return &MoqGenericResultsFn_anyParams[S, E]{Recorder: r}
}

func (a *MoqGenericResultsFn_anyParams[S, E]) Param1() *MoqGenericResultsFn_recorder[S, E] {
	a.Recorder.Recorder.AnyParam(1)
	return a.Recorder
}

func (a *MoqGenericResultsFn_anyParams[S, E]) Param2() *MoqGenericResultsFn_recorder[S, E] {
	a.Recorder.Recorder.AnyParam(2)
	return a.Recorder
}

func (r *MoqGenericResultsFn_recorder[S, E]) Seq() *MoqGenericResultsFn_recorder[S, E] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(true, "Seq", true) {
		return nil
	}
	return r
}

func (r *MoqGenericResultsFn_recorder[S, E]) NoSeq() *MoqGenericResultsFn_recorder[S, E] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(false, "NoSeq", true) {
		return nil
	}
	return r
}

func (r *MoqGenericResultsFn_recorder[S, E]) ReturnResults(result1 S, result2 E) *MoqGenericResultsFn_recorder[S, E] {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.ReturnResults(MoqGenericResultsFn_results[S, E]{
		Result1: result1,
		Result2: result2,
	})
	return r
}

func (r *MoqGenericResultsFn_recorder[S, E]) AndDo(fn MoqGenericResultsFn_doFn[S, E]) *MoqGenericResultsFn_recorder[S, E] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.AndDo(func(params MoqGenericResultsFn_params[S, E]) {
		fn(params.Param1, params.Param2)
	}, true) {
		return nil
	}
	return r
}

func (r *MoqGenericResultsFn_recorder[S, E]) DoReturnResults(fn MoqGenericResultsFn_doReturnFn[S, E]) *MoqGenericResultsFn_recorder[S, E] {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.DoReturnResults(func(params MoqGenericResultsFn_params[S, E]) *MoqGenericResultsFn_results[S, E] {
		result1, result2 := fn(params.Param1, params.Param2)
		return &MoqGenericResultsFn_results[S, E]{
			Result1: result1,
			Result2: result2,
		}
	})
	return r
}

func (r *MoqGenericResultsFn_recorder[S, E]) Repeat(repeaters ...moq.Repeater) *MoqGenericResultsFn_recorder[S, E] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Repeat(repeaters, true) {
		return nil
	}
	return r
}

func (*MoqGenericResultsFn_adaptor[S, E]) PrettyParams(params MoqGenericResultsFn_params[S, E]) string {
	return fmt.Sprintf("GenericResultsFn(%#v, %#v)", params.Param1, params.Param2)
}

func (a *MoqGenericResultsFn_adaptor[S, E]) ParamsKey(params MoqGenericResultsFn_params[S, E], anyParams uint64) MoqGenericResultsFn_paramsKey[S, E] {
	a.Moq.Moq.Scene.T.Helper()
	param1Used, param1UsedHash := impl.ParamKey(
		params.Param1, 1, a.Moq.Runtime.ParameterIndexing.Param1, anyParams)
	param2Used, param2UsedHash := impl.ParamKey(
		params.Param2, 2, a.Moq.Runtime.ParameterIndexing.Param2, anyParams)
	return MoqGenericResultsFn_paramsKey[S, E]{
		Params: struct {
			Param1 string
			Param2 bool
		}{
			Param1: param1Used,
			Param2: param2Used,
		},
		Hashes: struct {
			Param1 hash.Hash
			Param2 hash.Hash
		}{
			Param1: param1UsedHash,
			Param2: param2UsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *MoqGenericResultsFn[S, E]) Reset() {
	m.Moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqGenericResultsFn[S, E]) AssertExpectationsMet() {
	m.Moq.Scene.T.Helper()
	m.Moq.AssertExpectationsMet()
}

// MoqPartialGenericResultsFn holds the state of a moq of the
// PartialGenericResultsFn type
type MoqPartialGenericResultsFn[S ~string] struct {
	Moq *impl.Moq[
		*MoqPartialGenericResultsFn_adaptor[S],
		MoqPartialGenericResultsFn_params[S],
		MoqPartialGenericResultsFn_paramsKey[S],
		MoqPartialGenericResultsFn_results[S]]

	Runtime MoqPartialGenericResultsFn_runtime
}

// MoqPartialGenericResultsFn_runtime holds runtime configuration for the
// PartialGenericResultsFn type
type MoqPartialGenericResultsFn_runtime struct {
	ParameterIndexing MoqPartialGenericResultsFn_paramIndexing
}

// MoqPartialGenericResultsFn_adaptor adapts MoqPartialGenericResultsFn as
// needed by the runtime
type MoqPartialGenericResultsFn_adaptor[S ~string] struct {
	Moq *MoqPartialGenericResultsFn[S]
}

// MoqPartialGenericResultsFn_params holds the params of the
// PartialGenericResultsFn type
type MoqPartialGenericResultsFn_params[S ~string] struct {
	Param1 string
	Param2 bool
}

// MoqPartialGenericResultsFn_paramsKey holds the map key params of the
// PartialGenericResultsFn type
type MoqPartialGenericResultsFn_paramsKey[S ~string] struct {
	Params struct {
		Param1 string
		Param2 bool
	}
	Hashes struct {
		Param1 hash.Hash
		Param2 hash.Hash
	}
}

// MoqPartialGenericResultsFn_results holds the results of the
// PartialGenericResultsFn type
type MoqPartialGenericResultsFn_results[S ~string] struct {
	Result1 S
	Result2 error
}

// MoqPartialGenericResultsFn_paramIndexing holds the parameter indexing
// runtime configuration for the PartialGenericResultsFn type
type MoqPartialGenericResultsFn_paramIndexing struct {
	Param1 moq.ParamIndexing
	Param2 moq.ParamIndexing
}

// MoqPartialGenericResultsFn_doFn defines the type of function needed when
// calling AndDo for the PartialGenericResultsFn type
type MoqPartialGenericResultsFn_doFn[S ~string] func(string, bool)

// MoqPartialGenericResultsFn_doReturnFn defines the type of function needed
// when calling DoReturnResults for the PartialGenericResultsFn type
type MoqPartialGenericResultsFn_doReturnFn[S ~string] func(string, bool) (S, error)

// MoqPartialGenericResultsFn_recorder routes recorded function calls to the
// MoqPartialGenericResultsFn moq
type MoqPartialGenericResultsFn_recorder[S ~string] struct {
	Recorder *impl.Recorder[
		*MoqPartialGenericResultsFn_adaptor[S],
		MoqPartialGenericResultsFn_params[S],
		MoqPartialGenericResultsFn_paramsKey[S],
		MoqPartialGenericResultsFn_results[S]]
}

// MoqPartialGenericResultsFn_anyParams isolates the any params functions of
// the PartialGenericResultsFn type
type MoqPartialGenericResultsFn_anyParams[S ~string] struct {
	Recorder *MoqPartialGenericResultsFn_recorder[S]
}

// NewMoqPartialGenericResultsFn creates a new moq of the
// PartialGenericResultsFn type
func NewMoqPartialGenericResultsFn[S ~string](scene *moq.Scene, config *moq.Config) *MoqPartialGenericResultsFn[S] {
	adaptor1 := &MoqPartialGenericResultsFn_adaptor[S]{}
	m := &MoqPartialGenericResultsFn[S]{
		Moq: impl.NewMoq[
			*MoqPartialGenericResultsFn_adaptor[S],
			MoqPartialGenericResultsFn_params[S],
			MoqPartialGenericResultsFn_paramsKey[S],
			MoqPartialGenericResultsFn_results[S]](scene, adaptor1, config),

		Runtime: MoqPartialGenericResultsFn_runtime{ParameterIndexing: MoqPartialGenericResultsFn_paramIndexing{
			Param1: moq.ParamIndexByValue,
			Param2: moq.ParamIndexByValue,
		}},
	}
	adaptor1.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the moq implementation of the PartialGenericResultsFn type
func (m *MoqPartialGenericResultsFn[S]) Mock() testmoqs.PartialGenericResultsFn[S] {
	return func(param1 string, param2 bool) (S, error) {
		m.Moq.Scene.T.Helper()
		params := MoqPartialGenericResultsFn_params[S]{
			Param1: param1,
			Param2: param2,
		}

		var result1 S
		var result2 error
		if result := m.Moq.Function(params); result != nil {
			result1 = result.Result1
			result2 = result.Result2
		}
		return result1, result2
	}
}

func (m *MoqPartialGenericResultsFn[S]) OnCall(param1 string, param2 bool) *MoqPartialGenericResultsFn_recorder[S] {
	return &MoqPartialGenericResultsFn_recorder[S]{
		Recorder: m.Moq.OnCall(MoqPartialGenericResultsFn_params[S]{
			Param1: param1,
			Param2: param2,
		}),
	}
}

func (r *MoqPartialGenericResultsFn_recorder[S]) Any() *MoqPartialGenericResultsFn_anyParams[S] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.IsAnyPermitted(true) {
		return nil
	}
	return &MoqPartialGenericResultsFn_anyParams[S]{Recorder: r}
}

func (a *MoqPartialGenericResultsFn_anyParams[S]) Param1() *MoqPartialGenericResultsFn_recorder[S] {
	a.Recorder.Recorder.AnyParam(1)
	return a.Recorder
}

func (a *MoqPartialGenericResultsFn_anyParams[S]) Param2() *MoqPartialGenericResultsFn_recorder[S] {
	a.Recorder.Recorder.AnyParam(2)
	return a.Recorder
}

func (r *MoqPartialGenericResultsFn_recorder[S]) Seq() *MoqPartialGenericResultsFn_recorder[S] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(true, "Seq", true) {
		return nil
	}
	return r
}

func (r *MoqPartialGenericResultsFn_recorder[S]) NoSeq() *MoqPartialGenericResultsFn_recorder[S] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(false, "NoSeq", true) {
		return nil
	}
	return r
}

func (r *MoqPartialGenericResultsFn_recorder[S]) ReturnResults(result1 S, result2 error) *MoqPartialGenericResultsFn_recorder[S] {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.ReturnResults(MoqPartialGenericResultsFn_results[S]{
		Result1: result1,
		Result2: result2,
	})
	return r
}

func (r *MoqPartialGenericResultsFn_recorder[S]) AndDo(fn MoqPartialGenericResultsFn_doFn[S]) *MoqPartialGenericResultsFn_recorder[S] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.AndDo(func(params MoqPartialGenericResultsFn_params[S]) {
		fn(params.Param1, params.Param2)
	}, true) {
		return nil
	}
	return r
}

func (r *MoqPartialGenericResultsFn_recorder[S]) DoReturnResults(fn MoqPartialGenericResultsFn_doReturnFn[S]) *MoqPartialGenericResultsFn_recorder[S] {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.DoReturnResults(func(params MoqPartialGenericResultsFn_params[S]) *MoqPartialGenericResultsFn_results[S] {
		result1, result2 := fn(params.Param1, params.Param2)
		return &MoqPartialGenericResultsFn_results[S]{
			Result1: result1,
			Result2: result2,
		}
	})
	return r
}

func (r *MoqPartialGenericResultsFn_recorder[S]) Repeat(repeaters ...moq.Repeater) *MoqPartialGenericResultsFn_recorder[S] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Repeat(repeaters, true) {
		return nil
	}
	return r
}

func (*MoqPartialGenericResultsFn_adaptor[S]) PrettyParams(params MoqPartialGenericResultsFn_params[S]) string {
	return fmt.Sprintf("PartialGenericResultsFn(%#v, %#v)", params.Param1, params.Param2)
}

func (a *MoqPartialGenericResultsFn_adaptor[S]) ParamsKey(params MoqPartialGenericResultsFn_params[S], anyParams uint64) MoqPartialGenericResultsFn_paramsKey[S] {
	a.Moq.Moq.Scene.T.Helper()
	param1Used, param1UsedHash := impl.ParamKey(
		params.Param1, 1, a.Moq.Runtime.ParameterIndexing.Param1, anyParams)
	param2Used, param2UsedHash := impl.ParamKey(
		params.Param2, 2, a.Moq.Runtime.ParameterIndexing.Param2, anyParams)
	return MoqPartialGenericResultsFn_paramsKey[S]{
		Params: struct {
			Param1 string
			Param2 bool
		}{
			Param1: param1Used,
			Param2: param2Used,
		},
		Hashes: struct {
			Param1 hash.Hash
			Param2 hash.Hash
		}{
			Param1: param1UsedHash,
			Param2: param2UsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *MoqPartialGenericResultsFn[S]) Reset() {
	m.Moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqPartialGenericResultsFn[S]) AssertExpectationsMet() {
	m.Moq.Scene.T.Helper()
	m.Moq.AssertExpectationsMet()
}

// MoqGenericInterfaceParamFn holds the state of a moq of the
// GenericInterfaceParamFn type
type MoqGenericInterfaceParamFn[W testmoqs.MyWriter] struct {
	Moq *impl.Moq[
		*MoqGenericInterfaceParamFn_adaptor[W],
		MoqGenericInterfaceParamFn_params[W],
		MoqGenericInterfaceParamFn_paramsKey[W],
		MoqGenericInterfaceParamFn_results[W]]

	Runtime MoqGenericInterfaceParamFn_runtime
}

// MoqGenericInterfaceParamFn_runtime holds runtime configuration for the
// GenericInterfaceParamFn type
type MoqGenericInterfaceParamFn_runtime struct {
	ParameterIndexing MoqGenericInterfaceParamFn_paramIndexing
}

// MoqGenericInterfaceParamFn_adaptor adapts MoqGenericInterfaceParamFn as
// needed by the runtime
type MoqGenericInterfaceParamFn_adaptor[W testmoqs.MyWriter] struct {
	Moq *MoqGenericInterfaceParamFn[W]
}

// MoqGenericInterfaceParamFn_params holds the params of the
// GenericInterfaceParamFn type
type MoqGenericInterfaceParamFn_params[W testmoqs.MyWriter] struct{ W W }

// MoqGenericInterfaceParamFn_paramsKey holds the map key params of the
// GenericInterfaceParamFn type
type MoqGenericInterfaceParamFn_paramsKey[W testmoqs.MyWriter] struct {
	Params struct{}
	Hashes struct{ W hash.Hash }
}

// MoqGenericInterfaceParamFn_results holds the results of the
// GenericInterfaceParamFn type
type MoqGenericInterfaceParamFn_results[W testmoqs.MyWriter] struct {
	SResult string
	Err     error
}

// MoqGenericInterfaceParamFn_paramIndexing holds the parameter indexing
// runtime configuration for the GenericInterfaceParamFn type
type MoqGenericInterfaceParamFn_paramIndexing struct {
	W moq.ParamIndexing
}

// MoqGenericInterfaceParamFn_doFn defines the type of function needed when
// calling AndDo for the GenericInterfaceParamFn type
type MoqGenericInterfaceParamFn_doFn[W testmoqs.MyWriter] func(w W)

// MoqGenericInterfaceParamFn_doReturnFn defines the type of function needed
// when calling DoReturnResults for the GenericInterfaceParamFn type
type MoqGenericInterfaceParamFn_doReturnFn[W testmoqs.MyWriter] func(w W) (sResult string, err error)

// MoqGenericInterfaceParamFn_recorder routes recorded function calls to the
// MoqGenericInterfaceParamFn moq
type MoqGenericInterfaceParamFn_recorder[W testmoqs.MyWriter] struct {
	Recorder *impl.Recorder[
		*MoqGenericInterfaceParamFn_adaptor[W],
		MoqGenericInterfaceParamFn_params[W],
		MoqGenericInterfaceParamFn_paramsKey[W],
		MoqGenericInterfaceParamFn_results[W]]
}

// MoqGenericInterfaceParamFn_anyParams isolates the any params functions of
// the GenericInterfaceParamFn type
type MoqGenericInterfaceParamFn_anyParams[W testmoqs.MyWriter] struct {
	Recorder *MoqGenericInterfaceParamFn_recorder[W]
}

// NewMoqGenericInterfaceParamFn creates a new moq of the
// GenericInterfaceParamFn type
func NewMoqGenericInterfaceParamFn[W testmoqs.MyWriter](scene *moq.Scene, config *moq.Config) *MoqGenericInterfaceParamFn[W] {
	adaptor1 := &MoqGenericInterfaceParamFn_adaptor[W]{}
	m := &MoqGenericInterfaceParamFn[W]{
		Moq: impl.NewMoq[
			*MoqGenericInterfaceParamFn_adaptor[W],
			MoqGenericInterfaceParamFn_params[W],
			MoqGenericInterfaceParamFn_paramsKey[W],
			MoqGenericInterfaceParamFn_results[W]](scene, adaptor1, config),

		Runtime: MoqGenericInterfaceParamFn_runtime{ParameterIndexing: MoqGenericInterfaceParamFn_paramIndexing{
			W: moq.ParamIndexByHash,
		}},
	}
	adaptor1.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the moq implementation of the GenericInterfaceParamFn type
func (m *MoqGenericInterfaceParamFn[W]) Mock() testmoqs.GenericInterfaceParamFn[W] {
	return func(w W) (string, error) {
		m.Moq.Scene.T.Helper()
		params := MoqGenericInterfaceParamFn_params[W]{
			W: w,
		}

		var result1 string
		var result2 error
		if result := m.Moq.Function(params); result != nil {
			result1 = result.SResult
			result2 = result.Err
		}
		return result1, result2
	}
}

func (m *MoqGenericInterfaceParamFn[W]) OnCall(w W) *MoqGenericInterfaceParamFn_recorder[W] {
	return &MoqGenericInterfaceParamFn_recorder[W]{
		Recorder: m.Moq.OnCall(MoqGenericInterfaceParamFn_params[W]{
			W: w,
		}),
	}
}

func (r *MoqGenericInterfaceParamFn_recorder[W]) Any() *MoqGenericInterfaceParamFn_anyParams[W] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.IsAnyPermitted(true) {
		return nil
	}
	return &MoqGenericInterfaceParamFn_anyParams[W]{Recorder: r}
}

func (a *MoqGenericInterfaceParamFn_anyParams[W]) W() *MoqGenericInterfaceParamFn_recorder[W] {
	a.Recorder.Recorder.AnyParam(1)
	return a.Recorder
}

func (r *MoqGenericInterfaceParamFn_recorder[W]) Seq() *MoqGenericInterfaceParamFn_recorder[W] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(true, "Seq", true) {
		return nil
	}
	return r
}

func (r *MoqGenericInterfaceParamFn_recorder[W]) NoSeq() *MoqGenericInterfaceParamFn_recorder[W] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(false, "NoSeq", true) {
		return nil
	}
	return r
}

func (r *MoqGenericInterfaceParamFn_recorder[W]) ReturnResults(sResult string, err error) *MoqGenericInterfaceParamFn_recorder[W] {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.ReturnResults(MoqGenericInterfaceParamFn_results[W]{
		SResult: sResult,
		Err:     err,
	})
	return r
}

func (r *MoqGenericInterfaceParamFn_recorder[W]) AndDo(fn MoqGenericInterfaceParamFn_doFn[W]) *MoqGenericInterfaceParamFn_recorder[W] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.AndDo(func(params MoqGenericInterfaceParamFn_params[W]) {
		fn(params.W)
	}, true) {
		return nil
	}
	return r
}

func (r *MoqGenericInterfaceParamFn_recorder[W]) DoReturnResults(fn MoqGenericInterfaceParamFn_doReturnFn[W]) *MoqGenericInterfaceParamFn_recorder[W] {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.DoReturnResults(func(params MoqGenericInterfaceParamFn_params[W]) *MoqGenericInterfaceParamFn_results[W] {
		sResult, err := fn(params.W)
		return &MoqGenericInterfaceParamFn_results[W]{
			SResult: sResult,
			Err:     err,
		}
	})
	return r
}

func (r *MoqGenericInterfaceParamFn_recorder[W]) Repeat(repeaters ...moq.Repeater) *MoqGenericInterfaceParamFn_recorder[W] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Repeat(repeaters, true) {
		return nil
	}
	return r
}

func (*MoqGenericInterfaceParamFn_adaptor[W]) PrettyParams(params MoqGenericInterfaceParamFn_params[W]) string {
	return fmt.Sprintf("GenericInterfaceParamFn(%#v)", params.W)
}

func (a *MoqGenericInterfaceParamFn_adaptor[W]) ParamsKey(params MoqGenericInterfaceParamFn_params[W], anyParams uint64) MoqGenericInterfaceParamFn_paramsKey[W] {
	a.Moq.Moq.Scene.T.Helper()
	wUsedHash := impl.HashOnlyParamKey(a.Moq.Moq.Scene.T,
		params.W, "w", 1, a.Moq.Runtime.ParameterIndexing.W, anyParams)
	return MoqGenericInterfaceParamFn_paramsKey[W]{
		Params: struct{}{},
		Hashes: struct{ W hash.Hash }{
			W: wUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *MoqGenericInterfaceParamFn[W]) Reset() {
	m.Moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqGenericInterfaceParamFn[W]) AssertExpectationsMet() {
	m.Moq.Scene.T.Helper()
	m.Moq.AssertExpectationsMet()
}

// MoqGenericInterfaceResultFn holds the state of a moq of the
// GenericInterfaceResultFn type
type MoqGenericInterfaceResultFn[R testmoqs.MyReader] struct {
	Moq *impl.Moq[
		*MoqGenericInterfaceResultFn_adaptor[R],
		MoqGenericInterfaceResultFn_params[R],
		MoqGenericInterfaceResultFn_paramsKey[R],
		MoqGenericInterfaceResultFn_results[R]]

	Runtime MoqGenericInterfaceResultFn_runtime
}

// MoqGenericInterfaceResultFn_runtime holds runtime configuration for the
// GenericInterfaceResultFn type
type MoqGenericInterfaceResultFn_runtime struct {
	ParameterIndexing MoqGenericInterfaceResultFn_paramIndexing
}

// MoqGenericInterfaceResultFn_adaptor adapts MoqGenericInterfaceResultFn as
// needed by the runtime
type MoqGenericInterfaceResultFn_adaptor[R testmoqs.MyReader] struct {
	Moq *MoqGenericInterfaceResultFn[R]
}

// MoqGenericInterfaceResultFn_params holds the params of the
// GenericInterfaceResultFn type
type MoqGenericInterfaceResultFn_params[R testmoqs.MyReader] struct {
	SParam string
	BParam bool
}

// MoqGenericInterfaceResultFn_paramsKey holds the map key params of the
// GenericInterfaceResultFn type
type MoqGenericInterfaceResultFn_paramsKey[R testmoqs.MyReader] struct {
	Params struct {
		SParam string
		BParam bool
	}
	Hashes struct {
		SParam hash.Hash
		BParam hash.Hash
	}
}

// MoqGenericInterfaceResultFn_results holds the results of the
// GenericInterfaceResultFn type
type MoqGenericInterfaceResultFn_results[R testmoqs.MyReader] struct{ Result1 R }

// MoqGenericInterfaceResultFn_paramIndexing holds the parameter indexing
// runtime configuration for the GenericInterfaceResultFn type
type MoqGenericInterfaceResultFn_paramIndexing struct {
	SParam moq.ParamIndexing
	BParam moq.ParamIndexing
}

// MoqGenericInterfaceResultFn_doFn defines the type of function needed when
// calling AndDo for the GenericInterfaceResultFn type
type MoqGenericInterfaceResultFn_doFn[R testmoqs.MyReader] func(sParam string, bParam bool)

// MoqGenericInterfaceResultFn_doReturnFn defines the type of function needed
// when calling DoReturnResults for the GenericInterfaceResultFn type
type MoqGenericInterfaceResultFn_doReturnFn[R testmoqs.MyReader] func(sParam string, bParam bool) (r R)

// MoqGenericInterfaceResultFn_recorder routes recorded function calls to the
// MoqGenericInterfaceResultFn moq
type MoqGenericInterfaceResultFn_recorder[R testmoqs.MyReader] struct {
	Recorder *impl.Recorder[
		*MoqGenericInterfaceResultFn_adaptor[R],
		MoqGenericInterfaceResultFn_params[R],
		MoqGenericInterfaceResultFn_paramsKey[R],
		MoqGenericInterfaceResultFn_results[R]]
}

// MoqGenericInterfaceResultFn_anyParams isolates the any params functions of
// the GenericInterfaceResultFn type
type MoqGenericInterfaceResultFn_anyParams[R testmoqs.MyReader] struct {
	Recorder *MoqGenericInterfaceResultFn_recorder[R]
}

// NewMoqGenericInterfaceResultFn creates a new moq of the
// GenericInterfaceResultFn type
func NewMoqGenericInterfaceResultFn[R testmoqs.MyReader](scene *moq.Scene, config *moq.Config) *MoqGenericInterfaceResultFn[R] {
	adaptor1 := &MoqGenericInterfaceResultFn_adaptor[R]{}
	m := &MoqGenericInterfaceResultFn[R]{
		Moq: impl.NewMoq[
			*MoqGenericInterfaceResultFn_adaptor[R],
			MoqGenericInterfaceResultFn_params[R],
			MoqGenericInterfaceResultFn_paramsKey[R],
			MoqGenericInterfaceResultFn_results[R]](scene, adaptor1, config),

		Runtime: MoqGenericInterfaceResultFn_runtime{ParameterIndexing: MoqGenericInterfaceResultFn_paramIndexing{
			SParam: moq.ParamIndexByValue,
			BParam: moq.ParamIndexByValue,
		}},
	}
	adaptor1.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the moq implementation of the GenericInterfaceResultFn type
func (m *MoqGenericInterfaceResultFn[R]) Mock() testmoqs.GenericInterfaceResultFn[R] {
	return func(sParam string, bParam bool) R {
		m.Moq.Scene.T.Helper()
		params := MoqGenericInterfaceResultFn_params[R]{
			SParam: sParam,
			BParam: bParam,
		}

		var result1 R
		if result := m.Moq.Function(params); result != nil {
			result1 = result.Result1
		}
		return result1
	}
}

func (m *MoqGenericInterfaceResultFn[R]) OnCall(sParam string, bParam bool) *MoqGenericInterfaceResultFn_recorder[R] {
	return &MoqGenericInterfaceResultFn_recorder[R]{
		Recorder: m.Moq.OnCall(MoqGenericInterfaceResultFn_params[R]{
			SParam: sParam,
			BParam: bParam,
		}),
	}
}

func (r *MoqGenericInterfaceResultFn_recorder[R]) Any() *MoqGenericInterfaceResultFn_anyParams[R] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.IsAnyPermitted(true) {
		return nil
	}
	return &MoqGenericInterfaceResultFn_anyParams[R]{Recorder: r}
}

func (a *MoqGenericInterfaceResultFn_anyParams[R]) SParam() *MoqGenericInterfaceResultFn_recorder[R] {
	a.Recorder.Recorder.AnyParam(1)
	return a.Recorder
}

func (a *MoqGenericInterfaceResultFn_anyParams[R]) BParam() *MoqGenericInterfaceResultFn_recorder[R] {
	a.Recorder.Recorder.AnyParam(2)
	return a.Recorder
}

func (r *MoqGenericInterfaceResultFn_recorder[R]) Seq() *MoqGenericInterfaceResultFn_recorder[R] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(true, "Seq", true) {
		return nil
	}
	return r
}

func (r *MoqGenericInterfaceResultFn_recorder[R]) NoSeq() *MoqGenericInterfaceResultFn_recorder[R] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(false, "NoSeq", true) {
		return nil
	}
	return r
}

func (r *MoqGenericInterfaceResultFn_recorder[R]) ReturnResults(result1 R) *MoqGenericInterfaceResultFn_recorder[R] {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.ReturnResults(MoqGenericInterfaceResultFn_results[R]{
		Result1: result1,
	})
	return r
}

func (r *MoqGenericInterfaceResultFn_recorder[R]) AndDo(fn MoqGenericInterfaceResultFn_doFn[R]) *MoqGenericInterfaceResultFn_recorder[R] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.AndDo(func(params MoqGenericInterfaceResultFn_params[R]) {
		fn(params.SParam, params.BParam)
	}, true) {
		return nil
	}
	return r
}

func (r *MoqGenericInterfaceResultFn_recorder[R]) DoReturnResults(fn MoqGenericInterfaceResultFn_doReturnFn[R]) *MoqGenericInterfaceResultFn_recorder[R] {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.DoReturnResults(func(params MoqGenericInterfaceResultFn_params[R]) *MoqGenericInterfaceResultFn_results[R] {
		result1 := fn(params.SParam, params.BParam)
		return &MoqGenericInterfaceResultFn_results[R]{
			Result1: result1,
		}
	})
	return r
}

func (r *MoqGenericInterfaceResultFn_recorder[R]) Repeat(repeaters ...moq.Repeater) *MoqGenericInterfaceResultFn_recorder[R] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Repeat(repeaters, true) {
		return nil
	}
	return r
}

func (*MoqGenericInterfaceResultFn_adaptor[R]) PrettyParams(params MoqGenericInterfaceResultFn_params[R]) string {
	return fmt.Sprintf("GenericInterfaceResultFn(%#v, %#v)", params.SParam, params.BParam)
}

func (a *MoqGenericInterfaceResultFn_adaptor[R]) ParamsKey(params MoqGenericInterfaceResultFn_params[R], anyParams uint64) MoqGenericInterfaceResultFn_paramsKey[R] {
	a.Moq.Moq.Scene.T.Helper()
	sParamUsed, sParamUsedHash := impl.ParamKey(
		params.SParam, 1, a.Moq.Runtime.ParameterIndexing.SParam, anyParams)
	bParamUsed, bParamUsedHash := impl.ParamKey(
		params.BParam, 2, a.Moq.Runtime.ParameterIndexing.BParam, anyParams)
	return MoqGenericInterfaceResultFn_paramsKey[R]{
		Params: struct {
			SParam string
			BParam bool
		}{
			SParam: sParamUsed,
			BParam: bParamUsed,
		},
		Hashes: struct {
			SParam hash.Hash
			BParam hash.Hash
		}{
			SParam: sParamUsedHash,
			BParam: bParamUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *MoqGenericInterfaceResultFn[R]) Reset() {
	m.Moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqGenericInterfaceResultFn[R]) AssertExpectationsMet() {
	m.Moq.Scene.T.Helper()
	m.Moq.AssertExpectationsMet()
}

// MoqGenericParamsResultsFn holds the state of a moq of the
// GenericParamsResultsFn type
type MoqGenericParamsResultsFn[S, B any, E error] struct {
	Moq *impl.Moq[
		*MoqGenericParamsResultsFn_adaptor[S, B, E],
		MoqGenericParamsResultsFn_params[S, B, E],
		MoqGenericParamsResultsFn_paramsKey[S, B, E],
		MoqGenericParamsResultsFn_results[S, B, E]]

	Runtime MoqGenericParamsResultsFn_runtime
}

// MoqGenericParamsResultsFn_runtime holds runtime configuration for the
// GenericParamsResultsFn type
type MoqGenericParamsResultsFn_runtime struct {
	ParameterIndexing MoqGenericParamsResultsFn_paramIndexing
}

// MoqGenericParamsResultsFn_adaptor adapts MoqGenericParamsResultsFn as needed
// by the runtime
type MoqGenericParamsResultsFn_adaptor[S, B any, E error] struct {
	Moq *MoqGenericParamsResultsFn[S, B, E]
}

// MoqGenericParamsResultsFn_params holds the params of the
// GenericParamsResultsFn type
type MoqGenericParamsResultsFn_params[S, B any, E error] struct {
	SParam testmoqs.Container[S]
	BParam testmoqs.Container[B]
}

// MoqGenericParamsResultsFn_paramsKey holds the map key params of the
// GenericParamsResultsFn type
type MoqGenericParamsResultsFn_paramsKey[S, B any, E error] struct {
	Params struct{}
	Hashes struct {
		SParam hash.Hash
		BParam hash.Hash
	}
}

// MoqGenericParamsResultsFn_results holds the results of the
// GenericParamsResultsFn type
type MoqGenericParamsResultsFn_results[S, B any, E error] struct {
	SResult testmoqs.Container[S]
	Err     testmoqs.Container[E]
}

// MoqGenericParamsResultsFn_paramIndexing holds the parameter indexing runtime
// configuration for the GenericParamsResultsFn type
type MoqGenericParamsResultsFn_paramIndexing struct {
	SParam moq.ParamIndexing
	BParam moq.ParamIndexing
}

// MoqGenericParamsResultsFn_doFn defines the type of function needed when
// calling AndDo for the GenericParamsResultsFn type
type MoqGenericParamsResultsFn_doFn[S, B any, E error] func(
	sParam testmoqs.Container[S],
	bParam testmoqs.Container[B],
)

// MoqGenericParamsResultsFn_doReturnFn defines the type of function needed
// when calling DoReturnResults for the GenericParamsResultsFn type
type MoqGenericParamsResultsFn_doReturnFn[S, B any, E error] func(
	sParam testmoqs.Container[S],
	bParam testmoqs.Container[B],
) (sResult testmoqs.Container[S], err testmoqs.Container[E])

// MoqGenericParamsResultsFn_recorder routes recorded function calls to the
// MoqGenericParamsResultsFn moq
type MoqGenericParamsResultsFn_recorder[S, B any, E error] struct {
	Recorder *impl.Recorder[
		*MoqGenericParamsResultsFn_adaptor[S, B, E],
		MoqGenericParamsResultsFn_params[S, B, E],
		MoqGenericParamsResultsFn_paramsKey[S, B, E],
		MoqGenericParamsResultsFn_results[S, B, E]]
}

// MoqGenericParamsResultsFn_anyParams isolates the any params functions of the
// GenericParamsResultsFn type
type MoqGenericParamsResultsFn_anyParams[S, B any, E error] struct {
	Recorder *MoqGenericParamsResultsFn_recorder[S, B, E]
}

// NewMoqGenericParamsResultsFn creates a new moq of the GenericParamsResultsFn
// type
func NewMoqGenericParamsResultsFn[S, B any, E error](scene *moq.Scene, config *moq.Config) *MoqGenericParamsResultsFn[S, B, E] {
	adaptor1 := &MoqGenericParamsResultsFn_adaptor[S, B, E]{}
	m := &MoqGenericParamsResultsFn[S, B, E]{
		Moq: impl.NewMoq[
			*MoqGenericParamsResultsFn_adaptor[S, B, E],
			MoqGenericParamsResultsFn_params[S, B, E],
			MoqGenericParamsResultsFn_paramsKey[S, B, E],
			MoqGenericParamsResultsFn_results[S, B, E]](scene, adaptor1, config),

		Runtime: MoqGenericParamsResultsFn_runtime{ParameterIndexing: MoqGenericParamsResultsFn_paramIndexing{
			SParam: moq.ParamIndexByHash,
			BParam: moq.ParamIndexByHash,
		}},
	}
	adaptor1.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the moq implementation of the GenericParamsResultsFn type
func (m *MoqGenericParamsResultsFn[S, B, E]) Mock() testmoqs.GenericParamsResultsFn[S, B, E] {
	return func(
		sParam testmoqs.Container[S],
		bParam testmoqs.Container[B],
	) (testmoqs.Container[S], testmoqs.Container[E]) {
		m.Moq.Scene.T.Helper()
		params := MoqGenericParamsResultsFn_params[S, B, E]{
			SParam: sParam,
			BParam: bParam,
		}

		var result1 testmoqs.Container[S]
		var result2 testmoqs.Container[E]
		if result := m.Moq.Function(params); result != nil {
			result1 = result.SResult
			result2 = result.Err
		}
		return result1, result2
	}
}

func (m *MoqGenericParamsResultsFn[S, B, E]) OnCall(
	sParam testmoqs.Container[S],
	bParam testmoqs.Container[B],
) *MoqGenericParamsResultsFn_recorder[S, B, E] {
	return &MoqGenericParamsResultsFn_recorder[S, B, E]{
		Recorder: m.Moq.OnCall(MoqGenericParamsResultsFn_params[S, B, E]{
			SParam: sParam,
			BParam: bParam,
		}),
	}
}

func (r *MoqGenericParamsResultsFn_recorder[S, B, E]) Any() *MoqGenericParamsResultsFn_anyParams[S, B, E] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.IsAnyPermitted(true) {
		return nil
	}
	return &MoqGenericParamsResultsFn_anyParams[S, B, E]{Recorder: r}
}

func (a *MoqGenericParamsResultsFn_anyParams[S, B, E]) SParam() *MoqGenericParamsResultsFn_recorder[S, B, E] {
	a.Recorder.Recorder.AnyParam(1)
	return a.Recorder
}

func (a *MoqGenericParamsResultsFn_anyParams[S, B, E]) BParam() *MoqGenericParamsResultsFn_recorder[S, B, E] {
	a.Recorder.Recorder.AnyParam(2)
	return a.Recorder
}

func (r *MoqGenericParamsResultsFn_recorder[S, B, E]) Seq() *MoqGenericParamsResultsFn_recorder[S, B, E] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(true, "Seq", true) {
		return nil
	}
	return r
}

func (r *MoqGenericParamsResultsFn_recorder[S, B, E]) NoSeq() *MoqGenericParamsResultsFn_recorder[S, B, E] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(false, "NoSeq", true) {
		return nil
	}
	return r
}

func (r *MoqGenericParamsResultsFn_recorder[S, B, E]) ReturnResults(sResult testmoqs.Container[S], err testmoqs.Container[E]) *MoqGenericParamsResultsFn_recorder[S, B, E] {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.ReturnResults(MoqGenericParamsResultsFn_results[S, B, E]{
		SResult: sResult,
		Err:     err,
	})
	return r
}

func (r *MoqGenericParamsResultsFn_recorder[S, B, E]) AndDo(fn MoqGenericParamsResultsFn_doFn[S, B, E]) *MoqGenericParamsResultsFn_recorder[S, B, E] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.AndDo(func(params MoqGenericParamsResultsFn_params[S, B, E]) {
		fn(params.SParam, params.BParam)
	}, true) {
		return nil
	}
	return r
}

func (r *MoqGenericParamsResultsFn_recorder[S, B, E]) DoReturnResults(fn MoqGenericParamsResultsFn_doReturnFn[S, B, E]) *MoqGenericParamsResultsFn_recorder[S, B, E] {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.DoReturnResults(func(params MoqGenericParamsResultsFn_params[S, B, E]) *MoqGenericParamsResultsFn_results[S, B, E] {
		sResult, err := fn(params.SParam, params.BParam)
		return &MoqGenericParamsResultsFn_results[S, B, E]{
			SResult: sResult,
			Err:     err,
		}
	})
	return r
}

func (r *MoqGenericParamsResultsFn_recorder[S, B, E]) Repeat(repeaters ...moq.Repeater) *MoqGenericParamsResultsFn_recorder[S, B, E] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Repeat(repeaters, true) {
		return nil
	}
	return r
}

func (*MoqGenericParamsResultsFn_adaptor[S, B, E]) PrettyParams(params MoqGenericParamsResultsFn_params[S, B, E]) string {
	return fmt.Sprintf("GenericParamsResultsFn(%#v, %#v)", params.SParam, params.BParam)
}

func (a *MoqGenericParamsResultsFn_adaptor[S, B, E]) ParamsKey(params MoqGenericParamsResultsFn_params[S, B, E], anyParams uint64) MoqGenericParamsResultsFn_paramsKey[S, B, E] {
	a.Moq.Moq.Scene.T.Helper()
	sParamUsedHash := impl.HashOnlyParamKey(a.Moq.Moq.Scene.T,
		params.SParam, "sParam", 1, a.Moq.Runtime.ParameterIndexing.SParam, anyParams)
	bParamUsedHash := impl.HashOnlyParamKey(a.Moq.Moq.Scene.T,
		params.BParam, "bParam", 2, a.Moq.Runtime.ParameterIndexing.BParam, anyParams)
	return MoqGenericParamsResultsFn_paramsKey[S, B, E]{
		Params: struct{}{},
		Hashes: struct {
			SParam hash.Hash
			BParam hash.Hash
		}{
			SParam: sParamUsedHash,
			BParam: bParamUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *MoqGenericParamsResultsFn[S, B, E]) Reset() {
	m.Moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqGenericParamsResultsFn[S, B, E]) AssertExpectationsMet() {
	m.Moq.Scene.T.Helper()
	m.Moq.AssertExpectationsMet()
}

// The following type assertion assures that testmoqs.Usual is mocked
// completely
var _ testmoqs.Usual = (*MoqUsual_mock)(nil)

// MoqUsual holds the state of a moq of the Usual type
type MoqUsual struct {
	Moq *MoqUsual_mock

	Moq_Usual *impl.Moq[
		*MoqUsual_Usual_adaptor,
		MoqUsual_Usual_params,
		MoqUsual_Usual_paramsKey,
		MoqUsual_Usual_results,
	]
	Moq_NoNames *impl.Moq[
		*MoqUsual_NoNames_adaptor,
		MoqUsual_NoNames_params,
		MoqUsual_NoNames_paramsKey,
		MoqUsual_NoNames_results,
	]
	Moq_NoResults *impl.Moq[
		*MoqUsual_NoResults_adaptor,
		MoqUsual_NoResults_params,
		MoqUsual_NoResults_paramsKey,
		MoqUsual_NoResults_results,
	]
	Moq_NoParams *impl.Moq[
		*MoqUsual_NoParams_adaptor,
		MoqUsual_NoParams_params,
		MoqUsual_NoParams_paramsKey,
		MoqUsual_NoParams_results,
	]
	Moq_Nothing *impl.Moq[
		*MoqUsual_Nothing_adaptor,
		MoqUsual_Nothing_params,
		MoqUsual_Nothing_paramsKey,
		MoqUsual_Nothing_results,
	]
	Moq_Variadic *impl.Moq[
		*MoqUsual_Variadic_adaptor,
		MoqUsual_Variadic_params,
		MoqUsual_Variadic_paramsKey,
		MoqUsual_Variadic_results,
	]
	Moq_RepeatedIds *impl.Moq[
		*MoqUsual_RepeatedIds_adaptor,
		MoqUsual_RepeatedIds_params,
		MoqUsual_RepeatedIds_paramsKey,
		MoqUsual_RepeatedIds_results,
	]
	Moq_Times *impl.Moq[
		*MoqUsual_Times_adaptor,
		MoqUsual_Times_params,
		MoqUsual_Times_paramsKey,
		MoqUsual_Times_results,
	]
	Moq_DifficultParamNames *impl.Moq[
		*MoqUsual_DifficultParamNames_adaptor,
		MoqUsual_DifficultParamNames_params,
		MoqUsual_DifficultParamNames_paramsKey,
		MoqUsual_DifficultParamNames_results,
	]
	Moq_DifficultResultNames *impl.Moq[
		*MoqUsual_DifficultResultNames_adaptor,
		MoqUsual_DifficultResultNames_params,
		MoqUsual_DifficultResultNames_paramsKey,
		MoqUsual_DifficultResultNames_results,
	]
	Moq_PassByArray *impl.Moq[
		*MoqUsual_PassByArray_adaptor,
		MoqUsual_PassByArray_params,
		MoqUsual_PassByArray_paramsKey,
		MoqUsual_PassByArray_results,
	]
	Moq_PassByChan *impl.Moq[
		*MoqUsual_PassByChan_adaptor,
		MoqUsual_PassByChan_params,
		MoqUsual_PassByChan_paramsKey,
		MoqUsual_PassByChan_results,
	]
	Moq_PassByEllipsis *impl.Moq[
		*MoqUsual_PassByEllipsis_adaptor,
		MoqUsual_PassByEllipsis_params,
		MoqUsual_PassByEllipsis_paramsKey,
		MoqUsual_PassByEllipsis_results,
	]
	Moq_PassByMap *impl.Moq[
		*MoqUsual_PassByMap_adaptor,
		MoqUsual_PassByMap_params,
		MoqUsual_PassByMap_paramsKey,
		MoqUsual_PassByMap_results,
	]
	Moq_PassByReference *impl.Moq[
		*MoqUsual_PassByReference_adaptor,
		MoqUsual_PassByReference_params,
		MoqUsual_PassByReference_paramsKey,
		MoqUsual_PassByReference_results,
	]
	Moq_PassBySlice *impl.Moq[
		*MoqUsual_PassBySlice_adaptor,
		MoqUsual_PassBySlice_params,
		MoqUsual_PassBySlice_paramsKey,
		MoqUsual_PassBySlice_results,
	]
	Moq_PassByValue *impl.Moq[
		*MoqUsual_PassByValue_adaptor,
		MoqUsual_PassByValue_params,
		MoqUsual_PassByValue_paramsKey,
		MoqUsual_PassByValue_results,
	]
	Moq_InterfaceParam *impl.Moq[
		*MoqUsual_InterfaceParam_adaptor,
		MoqUsual_InterfaceParam_params,
		MoqUsual_InterfaceParam_paramsKey,
		MoqUsual_InterfaceParam_results,
	]
	Moq_InterfaceResult *impl.Moq[
		*MoqUsual_InterfaceResult_adaptor,
		MoqUsual_InterfaceResult_params,
		MoqUsual_InterfaceResult_paramsKey,
		MoqUsual_InterfaceResult_results,
	]
	Moq_FnParam *impl.Moq[
		*MoqUsual_FnParam_adaptor,
		MoqUsual_FnParam_params,
		MoqUsual_FnParam_paramsKey,
		MoqUsual_FnParam_results,
	]
	Moq_Other *impl.Moq[
		*MoqUsual_Other_adaptor,
		MoqUsual_Other_params,
		MoqUsual_Other_paramsKey,
		MoqUsual_Other_results,
	]

	Runtime MoqUsual_runtime
}

// MoqUsual_mock isolates the mock interface of the Usual type
type MoqUsual_mock struct {
	Moq *MoqUsual
}

// MoqUsual_recorder isolates the recorder interface of the Usual type
type MoqUsual_recorder struct {
	Moq *MoqUsual
}

// MoqUsual_runtime holds runtime configuration for the Usual type
type MoqUsual_runtime struct {
	ParameterIndexing struct {
		Usual                MoqUsual_Usual_paramIndexing
		NoNames              MoqUsual_NoNames_paramIndexing
		NoResults            MoqUsual_NoResults_paramIndexing
		NoParams             MoqUsual_NoParams_paramIndexing
		Nothing              MoqUsual_Nothing_paramIndexing
		Variadic             MoqUsual_Variadic_paramIndexing
		RepeatedIds          MoqUsual_RepeatedIds_paramIndexing
		Times                MoqUsual_Times_paramIndexing
		DifficultParamNames  MoqUsual_DifficultParamNames_paramIndexing
		DifficultResultNames MoqUsual_DifficultResultNames_paramIndexing
		PassByArray          MoqUsual_PassByArray_paramIndexing
		PassByChan           MoqUsual_PassByChan_paramIndexing
		PassByEllipsis       MoqUsual_PassByEllipsis_paramIndexing
		PassByMap            MoqUsual_PassByMap_paramIndexing
		PassByReference      MoqUsual_PassByReference_paramIndexing
		PassBySlice          MoqUsual_PassBySlice_paramIndexing
		PassByValue          MoqUsual_PassByValue_paramIndexing
		InterfaceParam       MoqUsual_InterfaceParam_paramIndexing
		InterfaceResult      MoqUsual_InterfaceResult_paramIndexing
		FnParam              MoqUsual_FnParam_paramIndexing
		Other                MoqUsual_Other_paramIndexing
	}
}

// MoqUsual_Usual_adaptor adapts MoqUsual as needed by the runtime
type MoqUsual_Usual_adaptor struct {
	Moq *MoqUsual
}

// MoqUsual_Usual_params holds the params of the Usual type
type MoqUsual_Usual_params struct {
	SParam string
	BParam bool
}

// MoqUsual_Usual_paramsKey holds the map key params of the Usual type
type MoqUsual_Usual_paramsKey struct {
	Params struct {
		SParam string
		BParam bool
	}
	Hashes struct {
		SParam hash.Hash
		BParam hash.Hash
	}
}

// MoqUsual_Usual_results holds the results of the Usual type
type MoqUsual_Usual_results struct {
	SResult string
	Err     error
}

// MoqUsual_Usual_paramIndexing holds the parameter indexing runtime
// configuration for the Usual type
type MoqUsual_Usual_paramIndexing struct {
	SParam moq.ParamIndexing
	BParam moq.ParamIndexing
}

// MoqUsual_Usual_doFn defines the type of function needed when calling AndDo
// for the Usual type
type MoqUsual_Usual_doFn func(sParam string, bParam bool)

// MoqUsual_Usual_doReturnFn defines the type of function needed when calling
// DoReturnResults for the Usual type
type MoqUsual_Usual_doReturnFn func(sParam string, bParam bool) (sResult string, err error)

// MoqUsual_Usual_recorder routes recorded function calls to the MoqUsual moq
type MoqUsual_Usual_recorder struct {
	Recorder *impl.Recorder[
		*MoqUsual_Usual_adaptor,
		MoqUsual_Usual_params,
		MoqUsual_Usual_paramsKey,
		MoqUsual_Usual_results,
	]
}

// MoqUsual_Usual_anyParams isolates the any params functions of the Usual type
type MoqUsual_Usual_anyParams struct {
	Recorder *MoqUsual_Usual_recorder
}

// MoqUsual_NoNames_adaptor adapts MoqUsual as needed by the runtime
type MoqUsual_NoNames_adaptor struct {
	Moq *MoqUsual
}

// MoqUsual_NoNames_params holds the params of the Usual type
type MoqUsual_NoNames_params struct {
	Param1 string
	Param2 bool
}

// MoqUsual_NoNames_paramsKey holds the map key params of the Usual type
type MoqUsual_NoNames_paramsKey struct {
	Params struct {
		Param1 string
		Param2 bool
	}
	Hashes struct {
		Param1 hash.Hash
		Param2 hash.Hash
	}
}

// MoqUsual_NoNames_results holds the results of the Usual type
type MoqUsual_NoNames_results struct {
	Result1 string
	Result2 error
}

// MoqUsual_NoNames_paramIndexing holds the parameter indexing runtime
// configuration for the Usual type
type MoqUsual_NoNames_paramIndexing struct {
	Param1 moq.ParamIndexing
	Param2 moq.ParamIndexing
}

// MoqUsual_NoNames_doFn defines the type of function needed when calling AndDo
// for the Usual type
type MoqUsual_NoNames_doFn func(string, bool)

// MoqUsual_NoNames_doReturnFn defines the type of function needed when calling
// DoReturnResults for the Usual type
type MoqUsual_NoNames_doReturnFn func(string, bool) (string, error)

// MoqUsual_NoNames_recorder routes recorded function calls to the MoqUsual moq
type MoqUsual_NoNames_recorder struct {
	Recorder *impl.Recorder[
		*MoqUsual_NoNames_adaptor,
		MoqUsual_NoNames_params,
		MoqUsual_NoNames_paramsKey,
		MoqUsual_NoNames_results,
	]
}

// MoqUsual_NoNames_anyParams isolates the any params functions of the Usual
// type
type MoqUsual_NoNames_anyParams struct {
	Recorder *MoqUsual_NoNames_recorder
}

// MoqUsual_NoResults_adaptor adapts MoqUsual as needed by the runtime
type MoqUsual_NoResults_adaptor struct {
	Moq *MoqUsual
}

// MoqUsual_NoResults_params holds the params of the Usual type
type MoqUsual_NoResults_params struct {
	SParam string
	BParam bool
}

// MoqUsual_NoResults_paramsKey holds the map key params of the Usual type
type MoqUsual_NoResults_paramsKey struct {
	Params struct {
		SParam string
		BParam bool
	}
	Hashes struct {
		SParam hash.Hash
		BParam hash.Hash
	}
}

// MoqUsual_NoResults_results holds the results of the Usual type
type MoqUsual_NoResults_results struct{}

// MoqUsual_NoResults_paramIndexing holds the parameter indexing runtime
// configuration for the Usual type
type MoqUsual_NoResults_paramIndexing struct {
	SParam moq.ParamIndexing
	BParam moq.ParamIndexing
}

// MoqUsual_NoResults_doFn defines the type of function needed when calling
// AndDo for the Usual type
type MoqUsual_NoResults_doFn func(sParam string, bParam bool)

// MoqUsual_NoResults_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Usual type
type MoqUsual_NoResults_doReturnFn func(sParam string, bParam bool)

// MoqUsual_NoResults_recorder routes recorded function calls to the MoqUsual
// moq
type MoqUsual_NoResults_recorder struct {
	Recorder *impl.Recorder[
		*MoqUsual_NoResults_adaptor,
		MoqUsual_NoResults_params,
		MoqUsual_NoResults_paramsKey,
		MoqUsual_NoResults_results,
	]
}

// MoqUsual_NoResults_anyParams isolates the any params functions of the Usual
// type
type MoqUsual_NoResults_anyParams struct {
	Recorder *MoqUsual_NoResults_recorder
}

// MoqUsual_NoParams_adaptor adapts MoqUsual as needed by the runtime
type MoqUsual_NoParams_adaptor struct {
	Moq *MoqUsual
}

// MoqUsual_NoParams_params holds the params of the Usual type
type MoqUsual_NoParams_params struct{}

// MoqUsual_NoParams_paramsKey holds the map key params of the Usual type
type MoqUsual_NoParams_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqUsual_NoParams_results holds the results of the Usual type
type MoqUsual_NoParams_results struct {
	SResult string
	Err     error
}

// MoqUsual_NoParams_paramIndexing holds the parameter indexing runtime
// configuration for the Usual type
type MoqUsual_NoParams_paramIndexing struct{}

// MoqUsual_NoParams_doFn defines the type of function needed when calling
// AndDo for the Usual type
type MoqUsual_NoParams_doFn func()

// MoqUsual_NoParams_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Usual type
type MoqUsual_NoParams_doReturnFn func() (sResult string, err error)

// MoqUsual_NoParams_recorder routes recorded function calls to the MoqUsual
// moq
type MoqUsual_NoParams_recorder struct {
	Recorder *impl.Recorder[
		*MoqUsual_NoParams_adaptor,
		MoqUsual_NoParams_params,
		MoqUsual_NoParams_paramsKey,
		MoqUsual_NoParams_results,
	]
}

// MoqUsual_NoParams_anyParams isolates the any params functions of the Usual
// type
type MoqUsual_NoParams_anyParams struct {
	Recorder *MoqUsual_NoParams_recorder
}

// MoqUsual_Nothing_adaptor adapts MoqUsual as needed by the runtime
type MoqUsual_Nothing_adaptor struct {
	Moq *MoqUsual
}

// MoqUsual_Nothing_params holds the params of the Usual type
type MoqUsual_Nothing_params struct{}

// MoqUsual_Nothing_paramsKey holds the map key params of the Usual type
type MoqUsual_Nothing_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqUsual_Nothing_results holds the results of the Usual type
type MoqUsual_Nothing_results struct{}

// MoqUsual_Nothing_paramIndexing holds the parameter indexing runtime
// configuration for the Usual type
type MoqUsual_Nothing_paramIndexing struct{}

// MoqUsual_Nothing_doFn defines the type of function needed when calling AndDo
// for the Usual type
type MoqUsual_Nothing_doFn func()

// MoqUsual_Nothing_doReturnFn defines the type of function needed when calling
// DoReturnResults for the Usual type
type MoqUsual_Nothing_doReturnFn func()

// MoqUsual_Nothing_recorder routes recorded function calls to the MoqUsual moq
type MoqUsual_Nothing_recorder struct {
	Recorder *impl.Recorder[
		*MoqUsual_Nothing_adaptor,
		MoqUsual_Nothing_params,
		MoqUsual_Nothing_paramsKey,
		MoqUsual_Nothing_results,
	]
}

// MoqUsual_Nothing_anyParams isolates the any params functions of the Usual
// type
type MoqUsual_Nothing_anyParams struct {
	Recorder *MoqUsual_Nothing_recorder
}

// MoqUsual_Variadic_adaptor adapts MoqUsual as needed by the runtime
type MoqUsual_Variadic_adaptor struct {
	Moq *MoqUsual
}

// MoqUsual_Variadic_params holds the params of the Usual type
type MoqUsual_Variadic_params struct {
	Other bool
	Args  []string
}

// MoqUsual_Variadic_paramsKey holds the map key params of the Usual type
type MoqUsual_Variadic_paramsKey struct {
	Params struct{ Other bool }
	Hashes struct {
		Other hash.Hash
		Args  hash.Hash
	}
}

// MoqUsual_Variadic_results holds the results of the Usual type
type MoqUsual_Variadic_results struct {
	SResult string
	Err     error
}

// MoqUsual_Variadic_paramIndexing holds the parameter indexing runtime
// configuration for the Usual type
type MoqUsual_Variadic_paramIndexing struct {
	Other moq.ParamIndexing
	Args  moq.ParamIndexing
}

// MoqUsual_Variadic_doFn defines the type of function needed when calling
// AndDo for the Usual type
type MoqUsual_Variadic_doFn func(other bool, args ...string)

// MoqUsual_Variadic_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Usual type
type MoqUsual_Variadic_doReturnFn func(other bool, args ...string) (sResult string, err error)

// MoqUsual_Variadic_recorder routes recorded function calls to the MoqUsual
// moq
type MoqUsual_Variadic_recorder struct {
	Recorder *impl.Recorder[
		*MoqUsual_Variadic_adaptor,
		MoqUsual_Variadic_params,
		MoqUsual_Variadic_paramsKey,
		MoqUsual_Variadic_results,
	]
}

// MoqUsual_Variadic_anyParams isolates the any params functions of the Usual
// type
type MoqUsual_Variadic_anyParams struct {
	Recorder *MoqUsual_Variadic_recorder
}

// MoqUsual_RepeatedIds_adaptor adapts MoqUsual as needed by the runtime
type MoqUsual_RepeatedIds_adaptor struct {
	Moq *MoqUsual
}

// MoqUsual_RepeatedIds_params holds the params of the Usual type
type MoqUsual_RepeatedIds_params struct {
	SParam1, SParam2 string
	BParam           bool
}

// MoqUsual_RepeatedIds_paramsKey holds the map key params of the Usual type
type MoqUsual_RepeatedIds_paramsKey struct {
	Params struct {
		SParam1, SParam2 string
		BParam           bool
	}
	Hashes struct {
		SParam1, SParam2 hash.Hash
		BParam           hash.Hash
	}
}

// MoqUsual_RepeatedIds_results holds the results of the Usual type
type MoqUsual_RepeatedIds_results struct {
	SResult1, SResult2 string
	Err                error
}

// MoqUsual_RepeatedIds_paramIndexing holds the parameter indexing runtime
// configuration for the Usual type
type MoqUsual_RepeatedIds_paramIndexing struct {
	SParam1, SParam2 moq.ParamIndexing
	BParam           moq.ParamIndexing
}

// MoqUsual_RepeatedIds_doFn defines the type of function needed when calling
// AndDo for the Usual type
type MoqUsual_RepeatedIds_doFn func(sParam1, sParam2 string, bParam bool)

// MoqUsual_RepeatedIds_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Usual type
type MoqUsual_RepeatedIds_doReturnFn func(sParam1, sParam2 string, bParam bool) (sResult1, sResult2 string, err error)

// MoqUsual_RepeatedIds_recorder routes recorded function calls to the MoqUsual
// moq
type MoqUsual_RepeatedIds_recorder struct {
	Recorder *impl.Recorder[
		*MoqUsual_RepeatedIds_adaptor,
		MoqUsual_RepeatedIds_params,
		MoqUsual_RepeatedIds_paramsKey,
		MoqUsual_RepeatedIds_results,
	]
}

// MoqUsual_RepeatedIds_anyParams isolates the any params functions of the
// Usual type
type MoqUsual_RepeatedIds_anyParams struct {
	Recorder *MoqUsual_RepeatedIds_recorder
}

// MoqUsual_Times_adaptor adapts MoqUsual as needed by the runtime
type MoqUsual_Times_adaptor struct {
	Moq *MoqUsual
}

// MoqUsual_Times_params holds the params of the Usual type
type MoqUsual_Times_params struct {
	SParam string
	Times  bool
}

// MoqUsual_Times_paramsKey holds the map key params of the Usual type
type MoqUsual_Times_paramsKey struct {
	Params struct {
		SParam string
		Times  bool
	}
	Hashes struct {
		SParam hash.Hash
		Times  hash.Hash
	}
}

// MoqUsual_Times_results holds the results of the Usual type
type MoqUsual_Times_results struct {
	SResult string
	Err     error
}

// MoqUsual_Times_paramIndexing holds the parameter indexing runtime
// configuration for the Usual type
type MoqUsual_Times_paramIndexing struct {
	SParam moq.ParamIndexing
	Times  moq.ParamIndexing
}

// MoqUsual_Times_doFn defines the type of function needed when calling AndDo
// for the Usual type
type MoqUsual_Times_doFn func(sParam string, times bool)

// MoqUsual_Times_doReturnFn defines the type of function needed when calling
// DoReturnResults for the Usual type
type MoqUsual_Times_doReturnFn func(sParam string, times bool) (sResult string, err error)

// MoqUsual_Times_recorder routes recorded function calls to the MoqUsual moq
type MoqUsual_Times_recorder struct {
	Recorder *impl.Recorder[
		*MoqUsual_Times_adaptor,
		MoqUsual_Times_params,
		MoqUsual_Times_paramsKey,
		MoqUsual_Times_results,
	]
}

// MoqUsual_Times_anyParams isolates the any params functions of the Usual type
type MoqUsual_Times_anyParams struct {
	Recorder *MoqUsual_Times_recorder
}

// MoqUsual_DifficultParamNames_adaptor adapts MoqUsual as needed by the
// runtime
type MoqUsual_DifficultParamNames_adaptor struct {
	Moq *MoqUsual
}

// MoqUsual_DifficultParamNames_params holds the params of the Usual type
type MoqUsual_DifficultParamNames_params struct {
	Param1, Param2         bool
	Param3                 string
	Param, Param5, Param6  int
	Param7, Param8, Param9 float32
}

// MoqUsual_DifficultParamNames_paramsKey holds the map key params of the Usual
// type
type MoqUsual_DifficultParamNames_paramsKey struct {
	Params struct {
		Param1, Param2         bool
		Param3                 string
		Param, Param5, Param6  int
		Param7, Param8, Param9 float32
	}
	Hashes struct {
		Param1, Param2         hash.Hash
		Param3                 hash.Hash
		Param, Param5, Param6  hash.Hash
		Param7, Param8, Param9 hash.Hash
	}
}

// MoqUsual_DifficultParamNames_results holds the results of the Usual type
type MoqUsual_DifficultParamNames_results struct{}

// MoqUsual_DifficultParamNames_paramIndexing holds the parameter indexing
// runtime configuration for the Usual type
type MoqUsual_DifficultParamNames_paramIndexing struct {
	Param1, Param2         moq.ParamIndexing
	Param3                 moq.ParamIndexing
	Param, Param5, Param6  moq.ParamIndexing
	Param7, Param8, Param9 moq.ParamIndexing
}

// MoqUsual_DifficultParamNames_doFn defines the type of function needed when
// calling AndDo for the Usual type
type MoqUsual_DifficultParamNames_doFn func(m, r bool, sequence string, param, params, i int, result, results, _ float32)

// MoqUsual_DifficultParamNames_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Usual type
type MoqUsual_DifficultParamNames_doReturnFn func(m, r bool, sequence string, param, params, i int, result, results, _ float32)

// MoqUsual_DifficultParamNames_recorder routes recorded function calls to the
// MoqUsual moq
type MoqUsual_DifficultParamNames_recorder struct {
	Recorder *impl.Recorder[
		*MoqUsual_DifficultParamNames_adaptor,
		MoqUsual_DifficultParamNames_params,
		MoqUsual_DifficultParamNames_paramsKey,
		MoqUsual_DifficultParamNames_results,
	]
}

// MoqUsual_DifficultParamNames_anyParams isolates the any params functions of
// the Usual type
type MoqUsual_DifficultParamNames_anyParams struct {
	Recorder *MoqUsual_DifficultParamNames_recorder
}

// MoqUsual_DifficultResultNames_adaptor adapts MoqUsual as needed by the
// runtime
type MoqUsual_DifficultResultNames_adaptor struct {
	Moq *MoqUsual
}

// MoqUsual_DifficultResultNames_params holds the params of the Usual type
type MoqUsual_DifficultResultNames_params struct{}

// MoqUsual_DifficultResultNames_paramsKey holds the map key params of the
// Usual type
type MoqUsual_DifficultResultNames_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqUsual_DifficultResultNames_results holds the results of the Usual type
type MoqUsual_DifficultResultNames_results struct {
	Result1, Result2          string
	Result3                   error
	Param, Result5, Result6   int
	Result7, Result8, Result9 float32
}

// MoqUsual_DifficultResultNames_paramIndexing holds the parameter indexing
// runtime configuration for the Usual type
type MoqUsual_DifficultResultNames_paramIndexing struct{}

// MoqUsual_DifficultResultNames_doFn defines the type of function needed when
// calling AndDo for the Usual type
type MoqUsual_DifficultResultNames_doFn func()

// MoqUsual_DifficultResultNames_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Usual type
type MoqUsual_DifficultResultNames_doReturnFn func() (m, r string, sequence error, param, params, i int, result, results, _ float32)

// MoqUsual_DifficultResultNames_recorder routes recorded function calls to the
// MoqUsual moq
type MoqUsual_DifficultResultNames_recorder struct {
	Recorder *impl.Recorder[
		*MoqUsual_DifficultResultNames_adaptor,
		MoqUsual_DifficultResultNames_params,
		MoqUsual_DifficultResultNames_paramsKey,
		MoqUsual_DifficultResultNames_results,
	]
}

// MoqUsual_DifficultResultNames_anyParams isolates the any params functions of
// the Usual type
type MoqUsual_DifficultResultNames_anyParams struct {
	Recorder *MoqUsual_DifficultResultNames_recorder
}

// MoqUsual_PassByArray_adaptor adapts MoqUsual as needed by the runtime
type MoqUsual_PassByArray_adaptor struct {
	Moq *MoqUsual
}

// MoqUsual_PassByArray_params holds the params of the Usual type
type MoqUsual_PassByArray_params struct{ P [3]testmoqs.Params }

// MoqUsual_PassByArray_paramsKey holds the map key params of the Usual type
type MoqUsual_PassByArray_paramsKey struct {
	Params struct{ P [3]testmoqs.Params }
	Hashes struct{ P hash.Hash }
}

// MoqUsual_PassByArray_results holds the results of the Usual type
type MoqUsual_PassByArray_results struct {
	Result1 [3]testmoqs.Results
}

// MoqUsual_PassByArray_paramIndexing holds the parameter indexing runtime
// configuration for the Usual type
type MoqUsual_PassByArray_paramIndexing struct {
	P moq.ParamIndexing
}

// MoqUsual_PassByArray_doFn defines the type of function needed when calling
// AndDo for the Usual type
type MoqUsual_PassByArray_doFn func(p [3]testmoqs.Params)

// MoqUsual_PassByArray_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Usual type
type MoqUsual_PassByArray_doReturnFn func(p [3]testmoqs.Params) [3]testmoqs.Results

// MoqUsual_PassByArray_recorder routes recorded function calls to the MoqUsual
// moq
type MoqUsual_PassByArray_recorder struct {
	Recorder *impl.Recorder[
		*MoqUsual_PassByArray_adaptor,
		MoqUsual_PassByArray_params,
		MoqUsual_PassByArray_paramsKey,
		MoqUsual_PassByArray_results,
	]
}

// MoqUsual_PassByArray_anyParams isolates the any params functions of the
// Usual type
type MoqUsual_PassByArray_anyParams struct {
	Recorder *MoqUsual_PassByArray_recorder
}

// MoqUsual_PassByChan_adaptor adapts MoqUsual as needed by the runtime
type MoqUsual_PassByChan_adaptor struct {
	Moq *MoqUsual
}

// MoqUsual_PassByChan_params holds the params of the Usual type
type MoqUsual_PassByChan_params struct{ P chan testmoqs.Params }

// MoqUsual_PassByChan_paramsKey holds the map key params of the Usual type
type MoqUsual_PassByChan_paramsKey struct {
	Params struct{ P chan testmoqs.Params }
	Hashes struct{ P hash.Hash }
}

// MoqUsual_PassByChan_results holds the results of the Usual type
type MoqUsual_PassByChan_results struct {
	Result1 chan testmoqs.Results
}

// MoqUsual_PassByChan_paramIndexing holds the parameter indexing runtime
// configuration for the Usual type
type MoqUsual_PassByChan_paramIndexing struct {
	P moq.ParamIndexing
}

// MoqUsual_PassByChan_doFn defines the type of function needed when calling
// AndDo for the Usual type
type MoqUsual_PassByChan_doFn func(p chan testmoqs.Params)

// MoqUsual_PassByChan_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Usual type
type MoqUsual_PassByChan_doReturnFn func(p chan testmoqs.Params) chan testmoqs.Results

// MoqUsual_PassByChan_recorder routes recorded function calls to the MoqUsual
// moq
type MoqUsual_PassByChan_recorder struct {
	Recorder *impl.Recorder[
		*MoqUsual_PassByChan_adaptor,
		MoqUsual_PassByChan_params,
		MoqUsual_PassByChan_paramsKey,
		MoqUsual_PassByChan_results,
	]
}

// MoqUsual_PassByChan_anyParams isolates the any params functions of the Usual
// type
type MoqUsual_PassByChan_anyParams struct {
	Recorder *MoqUsual_PassByChan_recorder
}

// MoqUsual_PassByEllipsis_adaptor adapts MoqUsual as needed by the runtime
type MoqUsual_PassByEllipsis_adaptor struct {
	Moq *MoqUsual
}

// MoqUsual_PassByEllipsis_params holds the params of the Usual type
type MoqUsual_PassByEllipsis_params struct{ P []testmoqs.Params }

// MoqUsual_PassByEllipsis_paramsKey holds the map key params of the Usual type
type MoqUsual_PassByEllipsis_paramsKey struct {
	Params struct{}
	Hashes struct{ P hash.Hash }
}

// MoqUsual_PassByEllipsis_results holds the results of the Usual type
type MoqUsual_PassByEllipsis_results struct {
	Result1 string
	Result2 error
}

// MoqUsual_PassByEllipsis_paramIndexing holds the parameter indexing runtime
// configuration for the Usual type
type MoqUsual_PassByEllipsis_paramIndexing struct {
	P moq.ParamIndexing
}

// MoqUsual_PassByEllipsis_doFn defines the type of function needed when
// calling AndDo for the Usual type
type MoqUsual_PassByEllipsis_doFn func(p ...testmoqs.Params)

// MoqUsual_PassByEllipsis_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Usual type
type MoqUsual_PassByEllipsis_doReturnFn func(p ...testmoqs.Params) (string, error)

// MoqUsual_PassByEllipsis_recorder routes recorded function calls to the
// MoqUsual moq
type MoqUsual_PassByEllipsis_recorder struct {
	Recorder *impl.Recorder[
		*MoqUsual_PassByEllipsis_adaptor,
		MoqUsual_PassByEllipsis_params,
		MoqUsual_PassByEllipsis_paramsKey,
		MoqUsual_PassByEllipsis_results,
	]
}

// MoqUsual_PassByEllipsis_anyParams isolates the any params functions of the
// Usual type
type MoqUsual_PassByEllipsis_anyParams struct {
	Recorder *MoqUsual_PassByEllipsis_recorder
}

// MoqUsual_PassByMap_adaptor adapts MoqUsual as needed by the runtime
type MoqUsual_PassByMap_adaptor struct {
	Moq *MoqUsual
}

// MoqUsual_PassByMap_params holds the params of the Usual type
type MoqUsual_PassByMap_params struct{ P map[string]testmoqs.Params }

// MoqUsual_PassByMap_paramsKey holds the map key params of the Usual type
type MoqUsual_PassByMap_paramsKey struct {
	Params struct{}
	Hashes struct{ P hash.Hash }
}

// MoqUsual_PassByMap_results holds the results of the Usual type
type MoqUsual_PassByMap_results struct {
	Result1 map[string]testmoqs.Results
}

// MoqUsual_PassByMap_paramIndexing holds the parameter indexing runtime
// configuration for the Usual type
type MoqUsual_PassByMap_paramIndexing struct {
	P moq.ParamIndexing
}

// MoqUsual_PassByMap_doFn defines the type of function needed when calling
// AndDo for the Usual type
type MoqUsual_PassByMap_doFn func(p map[string]testmoqs.Params)

// MoqUsual_PassByMap_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Usual type
type MoqUsual_PassByMap_doReturnFn func(p map[string]testmoqs.Params) map[string]testmoqs.Results

// MoqUsual_PassByMap_recorder routes recorded function calls to the MoqUsual
// moq
type MoqUsual_PassByMap_recorder struct {
	Recorder *impl.Recorder[
		*MoqUsual_PassByMap_adaptor,
		MoqUsual_PassByMap_params,
		MoqUsual_PassByMap_paramsKey,
		MoqUsual_PassByMap_results,
	]
}

// MoqUsual_PassByMap_anyParams isolates the any params functions of the Usual
// type
type MoqUsual_PassByMap_anyParams struct {
	Recorder *MoqUsual_PassByMap_recorder
}

// MoqUsual_PassByReference_adaptor adapts MoqUsual as needed by the runtime
type MoqUsual_PassByReference_adaptor struct {
	Moq *MoqUsual
}

// MoqUsual_PassByReference_params holds the params of the Usual type
type MoqUsual_PassByReference_params struct{ P *testmoqs.Params }

// MoqUsual_PassByReference_paramsKey holds the map key params of the Usual
// type
type MoqUsual_PassByReference_paramsKey struct {
	Params struct{ P *testmoqs.Params }
	Hashes struct{ P hash.Hash }
}

// MoqUsual_PassByReference_results holds the results of the Usual type
type MoqUsual_PassByReference_results struct {
	Result1 *testmoqs.Results
}

// MoqUsual_PassByReference_paramIndexing holds the parameter indexing runtime
// configuration for the Usual type
type MoqUsual_PassByReference_paramIndexing struct {
	P moq.ParamIndexing
}

// MoqUsual_PassByReference_doFn defines the type of function needed when
// calling AndDo for the Usual type
type MoqUsual_PassByReference_doFn func(p *testmoqs.Params)

// MoqUsual_PassByReference_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Usual type
type MoqUsual_PassByReference_doReturnFn func(p *testmoqs.Params) *testmoqs.Results

// MoqUsual_PassByReference_recorder routes recorded function calls to the
// MoqUsual moq
type MoqUsual_PassByReference_recorder struct {
	Recorder *impl.Recorder[
		*MoqUsual_PassByReference_adaptor,
		MoqUsual_PassByReference_params,
		MoqUsual_PassByReference_paramsKey,
		MoqUsual_PassByReference_results,
	]
}

// MoqUsual_PassByReference_anyParams isolates the any params functions of the
// Usual type
type MoqUsual_PassByReference_anyParams struct {
	Recorder *MoqUsual_PassByReference_recorder
}

// MoqUsual_PassBySlice_adaptor adapts MoqUsual as needed by the runtime
type MoqUsual_PassBySlice_adaptor struct {
	Moq *MoqUsual
}

// MoqUsual_PassBySlice_params holds the params of the Usual type
type MoqUsual_PassBySlice_params struct{ P []testmoqs.Params }

// MoqUsual_PassBySlice_paramsKey holds the map key params of the Usual type
type MoqUsual_PassBySlice_paramsKey struct {
	Params struct{}
	Hashes struct{ P hash.Hash }
}

// MoqUsual_PassBySlice_results holds the results of the Usual type
type MoqUsual_PassBySlice_results struct {
	Result1 []testmoqs.Results
}

// MoqUsual_PassBySlice_paramIndexing holds the parameter indexing runtime
// configuration for the Usual type
type MoqUsual_PassBySlice_paramIndexing struct {
	P moq.ParamIndexing
}

// MoqUsual_PassBySlice_doFn defines the type of function needed when calling
// AndDo for the Usual type
type MoqUsual_PassBySlice_doFn func(p []testmoqs.Params)

// MoqUsual_PassBySlice_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Usual type
type MoqUsual_PassBySlice_doReturnFn func(p []testmoqs.Params) []testmoqs.Results

// MoqUsual_PassBySlice_recorder routes recorded function calls to the MoqUsual
// moq
type MoqUsual_PassBySlice_recorder struct {
	Recorder *impl.Recorder[
		*MoqUsual_PassBySlice_adaptor,
		MoqUsual_PassBySlice_params,
		MoqUsual_PassBySlice_paramsKey,
		MoqUsual_PassBySlice_results,
	]
}

// MoqUsual_PassBySlice_anyParams isolates the any params functions of the
// Usual type
type MoqUsual_PassBySlice_anyParams struct {
	Recorder *MoqUsual_PassBySlice_recorder
}

// MoqUsual_PassByValue_adaptor adapts MoqUsual as needed by the runtime
type MoqUsual_PassByValue_adaptor struct {
	Moq *MoqUsual
}

// MoqUsual_PassByValue_params holds the params of the Usual type
type MoqUsual_PassByValue_params struct{ P testmoqs.Params }

// MoqUsual_PassByValue_paramsKey holds the map key params of the Usual type
type MoqUsual_PassByValue_paramsKey struct {
	Params struct{ P testmoqs.Params }
	Hashes struct{ P hash.Hash }
}

// MoqUsual_PassByValue_results holds the results of the Usual type
type MoqUsual_PassByValue_results struct {
	Result1 testmoqs.Results
}

// MoqUsual_PassByValue_paramIndexing holds the parameter indexing runtime
// configuration for the Usual type
type MoqUsual_PassByValue_paramIndexing struct {
	P moq.ParamIndexing
}

// MoqUsual_PassByValue_doFn defines the type of function needed when calling
// AndDo for the Usual type
type MoqUsual_PassByValue_doFn func(p testmoqs.Params)

// MoqUsual_PassByValue_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Usual type
type MoqUsual_PassByValue_doReturnFn func(p testmoqs.Params) testmoqs.Results

// MoqUsual_PassByValue_recorder routes recorded function calls to the MoqUsual
// moq
type MoqUsual_PassByValue_recorder struct {
	Recorder *impl.Recorder[
		*MoqUsual_PassByValue_adaptor,
		MoqUsual_PassByValue_params,
		MoqUsual_PassByValue_paramsKey,
		MoqUsual_PassByValue_results,
	]
}

// MoqUsual_PassByValue_anyParams isolates the any params functions of the
// Usual type
type MoqUsual_PassByValue_anyParams struct {
	Recorder *MoqUsual_PassByValue_recorder
}

// MoqUsual_InterfaceParam_adaptor adapts MoqUsual as needed by the runtime
type MoqUsual_InterfaceParam_adaptor struct {
	Moq *MoqUsual
}

// MoqUsual_InterfaceParam_params holds the params of the Usual type
type MoqUsual_InterfaceParam_params struct{ W io.Writer }

// MoqUsual_InterfaceParam_paramsKey holds the map key params of the Usual type
type MoqUsual_InterfaceParam_paramsKey struct {
	Params struct{ W io.Writer }
	Hashes struct{ W hash.Hash }
}

// MoqUsual_InterfaceParam_results holds the results of the Usual type
type MoqUsual_InterfaceParam_results struct {
	SResult string
	Err     error
}

// MoqUsual_InterfaceParam_paramIndexing holds the parameter indexing runtime
// configuration for the Usual type
type MoqUsual_InterfaceParam_paramIndexing struct {
	W moq.ParamIndexing
}

// MoqUsual_InterfaceParam_doFn defines the type of function needed when
// calling AndDo for the Usual type
type MoqUsual_InterfaceParam_doFn func(w io.Writer)

// MoqUsual_InterfaceParam_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Usual type
type MoqUsual_InterfaceParam_doReturnFn func(w io.Writer) (sResult string, err error)

// MoqUsual_InterfaceParam_recorder routes recorded function calls to the
// MoqUsual moq
type MoqUsual_InterfaceParam_recorder struct {
	Recorder *impl.Recorder[
		*MoqUsual_InterfaceParam_adaptor,
		MoqUsual_InterfaceParam_params,
		MoqUsual_InterfaceParam_paramsKey,
		MoqUsual_InterfaceParam_results,
	]
}

// MoqUsual_InterfaceParam_anyParams isolates the any params functions of the
// Usual type
type MoqUsual_InterfaceParam_anyParams struct {
	Recorder *MoqUsual_InterfaceParam_recorder
}

// MoqUsual_InterfaceResult_adaptor adapts MoqUsual as needed by the runtime
type MoqUsual_InterfaceResult_adaptor struct {
	Moq *MoqUsual
}

// MoqUsual_InterfaceResult_params holds the params of the Usual type
type MoqUsual_InterfaceResult_params struct {
	SParam string
	BParam bool
}

// MoqUsual_InterfaceResult_paramsKey holds the map key params of the Usual
// type
type MoqUsual_InterfaceResult_paramsKey struct {
	Params struct {
		SParam string
		BParam bool
	}
	Hashes struct {
		SParam hash.Hash
		BParam hash.Hash
	}
}

// MoqUsual_InterfaceResult_results holds the results of the Usual type
type MoqUsual_InterfaceResult_results struct{ Result1 io.Reader }

// MoqUsual_InterfaceResult_paramIndexing holds the parameter indexing runtime
// configuration for the Usual type
type MoqUsual_InterfaceResult_paramIndexing struct {
	SParam moq.ParamIndexing
	BParam moq.ParamIndexing
}

// MoqUsual_InterfaceResult_doFn defines the type of function needed when
// calling AndDo for the Usual type
type MoqUsual_InterfaceResult_doFn func(sParam string, bParam bool)

// MoqUsual_InterfaceResult_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Usual type
type MoqUsual_InterfaceResult_doReturnFn func(sParam string, bParam bool) (r io.Reader)

// MoqUsual_InterfaceResult_recorder routes recorded function calls to the
// MoqUsual moq
type MoqUsual_InterfaceResult_recorder struct {
	Recorder *impl.Recorder[
		*MoqUsual_InterfaceResult_adaptor,
		MoqUsual_InterfaceResult_params,
		MoqUsual_InterfaceResult_paramsKey,
		MoqUsual_InterfaceResult_results,
	]
}

// MoqUsual_InterfaceResult_anyParams isolates the any params functions of the
// Usual type
type MoqUsual_InterfaceResult_anyParams struct {
	Recorder *MoqUsual_InterfaceResult_recorder
}

// MoqUsual_FnParam_adaptor adapts MoqUsual as needed by the runtime
type MoqUsual_FnParam_adaptor struct {
	Moq *MoqUsual
}

// MoqUsual_FnParam_params holds the params of the Usual type
type MoqUsual_FnParam_params struct{ Fn func() }

// MoqUsual_FnParam_paramsKey holds the map key params of the Usual type
type MoqUsual_FnParam_paramsKey struct {
	Params struct{}
	Hashes struct{ Fn hash.Hash }
}

// MoqUsual_FnParam_results holds the results of the Usual type
type MoqUsual_FnParam_results struct{}

// MoqUsual_FnParam_paramIndexing holds the parameter indexing runtime
// configuration for the Usual type
type MoqUsual_FnParam_paramIndexing struct {
	Fn moq.ParamIndexing
}

// MoqUsual_FnParam_doFn defines the type of function needed when calling AndDo
// for the Usual type
type MoqUsual_FnParam_doFn func(fn func())

// MoqUsual_FnParam_doReturnFn defines the type of function needed when calling
// DoReturnResults for the Usual type
type MoqUsual_FnParam_doReturnFn func(fn func())

// MoqUsual_FnParam_recorder routes recorded function calls to the MoqUsual moq
type MoqUsual_FnParam_recorder struct {
	Recorder *impl.Recorder[
		*MoqUsual_FnParam_adaptor,
		MoqUsual_FnParam_params,
		MoqUsual_FnParam_paramsKey,
		MoqUsual_FnParam_results,
	]
}

// MoqUsual_FnParam_anyParams isolates the any params functions of the Usual
// type
type MoqUsual_FnParam_anyParams struct {
	Recorder *MoqUsual_FnParam_recorder
}

// MoqUsual_Other_adaptor adapts MoqUsual as needed by the runtime
type MoqUsual_Other_adaptor struct {
	Moq *MoqUsual
}

// MoqUsual_Other_params holds the params of the Usual type
type MoqUsual_Other_params struct{ Param1 other.Params }

// MoqUsual_Other_paramsKey holds the map key params of the Usual type
type MoqUsual_Other_paramsKey struct {
	Params struct{ Param1 other.Params }
	Hashes struct{ Param1 hash.Hash }
}

// MoqUsual_Other_results holds the results of the Usual type
type MoqUsual_Other_results struct {
	Result1 other.Results
}

// MoqUsual_Other_paramIndexing holds the parameter indexing runtime
// configuration for the Usual type
type MoqUsual_Other_paramIndexing struct {
	Param1 moq.ParamIndexing
}

// MoqUsual_Other_doFn defines the type of function needed when calling AndDo
// for the Usual type
type MoqUsual_Other_doFn func(other.Params)

// MoqUsual_Other_doReturnFn defines the type of function needed when calling
// DoReturnResults for the Usual type
type MoqUsual_Other_doReturnFn func(other.Params) other.Results

// MoqUsual_Other_recorder routes recorded function calls to the MoqUsual moq
type MoqUsual_Other_recorder struct {
	Recorder *impl.Recorder[
		*MoqUsual_Other_adaptor,
		MoqUsual_Other_params,
		MoqUsual_Other_paramsKey,
		MoqUsual_Other_results,
	]
}

// MoqUsual_Other_anyParams isolates the any params functions of the Usual type
type MoqUsual_Other_anyParams struct {
	Recorder *MoqUsual_Other_recorder
}

// NewMoqUsual creates a new moq of the Usual type
func NewMoqUsual(scene *moq.Scene, config *moq.Config) *MoqUsual {
	adaptor1 := &MoqUsual_Usual_adaptor{}
	adaptor2 := &MoqUsual_NoNames_adaptor{}
	adaptor3 := &MoqUsual_NoResults_adaptor{}
	adaptor4 := &MoqUsual_NoParams_adaptor{}
	adaptor5 := &MoqUsual_Nothing_adaptor{}
	adaptor6 := &MoqUsual_Variadic_adaptor{}
	adaptor7 := &MoqUsual_RepeatedIds_adaptor{}
	adaptor8 := &MoqUsual_Times_adaptor{}
	adaptor9 := &MoqUsual_DifficultParamNames_adaptor{}
	adaptor10 := &MoqUsual_DifficultResultNames_adaptor{}
	adaptor11 := &MoqUsual_PassByArray_adaptor{}
	adaptor12 := &MoqUsual_PassByChan_adaptor{}
	adaptor13 := &MoqUsual_PassByEllipsis_adaptor{}
	adaptor14 := &MoqUsual_PassByMap_adaptor{}
	adaptor15 := &MoqUsual_PassByReference_adaptor{}
	adaptor16 := &MoqUsual_PassBySlice_adaptor{}
	adaptor17 := &MoqUsual_PassByValue_adaptor{}
	adaptor18 := &MoqUsual_InterfaceParam_adaptor{}
	adaptor19 := &MoqUsual_InterfaceResult_adaptor{}
	adaptor20 := &MoqUsual_FnParam_adaptor{}
	adaptor21 := &MoqUsual_Other_adaptor{}
	m := &MoqUsual{
		Moq: &MoqUsual_mock{},

		Moq_Usual: impl.NewMoq[
			*MoqUsual_Usual_adaptor,
			MoqUsual_Usual_params,
			MoqUsual_Usual_paramsKey,
			MoqUsual_Usual_results,
		](scene, adaptor1, config),
		Moq_NoNames: impl.NewMoq[
			*MoqUsual_NoNames_adaptor,
			MoqUsual_NoNames_params,
			MoqUsual_NoNames_paramsKey,
			MoqUsual_NoNames_results,
		](scene, adaptor2, config),
		Moq_NoResults: impl.NewMoq[
			*MoqUsual_NoResults_adaptor,
			MoqUsual_NoResults_params,
			MoqUsual_NoResults_paramsKey,
			MoqUsual_NoResults_results,
		](scene, adaptor3, config),
		Moq_NoParams: impl.NewMoq[
			*MoqUsual_NoParams_adaptor,
			MoqUsual_NoParams_params,
			MoqUsual_NoParams_paramsKey,
			MoqUsual_NoParams_results,
		](scene, adaptor4, config),
		Moq_Nothing: impl.NewMoq[
			*MoqUsual_Nothing_adaptor,
			MoqUsual_Nothing_params,
			MoqUsual_Nothing_paramsKey,
			MoqUsual_Nothing_results,
		](scene, adaptor5, config),
		Moq_Variadic: impl.NewMoq[
			*MoqUsual_Variadic_adaptor,
			MoqUsual_Variadic_params,
			MoqUsual_Variadic_paramsKey,
			MoqUsual_Variadic_results,
		](scene, adaptor6, config),
		Moq_RepeatedIds: impl.NewMoq[
			*MoqUsual_RepeatedIds_adaptor,
			MoqUsual_RepeatedIds_params,
			MoqUsual_RepeatedIds_paramsKey,
			MoqUsual_RepeatedIds_results,
		](scene, adaptor7, config),
		Moq_Times: impl.NewMoq[
			*MoqUsual_Times_adaptor,
			MoqUsual_Times_params,
			MoqUsual_Times_paramsKey,
			MoqUsual_Times_results,
		](scene, adaptor8, config),
		Moq_DifficultParamNames: impl.NewMoq[
			*MoqUsual_DifficultParamNames_adaptor,
			MoqUsual_DifficultParamNames_params,
			MoqUsual_DifficultParamNames_paramsKey,
			MoqUsual_DifficultParamNames_results,
		](scene, adaptor9, config),
		Moq_DifficultResultNames: impl.NewMoq[
			*MoqUsual_DifficultResultNames_adaptor,
			MoqUsual_DifficultResultNames_params,
			MoqUsual_DifficultResultNames_paramsKey,
			MoqUsual_DifficultResultNames_results,
		](scene, adaptor10, config),
		Moq_PassByArray: impl.NewMoq[
			*MoqUsual_PassByArray_adaptor,
			MoqUsual_PassByArray_params,
			MoqUsual_PassByArray_paramsKey,
			MoqUsual_PassByArray_results,
		](scene, adaptor11, config),
		Moq_PassByChan: impl.NewMoq[
			*MoqUsual_PassByChan_adaptor,
			MoqUsual_PassByChan_params,
			MoqUsual_PassByChan_paramsKey,
			MoqUsual_PassByChan_results,
		](scene, adaptor12, config),
		Moq_PassByEllipsis: impl.NewMoq[
			*MoqUsual_PassByEllipsis_adaptor,
			MoqUsual_PassByEllipsis_params,
			MoqUsual_PassByEllipsis_paramsKey,
			MoqUsual_PassByEllipsis_results,
		](scene, adaptor13, config),
		Moq_PassByMap: impl.NewMoq[
			*MoqUsual_PassByMap_adaptor,
			MoqUsual_PassByMap_params,
			MoqUsual_PassByMap_paramsKey,
			MoqUsual_PassByMap_results,
		](scene, adaptor14, config),
		Moq_PassByReference: impl.NewMoq[
			*MoqUsual_PassByReference_adaptor,
			MoqUsual_PassByReference_params,
			MoqUsual_PassByReference_paramsKey,
			MoqUsual_PassByReference_results,
		](scene, adaptor15, config),
		Moq_PassBySlice: impl.NewMoq[
			*MoqUsual_PassBySlice_adaptor,
			MoqUsual_PassBySlice_params,
			MoqUsual_PassBySlice_paramsKey,
			MoqUsual_PassBySlice_results,
		](scene, adaptor16, config),
		Moq_PassByValue: impl.NewMoq[
			*MoqUsual_PassByValue_adaptor,
			MoqUsual_PassByValue_params,
			MoqUsual_PassByValue_paramsKey,
			MoqUsual_PassByValue_results,
		](scene, adaptor17, config),
		Moq_InterfaceParam: impl.NewMoq[
			*MoqUsual_InterfaceParam_adaptor,
			MoqUsual_InterfaceParam_params,
			MoqUsual_InterfaceParam_paramsKey,
			MoqUsual_InterfaceParam_results,
		](scene, adaptor18, config),
		Moq_InterfaceResult: impl.NewMoq[
			*MoqUsual_InterfaceResult_adaptor,
			MoqUsual_InterfaceResult_params,
			MoqUsual_InterfaceResult_paramsKey,
			MoqUsual_InterfaceResult_results,
		](scene, adaptor19, config),
		Moq_FnParam: impl.NewMoq[
			*MoqUsual_FnParam_adaptor,
			MoqUsual_FnParam_params,
			MoqUsual_FnParam_paramsKey,
			MoqUsual_FnParam_results,
		](scene, adaptor20, config),
		Moq_Other: impl.NewMoq[
			*MoqUsual_Other_adaptor,
			MoqUsual_Other_params,
			MoqUsual_Other_paramsKey,
			MoqUsual_Other_results,
		](scene, adaptor21, config),

		Runtime: MoqUsual_runtime{ParameterIndexing: struct {
			Usual                MoqUsual_Usual_paramIndexing
			NoNames              MoqUsual_NoNames_paramIndexing
			NoResults            MoqUsual_NoResults_paramIndexing
			NoParams             MoqUsual_NoParams_paramIndexing
			Nothing              MoqUsual_Nothing_paramIndexing
			Variadic             MoqUsual_Variadic_paramIndexing
			RepeatedIds          MoqUsual_RepeatedIds_paramIndexing
			Times                MoqUsual_Times_paramIndexing
			DifficultParamNames  MoqUsual_DifficultParamNames_paramIndexing
			DifficultResultNames MoqUsual_DifficultResultNames_paramIndexing
			PassByArray          MoqUsual_PassByArray_paramIndexing
			PassByChan           MoqUsual_PassByChan_paramIndexing
			PassByEllipsis       MoqUsual_PassByEllipsis_paramIndexing
			PassByMap            MoqUsual_PassByMap_paramIndexing
			PassByReference      MoqUsual_PassByReference_paramIndexing
			PassBySlice          MoqUsual_PassBySlice_paramIndexing
			PassByValue          MoqUsual_PassByValue_paramIndexing
			InterfaceParam       MoqUsual_InterfaceParam_paramIndexing
			InterfaceResult      MoqUsual_InterfaceResult_paramIndexing
			FnParam              MoqUsual_FnParam_paramIndexing
			Other                MoqUsual_Other_paramIndexing
		}{
			Usual: MoqUsual_Usual_paramIndexing{
				SParam: moq.ParamIndexByValue,
				BParam: moq.ParamIndexByValue,
			},
			NoNames: MoqUsual_NoNames_paramIndexing{
				Param1: moq.ParamIndexByValue,
				Param2: moq.ParamIndexByValue,
			},
			NoResults: MoqUsual_NoResults_paramIndexing{
				SParam: moq.ParamIndexByValue,
				BParam: moq.ParamIndexByValue,
			},
			NoParams: MoqUsual_NoParams_paramIndexing{},
			Nothing:  MoqUsual_Nothing_paramIndexing{},
			Variadic: MoqUsual_Variadic_paramIndexing{
				Other: moq.ParamIndexByValue,
				Args:  moq.ParamIndexByHash,
			},
			RepeatedIds: MoqUsual_RepeatedIds_paramIndexing{
				SParam1: moq.ParamIndexByValue,
				SParam2: moq.ParamIndexByValue,
				BParam:  moq.ParamIndexByValue,
			},
			Times: MoqUsual_Times_paramIndexing{
				SParam: moq.ParamIndexByValue,
				Times:  moq.ParamIndexByValue,
			},
			DifficultParamNames: MoqUsual_DifficultParamNames_paramIndexing{
				Param1: moq.ParamIndexByValue,
				Param2: moq.ParamIndexByValue,
				Param3: moq.ParamIndexByValue,
				Param:  moq.ParamIndexByValue,
				Param5: moq.ParamIndexByValue,
				Param6: moq.ParamIndexByValue,
				Param7: moq.ParamIndexByValue,
				Param8: moq.ParamIndexByValue,
				Param9: moq.ParamIndexByValue,
			},
			DifficultResultNames: MoqUsual_DifficultResultNames_paramIndexing{},
			PassByArray: MoqUsual_PassByArray_paramIndexing{
				P: moq.ParamIndexByValue,
			},
			PassByChan: MoqUsual_PassByChan_paramIndexing{
				P: moq.ParamIndexByValue,
			},
			PassByEllipsis: MoqUsual_PassByEllipsis_paramIndexing{
				P: moq.ParamIndexByHash,
			},
			PassByMap: MoqUsual_PassByMap_paramIndexing{
				P: moq.ParamIndexByHash,
			},
			PassByReference: MoqUsual_PassByReference_paramIndexing{
				P: moq.ParamIndexByHash,
			},
			PassBySlice: MoqUsual_PassBySlice_paramIndexing{
				P: moq.ParamIndexByHash,
			},
			PassByValue: MoqUsual_PassByValue_paramIndexing{
				P: moq.ParamIndexByValue,
			},
			InterfaceParam: MoqUsual_InterfaceParam_paramIndexing{
				W: moq.ParamIndexByHash,
			},
			InterfaceResult: MoqUsual_InterfaceResult_paramIndexing{
				SParam: moq.ParamIndexByValue,
				BParam: moq.ParamIndexByValue,
			},
			FnParam: MoqUsual_FnParam_paramIndexing{
				Fn: moq.ParamIndexByHash,
			},
			Other: MoqUsual_Other_paramIndexing{
				Param1: moq.ParamIndexByValue,
			},
		}},
	}
	m.Moq.Moq = m

	adaptor1.Moq = m
	adaptor2.Moq = m
	adaptor3.Moq = m
	adaptor4.Moq = m
	adaptor5.Moq = m
	adaptor6.Moq = m
	adaptor7.Moq = m
	adaptor8.Moq = m
	adaptor9.Moq = m
	adaptor10.Moq = m
	adaptor11.Moq = m
	adaptor12.Moq = m
	adaptor13.Moq = m
	adaptor14.Moq = m
	adaptor15.Moq = m
	adaptor16.Moq = m
	adaptor17.Moq = m
	adaptor18.Moq = m
	adaptor19.Moq = m
	adaptor20.Moq = m
	adaptor21.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the mock implementation of the Usual type
func (m *MoqUsual) Mock() *MoqUsual_mock { return m.Moq }

func (m *MoqUsual_mock) Usual(sParam string, bParam bool) (string, error) {
	m.Moq.Moq_Usual.Scene.T.Helper()
	params := MoqUsual_Usual_params{
		SParam: sParam,
		BParam: bParam,
	}

	var result1 string
	var result2 error
	if result := m.Moq.Moq_Usual.Function(params); result != nil {
		result1 = result.SResult
		result2 = result.Err
	}
	return result1, result2
}

func (m *MoqUsual_mock) NoNames(param1 string, param2 bool) (string, error) {
	m.Moq.Moq_NoNames.Scene.T.Helper()
	params := MoqUsual_NoNames_params{
		Param1: param1,
		Param2: param2,
	}

	var result1 string
	var result2 error
	if result := m.Moq.Moq_NoNames.Function(params); result != nil {
		result1 = result.Result1
		result2 = result.Result2
	}
	return result1, result2
}

func (m *MoqUsual_mock) NoResults(sParam string, bParam bool) {
	m.Moq.Moq_NoResults.Scene.T.Helper()
	params := MoqUsual_NoResults_params{
		SParam: sParam,
		BParam: bParam,
	}

	m.Moq.Moq_NoResults.Function(params)
}

func (m *MoqUsual_mock) NoParams() (string, error) {
	m.Moq.Moq_NoParams.Scene.T.Helper()
	params := MoqUsual_NoParams_params{}

	var result1 string
	var result2 error
	if result := m.Moq.Moq_NoParams.Function(params); result != nil {
		result1 = result.SResult
		result2 = result.Err
	}
	return result1, result2
}

func (m *MoqUsual_mock) Nothing() {
	m.Moq.Moq_Nothing.Scene.T.Helper()
	params := MoqUsual_Nothing_params{}

	m.Moq.Moq_Nothing.Function(params)
}

func (m *MoqUsual_mock) Variadic(other bool, args ...string) (string, error) {
	m.Moq.Moq_Variadic.Scene.T.Helper()
	params := MoqUsual_Variadic_params{
		Other: other,
		Args:  args,
	}

	var result1 string
	var result2 error
	if result := m.Moq.Moq_Variadic.Function(params); result != nil {
		result1 = result.SResult
		result2 = result.Err
	}
	return result1, result2
}

func (m *MoqUsual_mock) RepeatedIds(sParam1, sParam2 string, bParam bool) (string, string, error) {
	m.Moq.Moq_RepeatedIds.Scene.T.Helper()
	params := MoqUsual_RepeatedIds_params{
		SParam1: sParam1,
		SParam2: sParam2,
		BParam:  bParam,
	}

	var result1 string
	var result2 string
	var result3 error
	if result := m.Moq.Moq_RepeatedIds.Function(params); result != nil {
		result1 = result.SResult1
		result2 = result.SResult2
		result3 = result.Err
	}
	return result1, result2, result3
}

func (m *MoqUsual_mock) Times(sParam string, times bool) (string, error) {
	m.Moq.Moq_Times.Scene.T.Helper()
	params := MoqUsual_Times_params{
		SParam: sParam,
		Times:  times,
	}

	var result1 string
	var result2 error
	if result := m.Moq.Moq_Times.Function(params); result != nil {
		result1 = result.SResult
		result2 = result.Err
	}
	return result1, result2
}

func (m *MoqUsual_mock) DifficultParamNames(param1, param2 bool, param3 string, param, param5, param6 int, param7, param8, param9 float32) {
	m.Moq.Moq_DifficultParamNames.Scene.T.Helper()
	params := MoqUsual_DifficultParamNames_params{
		Param1: param1,
		Param2: param2,
		Param3: param3,
		Param:  param,
		Param5: param5,
		Param6: param6,
		Param7: param7,
		Param8: param8,
		Param9: param9,
	}

	m.Moq.Moq_DifficultParamNames.Function(params)
}

func (m *MoqUsual_mock) DifficultResultNames() (string, string, error, int, int, int, float32, float32, float32) {
	m.Moq.Moq_DifficultResultNames.Scene.T.Helper()
	params := MoqUsual_DifficultResultNames_params{}

	var result1 string
	var result2 string
	var result3 error
	var result4 int
	var result5 int
	var result6 int
	var result7 float32
	var result8 float32
	var result9 float32
	if result := m.Moq.Moq_DifficultResultNames.Function(params); result != nil {
		result1 = result.Result1
		result2 = result.Result2
		result3 = result.Result3
		result4 = result.Param
		result5 = result.Result5
		result6 = result.Result6
		result7 = result.Result7
		result8 = result.Result8
		result9 = result.Result9
	}
	return result1, result2, result3, result4, result5, result6, result7, result8, result9
}

func (m *MoqUsual_mock) PassByArray(p [3]testmoqs.Params) [3]testmoqs.Results {
	m.Moq.Moq_PassByArray.Scene.T.Helper()
	params := MoqUsual_PassByArray_params{
		P: p,
	}

	var result1 [3]testmoqs.Results
	if result := m.Moq.Moq_PassByArray.Function(params); result != nil {
		result1 = result.Result1
	}
	return result1
}

func (m *MoqUsual_mock) PassByChan(p chan testmoqs.Params) chan testmoqs.Results {
	m.Moq.Moq_PassByChan.Scene.T.Helper()
	params := MoqUsual_PassByChan_params{
		P: p,
	}

	var result1 chan testmoqs.Results
	if result := m.Moq.Moq_PassByChan.Function(params); result != nil {
		result1 = result.Result1
	}
	return result1
}

func (m *MoqUsual_mock) PassByEllipsis(p ...testmoqs.Params) (string, error) {
	m.Moq.Moq_PassByEllipsis.Scene.T.Helper()
	params := MoqUsual_PassByEllipsis_params{
		P: p,
	}

	var result1 string
	var result2 error
	if result := m.Moq.Moq_PassByEllipsis.Function(params); result != nil {
		result1 = result.Result1
		result2 = result.Result2
	}
	return result1, result2
}

func (m *MoqUsual_mock) PassByMap(p map[string]testmoqs.Params) map[string]testmoqs.Results {
	m.Moq.Moq_PassByMap.Scene.T.Helper()
	params := MoqUsual_PassByMap_params{
		P: p,
	}

	var result1 map[string]testmoqs.Results
	if result := m.Moq.Moq_PassByMap.Function(params); result != nil {
		result1 = result.Result1
	}
	return result1
}

func (m *MoqUsual_mock) PassByReference(p *testmoqs.Params) *testmoqs.Results {
	m.Moq.Moq_PassByReference.Scene.T.Helper()
	params := MoqUsual_PassByReference_params{
		P: p,
	}

	var result1 *testmoqs.Results
	if result := m.Moq.Moq_PassByReference.Function(params); result != nil {
		result1 = result.Result1
	}
	return result1
}

func (m *MoqUsual_mock) PassBySlice(p []testmoqs.Params) []testmoqs.Results {
	m.Moq.Moq_PassBySlice.Scene.T.Helper()
	params := MoqUsual_PassBySlice_params{
		P: p,
	}

	var result1 []testmoqs.Results
	if result := m.Moq.Moq_PassBySlice.Function(params); result != nil {
		result1 = result.Result1
	}
	return result1
}

func (m *MoqUsual_mock) PassByValue(p testmoqs.Params) testmoqs.Results {
	m.Moq.Moq_PassByValue.Scene.T.Helper()
	params := MoqUsual_PassByValue_params{
		P: p,
	}

	var result1 testmoqs.Results
	if result := m.Moq.Moq_PassByValue.Function(params); result != nil {
		result1 = result.Result1
	}
	return result1
}

func (m *MoqUsual_mock) InterfaceParam(w io.Writer) (string, error) {
	m.Moq.Moq_InterfaceParam.Scene.T.Helper()
	params := MoqUsual_InterfaceParam_params{
		W: w,
	}

	var result1 string
	var result2 error
	if result := m.Moq.Moq_InterfaceParam.Function(params); result != nil {
		result1 = result.SResult
		result2 = result.Err
	}
	return result1, result2
}

func (m *MoqUsual_mock) InterfaceResult(sParam string, bParam bool) io.Reader {
	m.Moq.Moq_InterfaceResult.Scene.T.Helper()
	params := MoqUsual_InterfaceResult_params{
		SParam: sParam,
		BParam: bParam,
	}

	var result1 io.Reader
	if result := m.Moq.Moq_InterfaceResult.Function(params); result != nil {
		result1 = result.Result1
	}
	return result1
}

func (m *MoqUsual_mock) FnParam(fn func()) {
	m.Moq.Moq_FnParam.Scene.T.Helper()
	params := MoqUsual_FnParam_params{
		Fn: fn,
	}

	m.Moq.Moq_FnParam.Function(params)
}

func (m *MoqUsual_mock) Other(param1 other.Params) other.Results {
	m.Moq.Moq_Other.Scene.T.Helper()
	params := MoqUsual_Other_params{
		Param1: param1,
	}

	var result1 other.Results
	if result := m.Moq.Moq_Other.Function(params); result != nil {
		result1 = result.Result1
	}
	return result1
}

// OnCall returns the recorder implementation of the Usual type
func (m *MoqUsual) OnCall() *MoqUsual_recorder {
	return &MoqUsual_recorder{
		Moq: m,
	}
}

func (m *MoqUsual_recorder) Usual(sParam string, bParam bool) *MoqUsual_Usual_recorder {
	return &MoqUsual_Usual_recorder{
		Recorder: m.Moq.Moq_Usual.OnCall(MoqUsual_Usual_params{
			SParam: sParam,
			BParam: bParam,
		}),
	}
}

func (r *MoqUsual_Usual_recorder) Any() *MoqUsual_Usual_anyParams {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.IsAnyPermitted(true) {
		return nil
	}
	return &MoqUsual_Usual_anyParams{Recorder: r}
}

func (a *MoqUsual_Usual_anyParams) SParam() *MoqUsual_Usual_recorder {
	a.Recorder.Recorder.AnyParam(1)
	return a.Recorder
}

func (a *MoqUsual_Usual_anyParams) BParam() *MoqUsual_Usual_recorder {
	a.Recorder.Recorder.AnyParam(2)
	return a.Recorder
}

func (r *MoqUsual_Usual_recorder) Seq() *MoqUsual_Usual_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(true, "Seq", true) {
		return nil
	}
	return r
}

func (r *MoqUsual_Usual_recorder) NoSeq() *MoqUsual_Usual_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(false, "NoSeq", true) {
		return nil
	}
	return r
}

func (r *MoqUsual_Usual_recorder) ReturnResults(sResult string, err error) *MoqUsual_Usual_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.ReturnResults(MoqUsual_Usual_results{
		SResult: sResult,
		Err:     err,
	})
	return r
}

func (r *MoqUsual_Usual_recorder) AndDo(fn MoqUsual_Usual_doFn) *MoqUsual_Usual_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.AndDo(func(params MoqUsual_Usual_params) {
		fn(params.SParam, params.BParam)
	}, true) {
		return nil
	}
	return r
}

func (r *MoqUsual_Usual_recorder) DoReturnResults(fn MoqUsual_Usual_doReturnFn) *MoqUsual_Usual_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.DoReturnResults(func(params MoqUsual_Usual_params) *MoqUsual_Usual_results {
		sResult, err := fn(params.SParam, params.BParam)
		return &MoqUsual_Usual_results{
			SResult: sResult,
			Err:     err,
		}
	})
	return r
}

func (r *MoqUsual_Usual_recorder) Repeat(repeaters ...moq.Repeater) *MoqUsual_Usual_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Repeat(repeaters, true) {
		return nil
	}
	return r
}

func (*MoqUsual_Usual_adaptor) PrettyParams(params MoqUsual_Usual_params) string {
	return fmt.Sprintf("Usual(%#v, %#v)", params.SParam, params.BParam)
}

func (a *MoqUsual_Usual_adaptor) ParamsKey(params MoqUsual_Usual_params, anyParams uint64) MoqUsual_Usual_paramsKey {
	a.Moq.Moq_Usual.Scene.T.Helper()
	sParamUsed, sParamUsedHash := impl.ParamKey(
		params.SParam, 1, a.Moq.Runtime.ParameterIndexing.Usual.SParam, anyParams)
	bParamUsed, bParamUsedHash := impl.ParamKey(
		params.BParam, 2, a.Moq.Runtime.ParameterIndexing.Usual.BParam, anyParams)
	return MoqUsual_Usual_paramsKey{
		Params: struct {
			SParam string
			BParam bool
		}{
			SParam: sParamUsed,
			BParam: bParamUsed,
		},
		Hashes: struct {
			SParam hash.Hash
			BParam hash.Hash
		}{
			SParam: sParamUsedHash,
			BParam: bParamUsedHash,
		},
	}
}

func (m *MoqUsual_recorder) NoNames(param1 string, param2 bool) *MoqUsual_NoNames_recorder {
	return &MoqUsual_NoNames_recorder{
		Recorder: m.Moq.Moq_NoNames.OnCall(MoqUsual_NoNames_params{
			Param1: param1,
			Param2: param2,
		}),
	}
}

func (r *MoqUsual_NoNames_recorder) Any() *MoqUsual_NoNames_anyParams {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.IsAnyPermitted(true) {
		return nil
	}
	return &MoqUsual_NoNames_anyParams{Recorder: r}
}

func (a *MoqUsual_NoNames_anyParams) Param1() *MoqUsual_NoNames_recorder {
	a.Recorder.Recorder.AnyParam(1)
	return a.Recorder
}

func (a *MoqUsual_NoNames_anyParams) Param2() *MoqUsual_NoNames_recorder {
	a.Recorder.Recorder.AnyParam(2)
	return a.Recorder
}

func (r *MoqUsual_NoNames_recorder) Seq() *MoqUsual_NoNames_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(true, "Seq", true) {
		return nil
	}
	return r
}

func (r *MoqUsual_NoNames_recorder) NoSeq() *MoqUsual_NoNames_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(false, "NoSeq", true) {
		return nil
	}
	return r
}

func (r *MoqUsual_NoNames_recorder) ReturnResults(result1 string, result2 error) *MoqUsual_NoNames_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.ReturnResults(MoqUsual_NoNames_results{
		Result1: result1,
		Result2: result2,
	})
	return r
}

func (r *MoqUsual_NoNames_recorder) AndDo(fn MoqUsual_NoNames_doFn) *MoqUsual_NoNames_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.AndDo(func(params MoqUsual_NoNames_params) {
		fn(params.Param1, params.Param2)
	}, true) {
		return nil
	}
	return r
}

func (r *MoqUsual_NoNames_recorder) DoReturnResults(fn MoqUsual_NoNames_doReturnFn) *MoqUsual_NoNames_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.DoReturnResults(func(params MoqUsual_NoNames_params) *MoqUsual_NoNames_results {
		result1, result2 := fn(params.Param1, params.Param2)
		return &MoqUsual_NoNames_results{
			Result1: result1,
			Result2: result2,
		}
	})
	return r
}

func (r *MoqUsual_NoNames_recorder) Repeat(repeaters ...moq.Repeater) *MoqUsual_NoNames_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Repeat(repeaters, true) {
		return nil
	}
	return r
}

func (*MoqUsual_NoNames_adaptor) PrettyParams(params MoqUsual_NoNames_params) string {
	return fmt.Sprintf("NoNames(%#v, %#v)", params.Param1, params.Param2)
}

func (a *MoqUsual_NoNames_adaptor) ParamsKey(params MoqUsual_NoNames_params, anyParams uint64) MoqUsual_NoNames_paramsKey {
	a.Moq.Moq_NoNames.Scene.T.Helper()
	param1Used, param1UsedHash := impl.ParamKey(
		params.Param1, 1, a.Moq.Runtime.ParameterIndexing.NoNames.Param1, anyParams)
	param2Used, param2UsedHash := impl.ParamKey(
		params.Param2, 2, a.Moq.Runtime.ParameterIndexing.NoNames.Param2, anyParams)
	return MoqUsual_NoNames_paramsKey{
		Params: struct {
			Param1 string
			Param2 bool
		}{
			Param1: param1Used,
			Param2: param2Used,
		},
		Hashes: struct {
			Param1 hash.Hash
			Param2 hash.Hash
		}{
			Param1: param1UsedHash,
			Param2: param2UsedHash,
		},
	}
}

func (m *MoqUsual_recorder) NoResults(sParam string, bParam bool) *MoqUsual_NoResults_recorder {
	return &MoqUsual_NoResults_recorder{
		Recorder: m.Moq.Moq_NoResults.OnCall(MoqUsual_NoResults_params{
			SParam: sParam,
			BParam: bParam,
		}),
	}
}

func (r *MoqUsual_NoResults_recorder) Any() *MoqUsual_NoResults_anyParams {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.IsAnyPermitted(true) {
		return nil
	}
	return &MoqUsual_NoResults_anyParams{Recorder: r}
}

func (a *MoqUsual_NoResults_anyParams) SParam() *MoqUsual_NoResults_recorder {
	a.Recorder.Recorder.AnyParam(1)
	return a.Recorder
}

func (a *MoqUsual_NoResults_anyParams) BParam() *MoqUsual_NoResults_recorder {
	a.Recorder.Recorder.AnyParam(2)
	return a.Recorder
}

func (r *MoqUsual_NoResults_recorder) Seq() *MoqUsual_NoResults_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(true, "Seq", true) {
		return nil
	}
	return r
}

func (r *MoqUsual_NoResults_recorder) NoSeq() *MoqUsual_NoResults_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(false, "NoSeq", true) {
		return nil
	}
	return r
}

func (r *MoqUsual_NoResults_recorder) ReturnResults() *MoqUsual_NoResults_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.ReturnResults(MoqUsual_NoResults_results{})
	return r
}

func (r *MoqUsual_NoResults_recorder) AndDo(fn MoqUsual_NoResults_doFn) *MoqUsual_NoResults_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.AndDo(func(params MoqUsual_NoResults_params) {
		fn(params.SParam, params.BParam)
	}, true) {
		return nil
	}
	return r
}

func (r *MoqUsual_NoResults_recorder) DoReturnResults(fn MoqUsual_NoResults_doReturnFn) *MoqUsual_NoResults_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.DoReturnResults(func(params MoqUsual_NoResults_params) *MoqUsual_NoResults_results {
		fn(params.SParam, params.BParam)
		return &MoqUsual_NoResults_results{}
	})
	return r
}

func (r *MoqUsual_NoResults_recorder) Repeat(repeaters ...moq.Repeater) *MoqUsual_NoResults_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Repeat(repeaters, true) {
		return nil
	}
	return r
}

func (*MoqUsual_NoResults_adaptor) PrettyParams(params MoqUsual_NoResults_params) string {
	return fmt.Sprintf("NoResults(%#v, %#v)", params.SParam, params.BParam)
}

func (a *MoqUsual_NoResults_adaptor) ParamsKey(params MoqUsual_NoResults_params, anyParams uint64) MoqUsual_NoResults_paramsKey {
	a.Moq.Moq_NoResults.Scene.T.Helper()
	sParamUsed, sParamUsedHash := impl.ParamKey(
		params.SParam, 1, a.Moq.Runtime.ParameterIndexing.NoResults.SParam, anyParams)
	bParamUsed, bParamUsedHash := impl.ParamKey(
		params.BParam, 2, a.Moq.Runtime.ParameterIndexing.NoResults.BParam, anyParams)
	return MoqUsual_NoResults_paramsKey{
		Params: struct {
			SParam string
			BParam bool
		}{
			SParam: sParamUsed,
			BParam: bParamUsed,
		},
		Hashes: struct {
			SParam hash.Hash
			BParam hash.Hash
		}{
			SParam: sParamUsedHash,
			BParam: bParamUsedHash,
		},
	}
}

func (m *MoqUsual_recorder) NoParams() *MoqUsual_NoParams_recorder {
	return &MoqUsual_NoParams_recorder{
		Recorder: m.Moq.Moq_NoParams.OnCall(MoqUsual_NoParams_params{}),
	}
}

func (r *MoqUsual_NoParams_recorder) Any() *MoqUsual_NoParams_anyParams {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.IsAnyPermitted(true) {
		return nil
	}
	return &MoqUsual_NoParams_anyParams{Recorder: r}
}

func (r *MoqUsual_NoParams_recorder) Seq() *MoqUsual_NoParams_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(true, "Seq", true) {
		return nil
	}
	return r
}

func (r *MoqUsual_NoParams_recorder) NoSeq() *MoqUsual_NoParams_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(false, "NoSeq", true) {
		return nil
	}
	return r
}

func (r *MoqUsual_NoParams_recorder) ReturnResults(sResult string, err error) *MoqUsual_NoParams_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.ReturnResults(MoqUsual_NoParams_results{
		SResult: sResult,
		Err:     err,
	})
	return r
}

func (r *MoqUsual_NoParams_recorder) AndDo(fn MoqUsual_NoParams_doFn) *MoqUsual_NoParams_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.AndDo(func(params MoqUsual_NoParams_params) {
		fn()
	}, true) {
		return nil
	}
	return r
}

func (r *MoqUsual_NoParams_recorder) DoReturnResults(fn MoqUsual_NoParams_doReturnFn) *MoqUsual_NoParams_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.DoReturnResults(func(params MoqUsual_NoParams_params) *MoqUsual_NoParams_results {
		sResult, err := fn()
		return &MoqUsual_NoParams_results{
			SResult: sResult,
			Err:     err,
		}
	})
	return r
}

func (r *MoqUsual_NoParams_recorder) Repeat(repeaters ...moq.Repeater) *MoqUsual_NoParams_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Repeat(repeaters, true) {
		return nil
	}
	return r
}

func (*MoqUsual_NoParams_adaptor) PrettyParams(params MoqUsual_NoParams_params) string {
	return fmt.Sprintf("NoParams()")
}

func (a *MoqUsual_NoParams_adaptor) ParamsKey(params MoqUsual_NoParams_params, anyParams uint64) MoqUsual_NoParams_paramsKey {
	a.Moq.Moq_NoParams.Scene.T.Helper()
	return MoqUsual_NoParams_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqUsual_recorder) Nothing() *MoqUsual_Nothing_recorder {
	return &MoqUsual_Nothing_recorder{
		Recorder: m.Moq.Moq_Nothing.OnCall(MoqUsual_Nothing_params{}),
	}
}

func (r *MoqUsual_Nothing_recorder) Any() *MoqUsual_Nothing_anyParams {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.IsAnyPermitted(true) {
		return nil
	}
	return &MoqUsual_Nothing_anyParams{Recorder: r}
}

func (r *MoqUsual_Nothing_recorder) Seq() *MoqUsual_Nothing_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(true, "Seq", true) {
		return nil
	}
	return r
}

func (r *MoqUsual_Nothing_recorder) NoSeq() *MoqUsual_Nothing_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(false, "NoSeq", true) {
		return nil
	}
	return r
}

func (r *MoqUsual_Nothing_recorder) ReturnResults() *MoqUsual_Nothing_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.ReturnResults(MoqUsual_Nothing_results{})
	return r
}

func (r *MoqUsual_Nothing_recorder) AndDo(fn MoqUsual_Nothing_doFn) *MoqUsual_Nothing_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.AndDo(func(params MoqUsual_Nothing_params) {
		fn()
	}, true) {
		return nil
	}
	return r
}

func (r *MoqUsual_Nothing_recorder) DoReturnResults(fn MoqUsual_Nothing_doReturnFn) *MoqUsual_Nothing_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.DoReturnResults(func(params MoqUsual_Nothing_params) *MoqUsual_Nothing_results {
		fn()
		return &MoqUsual_Nothing_results{}
	})
	return r
}

func (r *MoqUsual_Nothing_recorder) Repeat(repeaters ...moq.Repeater) *MoqUsual_Nothing_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Repeat(repeaters, true) {
		return nil
	}
	return r
}

func (*MoqUsual_Nothing_adaptor) PrettyParams(params MoqUsual_Nothing_params) string {
	return fmt.Sprintf("Nothing()")
}

func (a *MoqUsual_Nothing_adaptor) ParamsKey(params MoqUsual_Nothing_params, anyParams uint64) MoqUsual_Nothing_paramsKey {
	a.Moq.Moq_Nothing.Scene.T.Helper()
	return MoqUsual_Nothing_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqUsual_recorder) Variadic(other bool, args ...string) *MoqUsual_Variadic_recorder {
	return &MoqUsual_Variadic_recorder{
		Recorder: m.Moq.Moq_Variadic.OnCall(MoqUsual_Variadic_params{
			Other: other,
			Args:  args,
		}),
	}
}

func (r *MoqUsual_Variadic_recorder) Any() *MoqUsual_Variadic_anyParams {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.IsAnyPermitted(true) {
		return nil
	}
	return &MoqUsual_Variadic_anyParams{Recorder: r}
}

func (a *MoqUsual_Variadic_anyParams) Other() *MoqUsual_Variadic_recorder {
	a.Recorder.Recorder.AnyParam(1)
	return a.Recorder
}

func (a *MoqUsual_Variadic_anyParams) Args() *MoqUsual_Variadic_recorder {
	a.Recorder.Recorder.AnyParam(2)
	return a.Recorder
}

func (r *MoqUsual_Variadic_recorder) Seq() *MoqUsual_Variadic_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(true, "Seq", true) {
		return nil
	}
	return r
}

func (r *MoqUsual_Variadic_recorder) NoSeq() *MoqUsual_Variadic_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(false, "NoSeq", true) {
		return nil
	}
	return r
}

func (r *MoqUsual_Variadic_recorder) ReturnResults(sResult string, err error) *MoqUsual_Variadic_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.ReturnResults(MoqUsual_Variadic_results{
		SResult: sResult,
		Err:     err,
	})
	return r
}

func (r *MoqUsual_Variadic_recorder) AndDo(fn MoqUsual_Variadic_doFn) *MoqUsual_Variadic_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.AndDo(func(params MoqUsual_Variadic_params) {
		fn(params.Other, params.Args...)
	}, true) {
		return nil
	}
	return r
}

func (r *MoqUsual_Variadic_recorder) DoReturnResults(fn MoqUsual_Variadic_doReturnFn) *MoqUsual_Variadic_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.DoReturnResults(func(params MoqUsual_Variadic_params) *MoqUsual_Variadic_results {
		sResult, err := fn(params.Other, params.Args...)
		return &MoqUsual_Variadic_results{
			SResult: sResult,
			Err:     err,
		}
	})
	return r
}

func (r *MoqUsual_Variadic_recorder) Repeat(repeaters ...moq.Repeater) *MoqUsual_Variadic_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Repeat(repeaters, true) {
		return nil
	}
	return r
}

func (*MoqUsual_Variadic_adaptor) PrettyParams(params MoqUsual_Variadic_params) string {
	return fmt.Sprintf("Variadic(%#v, %#v)", params.Other, params.Args)
}

func (a *MoqUsual_Variadic_adaptor) ParamsKey(params MoqUsual_Variadic_params, anyParams uint64) MoqUsual_Variadic_paramsKey {
	a.Moq.Moq_Variadic.Scene.T.Helper()
	otherUsed, otherUsedHash := impl.ParamKey(
		params.Other, 1, a.Moq.Runtime.ParameterIndexing.Variadic.Other, anyParams)
	argsUsedHash := impl.HashOnlyParamKey(a.Moq.Moq_Variadic.Scene.T,
		params.Args, "args", 2, a.Moq.Runtime.ParameterIndexing.Variadic.Args, anyParams)
	return MoqUsual_Variadic_paramsKey{
		Params: struct{ Other bool }{
			Other: otherUsed,
		},
		Hashes: struct {
			Other hash.Hash
			Args  hash.Hash
		}{
			Other: otherUsedHash,
			Args:  argsUsedHash,
		},
	}
}

func (m *MoqUsual_recorder) RepeatedIds(sParam1, sParam2 string, bParam bool) *MoqUsual_RepeatedIds_recorder {
	return &MoqUsual_RepeatedIds_recorder{
		Recorder: m.Moq.Moq_RepeatedIds.OnCall(MoqUsual_RepeatedIds_params{
			SParam1: sParam1,
			SParam2: sParam2,
			BParam:  bParam,
		}),
	}
}

func (r *MoqUsual_RepeatedIds_recorder) Any() *MoqUsual_RepeatedIds_anyParams {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.IsAnyPermitted(true) {
		return nil
	}
	return &MoqUsual_RepeatedIds_anyParams{Recorder: r}
}

func (a *MoqUsual_RepeatedIds_anyParams) SParam1() *MoqUsual_RepeatedIds_recorder {
	a.Recorder.Recorder.AnyParam(1)
	return a.Recorder
}

func (a *MoqUsual_RepeatedIds_anyParams) SParam2() *MoqUsual_RepeatedIds_recorder {
	a.Recorder.Recorder.AnyParam(2)
	return a.Recorder
}

func (a *MoqUsual_RepeatedIds_anyParams) BParam() *MoqUsual_RepeatedIds_recorder {
	a.Recorder.Recorder.AnyParam(3)
	return a.Recorder
}

func (r *MoqUsual_RepeatedIds_recorder) Seq() *MoqUsual_RepeatedIds_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(true, "Seq", true) {
		return nil
	}
	return r
}

func (r *MoqUsual_RepeatedIds_recorder) NoSeq() *MoqUsual_RepeatedIds_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(false, "NoSeq", true) {
		return nil
	}
	return r
}

func (r *MoqUsual_RepeatedIds_recorder) ReturnResults(sResult1, sResult2 string, err error) *MoqUsual_RepeatedIds_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.ReturnResults(MoqUsual_RepeatedIds_results{
		SResult1: sResult1,
		SResult2: sResult2,
		Err:      err,
	})
	return r
}

func (r *MoqUsual_RepeatedIds_recorder) AndDo(fn MoqUsual_RepeatedIds_doFn) *MoqUsual_RepeatedIds_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.AndDo(func(params MoqUsual_RepeatedIds_params) {
		fn(params.SParam1, params.SParam2, params.BParam)
	}, true) {
		return nil
	}
	return r
}

func (r *MoqUsual_RepeatedIds_recorder) DoReturnResults(fn MoqUsual_RepeatedIds_doReturnFn) *MoqUsual_RepeatedIds_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.DoReturnResults(func(params MoqUsual_RepeatedIds_params) *MoqUsual_RepeatedIds_results {
		sResult1, sResult2, err := fn(params.SParam1, params.SParam2, params.BParam)
		return &MoqUsual_RepeatedIds_results{
			SResult1: sResult1,
			SResult2: sResult2,
			Err:      err,
		}
	})
	return r
}

func (r *MoqUsual_RepeatedIds_recorder) Repeat(repeaters ...moq.Repeater) *MoqUsual_RepeatedIds_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Repeat(repeaters, true) {
		return nil
	}
	return r
}

func (*MoqUsual_RepeatedIds_adaptor) PrettyParams(params MoqUsual_RepeatedIds_params) string {
	return fmt.Sprintf("RepeatedIds(%#v, %#v, %#v)", params.SParam1, params.SParam2, params.BParam)
}

func (a *MoqUsual_RepeatedIds_adaptor) ParamsKey(params MoqUsual_RepeatedIds_params, anyParams uint64) MoqUsual_RepeatedIds_paramsKey {
	a.Moq.Moq_RepeatedIds.Scene.T.Helper()
	sParam1Used, sParam1UsedHash := impl.ParamKey(
		params.SParam1, 1, a.Moq.Runtime.ParameterIndexing.RepeatedIds.SParam1, anyParams)
	sParam2Used, sParam2UsedHash := impl.ParamKey(
		params.SParam2, 2, a.Moq.Runtime.ParameterIndexing.RepeatedIds.SParam2, anyParams)
	bParamUsed, bParamUsedHash := impl.ParamKey(
		params.BParam, 3, a.Moq.Runtime.ParameterIndexing.RepeatedIds.BParam, anyParams)
	return MoqUsual_RepeatedIds_paramsKey{
		Params: struct {
			SParam1, SParam2 string
			BParam           bool
		}{
			SParam1: sParam1Used,
			SParam2: sParam2Used,
			BParam:  bParamUsed,
		},
		Hashes: struct {
			SParam1, SParam2 hash.Hash
			BParam           hash.Hash
		}{
			SParam1: sParam1UsedHash,
			SParam2: sParam2UsedHash,
			BParam:  bParamUsedHash,
		},
	}
}

func (m *MoqUsual_recorder) Times(sParam string, times bool) *MoqUsual_Times_recorder {
	return &MoqUsual_Times_recorder{
		Recorder: m.Moq.Moq_Times.OnCall(MoqUsual_Times_params{
			SParam: sParam,
			Times:  times,
		}),
	}
}

func (r *MoqUsual_Times_recorder) Any() *MoqUsual_Times_anyParams {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.IsAnyPermitted(true) {
		return nil
	}
	return &MoqUsual_Times_anyParams{Recorder: r}
}

func (a *MoqUsual_Times_anyParams) SParam() *MoqUsual_Times_recorder {
	a.Recorder.Recorder.AnyParam(1)
	return a.Recorder
}

func (a *MoqUsual_Times_anyParams) Times() *MoqUsual_Times_recorder {
	a.Recorder.Recorder.AnyParam(2)
	return a.Recorder
}

func (r *MoqUsual_Times_recorder) Seq() *MoqUsual_Times_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(true, "Seq", true) {
		return nil
	}
	return r
}

func (r *MoqUsual_Times_recorder) NoSeq() *MoqUsual_Times_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(false, "NoSeq", true) {
		return nil
	}
	return r
}

func (r *MoqUsual_Times_recorder) ReturnResults(sResult string, err error) *MoqUsual_Times_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.ReturnResults(MoqUsual_Times_results{
		SResult: sResult,
		Err:     err,
	})
	return r
}

func (r *MoqUsual_Times_recorder) AndDo(fn MoqUsual_Times_doFn) *MoqUsual_Times_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.AndDo(func(params MoqUsual_Times_params) {
		fn(params.SParam, params.Times)
	}, true) {
		return nil
	}
	return r
}

func (r *MoqUsual_Times_recorder) DoReturnResults(fn MoqUsual_Times_doReturnFn) *MoqUsual_Times_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.DoReturnResults(func(params MoqUsual_Times_params) *MoqUsual_Times_results {
		sResult, err := fn(params.SParam, params.Times)
		return &MoqUsual_Times_results{
			SResult: sResult,
			Err:     err,
		}
	})
	return r
}

func (r *MoqUsual_Times_recorder) Repeat(repeaters ...moq.Repeater) *MoqUsual_Times_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Repeat(repeaters, true) {
		return nil
	}
	return r
}

func (*MoqUsual_Times_adaptor) PrettyParams(params MoqUsual_Times_params) string {
	return fmt.Sprintf("Times(%#v, %#v)", params.SParam, params.Times)
}

func (a *MoqUsual_Times_adaptor) ParamsKey(params MoqUsual_Times_params, anyParams uint64) MoqUsual_Times_paramsKey {
	a.Moq.Moq_Times.Scene.T.Helper()
	sParamUsed, sParamUsedHash := impl.ParamKey(
		params.SParam, 1, a.Moq.Runtime.ParameterIndexing.Times.SParam, anyParams)
	timesUsed, timesUsedHash := impl.ParamKey(
		params.Times, 2, a.Moq.Runtime.ParameterIndexing.Times.Times, anyParams)
	return MoqUsual_Times_paramsKey{
		Params: struct {
			SParam string
			Times  bool
		}{
			SParam: sParamUsed,
			Times:  timesUsed,
		},
		Hashes: struct {
			SParam hash.Hash
			Times  hash.Hash
		}{
			SParam: sParamUsedHash,
			Times:  timesUsedHash,
		},
	}
}

func (m *MoqUsual_recorder) DifficultParamNames(param1, param2 bool, param3 string, param, param5, param6 int, param7, param8, param9 float32) *MoqUsual_DifficultParamNames_recorder {
	return &MoqUsual_DifficultParamNames_recorder{
		Recorder: m.Moq.Moq_DifficultParamNames.OnCall(MoqUsual_DifficultParamNames_params{
			Param1: param1,
			Param2: param2,
			Param3: param3,
			Param:  param,
			Param5: param5,
			Param6: param6,
			Param7: param7,
			Param8: param8,
			Param9: param9,
		}),
	}
}

func (r *MoqUsual_DifficultParamNames_recorder) Any() *MoqUsual_DifficultParamNames_anyParams {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.IsAnyPermitted(true) {
		return nil
	}
	return &MoqUsual_DifficultParamNames_anyParams{Recorder: r}
}

func (a *MoqUsual_DifficultParamNames_anyParams) Param1() *MoqUsual_DifficultParamNames_recorder {
	a.Recorder.Recorder.AnyParam(1)
	return a.Recorder
}

func (a *MoqUsual_DifficultParamNames_anyParams) Param2() *MoqUsual_DifficultParamNames_recorder {
	a.Recorder.Recorder.AnyParam(2)
	return a.Recorder
}

func (a *MoqUsual_DifficultParamNames_anyParams) Param3() *MoqUsual_DifficultParamNames_recorder {
	a.Recorder.Recorder.AnyParam(3)
	return a.Recorder
}

func (a *MoqUsual_DifficultParamNames_anyParams) Param() *MoqUsual_DifficultParamNames_recorder {
	a.Recorder.Recorder.AnyParam(4)
	return a.Recorder
}

func (a *MoqUsual_DifficultParamNames_anyParams) Param5() *MoqUsual_DifficultParamNames_recorder {
	a.Recorder.Recorder.AnyParam(5)
	return a.Recorder
}

func (a *MoqUsual_DifficultParamNames_anyParams) Param6() *MoqUsual_DifficultParamNames_recorder {
	a.Recorder.Recorder.AnyParam(6)
	return a.Recorder
}

func (a *MoqUsual_DifficultParamNames_anyParams) Param7() *MoqUsual_DifficultParamNames_recorder {
	a.Recorder.Recorder.AnyParam(7)
	return a.Recorder
}

func (a *MoqUsual_DifficultParamNames_anyParams) Param8() *MoqUsual_DifficultParamNames_recorder {
	a.Recorder.Recorder.AnyParam(8)
	return a.Recorder
}

func (a *MoqUsual_DifficultParamNames_anyParams) Param9() *MoqUsual_DifficultParamNames_recorder {
	a.Recorder.Recorder.AnyParam(9)
	return a.Recorder
}

func (r *MoqUsual_DifficultParamNames_recorder) Seq() *MoqUsual_DifficultParamNames_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(true, "Seq", true) {
		return nil
	}
	return r
}

func (r *MoqUsual_DifficultParamNames_recorder) NoSeq() *MoqUsual_DifficultParamNames_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(false, "NoSeq", true) {
		return nil
	}
	return r
}

func (r *MoqUsual_DifficultParamNames_recorder) ReturnResults() *MoqUsual_DifficultParamNames_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.ReturnResults(MoqUsual_DifficultParamNames_results{})
	return r
}

func (r *MoqUsual_DifficultParamNames_recorder) AndDo(fn MoqUsual_DifficultParamNames_doFn) *MoqUsual_DifficultParamNames_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.AndDo(func(params MoqUsual_DifficultParamNames_params) {
		fn(params.Param1, params.Param2, params.Param3, params.Param, params.Param5, params.Param6, params.Param7, params.Param8, params.Param9)
	}, true) {
		return nil
	}
	return r
}

func (r *MoqUsual_DifficultParamNames_recorder) DoReturnResults(fn MoqUsual_DifficultParamNames_doReturnFn) *MoqUsual_DifficultParamNames_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.DoReturnResults(func(params MoqUsual_DifficultParamNames_params) *MoqUsual_DifficultParamNames_results {
		fn(params.Param1, params.Param2, params.Param3, params.Param, params.Param5, params.Param6, params.Param7, params.Param8, params.Param9)
		return &MoqUsual_DifficultParamNames_results{}
	})
	return r
}

func (r *MoqUsual_DifficultParamNames_recorder) Repeat(repeaters ...moq.Repeater) *MoqUsual_DifficultParamNames_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Repeat(repeaters, true) {
		return nil
	}
	return r
}

func (*MoqUsual_DifficultParamNames_adaptor) PrettyParams(params MoqUsual_DifficultParamNames_params) string {
	return fmt.Sprintf("DifficultParamNames(%#v, %#v, %#v, %#v, %#v, %#v, %#v, %#v, %#v)", params.Param1, params.Param2, params.Param3, params.Param, params.Param5, params.Param6, params.Param7, params.Param8, params.Param9)
}

func (a *MoqUsual_DifficultParamNames_adaptor) ParamsKey(params MoqUsual_DifficultParamNames_params, anyParams uint64) MoqUsual_DifficultParamNames_paramsKey {
	a.Moq.Moq_DifficultParamNames.Scene.T.Helper()
	param1Used, param1UsedHash := impl.ParamKey(
		params.Param1, 1, a.Moq.Runtime.ParameterIndexing.DifficultParamNames.Param1, anyParams)
	param2Used, param2UsedHash := impl.ParamKey(
		params.Param2, 2, a.Moq.Runtime.ParameterIndexing.DifficultParamNames.Param2, anyParams)
	param3Used, param3UsedHash := impl.ParamKey(
		params.Param3, 3, a.Moq.Runtime.ParameterIndexing.DifficultParamNames.Param3, anyParams)
	paramUsed, paramUsedHash := impl.ParamKey(
		params.Param, 4, a.Moq.Runtime.ParameterIndexing.DifficultParamNames.Param, anyParams)
	param5Used, param5UsedHash := impl.ParamKey(
		params.Param5, 5, a.Moq.Runtime.ParameterIndexing.DifficultParamNames.Param5, anyParams)
	param6Used, param6UsedHash := impl.ParamKey(
		params.Param6, 6, a.Moq.Runtime.ParameterIndexing.DifficultParamNames.Param6, anyParams)
	param7Used, param7UsedHash := impl.ParamKey(
		params.Param7, 7, a.Moq.Runtime.ParameterIndexing.DifficultParamNames.Param7, anyParams)
	param8Used, param8UsedHash := impl.ParamKey(
		params.Param8, 8, a.Moq.Runtime.ParameterIndexing.DifficultParamNames.Param8, anyParams)
	param9Used, param9UsedHash := impl.ParamKey(
		params.Param9, 9, a.Moq.Runtime.ParameterIndexing.DifficultParamNames.Param9, anyParams)
	return MoqUsual_DifficultParamNames_paramsKey{
		Params: struct {
			Param1, Param2         bool
			Param3                 string
			Param, Param5, Param6  int
			Param7, Param8, Param9 float32
		}{
			Param1: param1Used,
			Param2: param2Used,
			Param3: param3Used,
			Param:  paramUsed,
			Param5: param5Used,
			Param6: param6Used,
			Param7: param7Used,
			Param8: param8Used,
			Param9: param9Used,
		},
		Hashes: struct {
			Param1, Param2         hash.Hash
			Param3                 hash.Hash
			Param, Param5, Param6  hash.Hash
			Param7, Param8, Param9 hash.Hash
		}{
			Param1: param1UsedHash,
			Param2: param2UsedHash,
			Param3: param3UsedHash,
			Param:  paramUsedHash,
			Param5: param5UsedHash,
			Param6: param6UsedHash,
			Param7: param7UsedHash,
			Param8: param8UsedHash,
			Param9: param9UsedHash,
		},
	}
}

func (m *MoqUsual_recorder) DifficultResultNames() *MoqUsual_DifficultResultNames_recorder {
	return &MoqUsual_DifficultResultNames_recorder{
		Recorder: m.Moq.Moq_DifficultResultNames.OnCall(MoqUsual_DifficultResultNames_params{}),
	}
}

func (r *MoqUsual_DifficultResultNames_recorder) Any() *MoqUsual_DifficultResultNames_anyParams {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.IsAnyPermitted(true) {
		return nil
	}
	return &MoqUsual_DifficultResultNames_anyParams{Recorder: r}
}

func (r *MoqUsual_DifficultResultNames_recorder) Seq() *MoqUsual_DifficultResultNames_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(true, "Seq", true) {
		return nil
	}
	return r
}

func (r *MoqUsual_DifficultResultNames_recorder) NoSeq() *MoqUsual_DifficultResultNames_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(false, "NoSeq", true) {
		return nil
	}
	return r
}

func (r *MoqUsual_DifficultResultNames_recorder) ReturnResults(result1, result2 string, result3 error, param, result5, result6 int, result7, result8, result9 float32) *MoqUsual_DifficultResultNames_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.ReturnResults(MoqUsual_DifficultResultNames_results{
		Result1: result1,
		Result2: result2,
		Result3: result3,
		Param:   param,
		Result5: result5,
		Result6: result6,
		Result7: result7,
		Result8: result8,
		Result9: result9,
	})
	return r
}

func (r *MoqUsual_DifficultResultNames_recorder) AndDo(fn MoqUsual_DifficultResultNames_doFn) *MoqUsual_DifficultResultNames_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.AndDo(func(params MoqUsual_DifficultResultNames_params) {
		fn()
	}, true) {
		return nil
	}
	return r
}

func (r *MoqUsual_DifficultResultNames_recorder) DoReturnResults(fn MoqUsual_DifficultResultNames_doReturnFn) *MoqUsual_DifficultResultNames_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.DoReturnResults(func(params MoqUsual_DifficultResultNames_params) *MoqUsual_DifficultResultNames_results {
		result1, result2, result3, param, result5, result6, result7, result8, result9 := fn()
		return &MoqUsual_DifficultResultNames_results{
			Result1: result1,
			Result2: result2,
			Result3: result3,
			Param:   param,
			Result5: result5,
			Result6: result6,
			Result7: result7,
			Result8: result8,
			Result9: result9,
		}
	})
	return r
}

func (r *MoqUsual_DifficultResultNames_recorder) Repeat(repeaters ...moq.Repeater) *MoqUsual_DifficultResultNames_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Repeat(repeaters, true) {
		return nil
	}
	return r
}

func (*MoqUsual_DifficultResultNames_adaptor) PrettyParams(params MoqUsual_DifficultResultNames_params) string {
	return fmt.Sprintf("DifficultResultNames()")
}

func (a *MoqUsual_DifficultResultNames_adaptor) ParamsKey(params MoqUsual_DifficultResultNames_params, anyParams uint64) MoqUsual_DifficultResultNames_paramsKey {
	a.Moq.Moq_DifficultResultNames.Scene.T.Helper()
	return MoqUsual_DifficultResultNames_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqUsual_recorder) PassByArray(p [3]testmoqs.Params) *MoqUsual_PassByArray_recorder {
	return &MoqUsual_PassByArray_recorder{
		Recorder: m.Moq.Moq_PassByArray.OnCall(MoqUsual_PassByArray_params{
			P: p,
		}),
	}
}

func (r *MoqUsual_PassByArray_recorder) Any() *MoqUsual_PassByArray_anyParams {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.IsAnyPermitted(true) {
		return nil
	}
	return &MoqUsual_PassByArray_anyParams{Recorder: r}
}

func (a *MoqUsual_PassByArray_anyParams) P() *MoqUsual_PassByArray_recorder {
	a.Recorder.Recorder.AnyParam(1)
	return a.Recorder
}

func (r *MoqUsual_PassByArray_recorder) Seq() *MoqUsual_PassByArray_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(true, "Seq", true) {
		return nil
	}
	return r
}

func (r *MoqUsual_PassByArray_recorder) NoSeq() *MoqUsual_PassByArray_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(false, "NoSeq", true) {
		return nil
	}
	return r
}

func (r *MoqUsual_PassByArray_recorder) ReturnResults(result1 [3]testmoqs.Results) *MoqUsual_PassByArray_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.ReturnResults(MoqUsual_PassByArray_results{
		Result1: result1,
	})
	return r
}

func (r *MoqUsual_PassByArray_recorder) AndDo(fn MoqUsual_PassByArray_doFn) *MoqUsual_PassByArray_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.AndDo(func(params MoqUsual_PassByArray_params) {
		fn(params.P)
	}, true) {
		return nil
	}
	return r
}

func (r *MoqUsual_PassByArray_recorder) DoReturnResults(fn MoqUsual_PassByArray_doReturnFn) *MoqUsual_PassByArray_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.DoReturnResults(func(params MoqUsual_PassByArray_params) *MoqUsual_PassByArray_results {
		result1 := fn(params.P)
		return &MoqUsual_PassByArray_results{
			Result1: result1,
		}
	})
	return r
}

func (r *MoqUsual_PassByArray_recorder) Repeat(repeaters ...moq.Repeater) *MoqUsual_PassByArray_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Repeat(repeaters, true) {
		return nil
	}
	return r
}

func (*MoqUsual_PassByArray_adaptor) PrettyParams(params MoqUsual_PassByArray_params) string {
	return fmt.Sprintf("PassByArray(%#v)", params.P)
}

func (a *MoqUsual_PassByArray_adaptor) ParamsKey(params MoqUsual_PassByArray_params, anyParams uint64) MoqUsual_PassByArray_paramsKey {
	a.Moq.Moq_PassByArray.Scene.T.Helper()
	pUsed, pUsedHash := impl.ParamKey(
		params.P, 1, a.Moq.Runtime.ParameterIndexing.PassByArray.P, anyParams)
	return MoqUsual_PassByArray_paramsKey{
		Params: struct{ P [3]testmoqs.Params }{
			P: pUsed,
		},
		Hashes: struct{ P hash.Hash }{
			P: pUsedHash,
		},
	}
}

func (m *MoqUsual_recorder) PassByChan(p chan testmoqs.Params) *MoqUsual_PassByChan_recorder {
	return &MoqUsual_PassByChan_recorder{
		Recorder: m.Moq.Moq_PassByChan.OnCall(MoqUsual_PassByChan_params{
			P: p,
		}),
	}
}

func (r *MoqUsual_PassByChan_recorder) Any() *MoqUsual_PassByChan_anyParams {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.IsAnyPermitted(true) {
		return nil
	}
	return &MoqUsual_PassByChan_anyParams{Recorder: r}
}

func (a *MoqUsual_PassByChan_anyParams) P() *MoqUsual_PassByChan_recorder {
	a.Recorder.Recorder.AnyParam(1)
	return a.Recorder
}

func (r *MoqUsual_PassByChan_recorder) Seq() *MoqUsual_PassByChan_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(true, "Seq", true) {
		return nil
	}
	return r
}

func (r *MoqUsual_PassByChan_recorder) NoSeq() *MoqUsual_PassByChan_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(false, "NoSeq", true) {
		return nil
	}
	return r
}

func (r *MoqUsual_PassByChan_recorder) ReturnResults(result1 chan testmoqs.Results) *MoqUsual_PassByChan_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.ReturnResults(MoqUsual_PassByChan_results{
		Result1: result1,
	})
	return r
}

func (r *MoqUsual_PassByChan_recorder) AndDo(fn MoqUsual_PassByChan_doFn) *MoqUsual_PassByChan_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.AndDo(func(params MoqUsual_PassByChan_params) {
		fn(params.P)
	}, true) {
		return nil
	}
	return r
}

func (r *MoqUsual_PassByChan_recorder) DoReturnResults(fn MoqUsual_PassByChan_doReturnFn) *MoqUsual_PassByChan_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.DoReturnResults(func(params MoqUsual_PassByChan_params) *MoqUsual_PassByChan_results {
		result1 := fn(params.P)
		return &MoqUsual_PassByChan_results{
			Result1: result1,
		}
	})
	return r
}

func (r *MoqUsual_PassByChan_recorder) Repeat(repeaters ...moq.Repeater) *MoqUsual_PassByChan_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Repeat(repeaters, true) {
		return nil
	}
	return r
}

func (*MoqUsual_PassByChan_adaptor) PrettyParams(params MoqUsual_PassByChan_params) string {
	return fmt.Sprintf("PassByChan(%#v)", params.P)
}

func (a *MoqUsual_PassByChan_adaptor) ParamsKey(params MoqUsual_PassByChan_params, anyParams uint64) MoqUsual_PassByChan_paramsKey {
	a.Moq.Moq_PassByChan.Scene.T.Helper()
	pUsed, pUsedHash := impl.ParamKey(
		params.P, 1, a.Moq.Runtime.ParameterIndexing.PassByChan.P, anyParams)
	return MoqUsual_PassByChan_paramsKey{
		Params: struct{ P chan testmoqs.Params }{
			P: pUsed,
		},
		Hashes: struct{ P hash.Hash }{
			P: pUsedHash,
		},
	}
}

func (m *MoqUsual_recorder) PassByEllipsis(p ...testmoqs.Params) *MoqUsual_PassByEllipsis_recorder {
	return &MoqUsual_PassByEllipsis_recorder{
		Recorder: m.Moq.Moq_PassByEllipsis.OnCall(MoqUsual_PassByEllipsis_params{
			P: p,
		}),
	}
}

func (r *MoqUsual_PassByEllipsis_recorder) Any() *MoqUsual_PassByEllipsis_anyParams {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.IsAnyPermitted(true) {
		return nil
	}
	return &MoqUsual_PassByEllipsis_anyParams{Recorder: r}
}

func (a *MoqUsual_PassByEllipsis_anyParams) P() *MoqUsual_PassByEllipsis_recorder {
	a.Recorder.Recorder.AnyParam(1)
	return a.Recorder
}

func (r *MoqUsual_PassByEllipsis_recorder) Seq() *MoqUsual_PassByEllipsis_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(true, "Seq", true) {
		return nil
	}
	return r
}

func (r *MoqUsual_PassByEllipsis_recorder) NoSeq() *MoqUsual_PassByEllipsis_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(false, "NoSeq", true) {
		return nil
	}
	return r
}

func (r *MoqUsual_PassByEllipsis_recorder) ReturnResults(result1 string, result2 error) *MoqUsual_PassByEllipsis_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.ReturnResults(MoqUsual_PassByEllipsis_results{
		Result1: result1,
		Result2: result2,
	})
	return r
}

func (r *MoqUsual_PassByEllipsis_recorder) AndDo(fn MoqUsual_PassByEllipsis_doFn) *MoqUsual_PassByEllipsis_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.AndDo(func(params MoqUsual_PassByEllipsis_params) {
		fn(params.P...)
	}, true) {
		return nil
	}
	return r
}

func (r *MoqUsual_PassByEllipsis_recorder) DoReturnResults(fn MoqUsual_PassByEllipsis_doReturnFn) *MoqUsual_PassByEllipsis_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.DoReturnResults(func(params MoqUsual_PassByEllipsis_params) *MoqUsual_PassByEllipsis_results {
		result1, result2 := fn(params.P...)
		return &MoqUsual_PassByEllipsis_results{
			Result1: result1,
			Result2: result2,
		}
	})
	return r
}

func (r *MoqUsual_PassByEllipsis_recorder) Repeat(repeaters ...moq.Repeater) *MoqUsual_PassByEllipsis_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Repeat(repeaters, true) {
		return nil
	}
	return r
}

func (*MoqUsual_PassByEllipsis_adaptor) PrettyParams(params MoqUsual_PassByEllipsis_params) string {
	return fmt.Sprintf("PassByEllipsis(%#v)", params.P)
}

func (a *MoqUsual_PassByEllipsis_adaptor) ParamsKey(params MoqUsual_PassByEllipsis_params, anyParams uint64) MoqUsual_PassByEllipsis_paramsKey {
	a.Moq.Moq_PassByEllipsis.Scene.T.Helper()
	pUsedHash := impl.HashOnlyParamKey(a.Moq.Moq_PassByEllipsis.Scene.T,
		params.P, "p", 1, a.Moq.Runtime.ParameterIndexing.PassByEllipsis.P, anyParams)
	return MoqUsual_PassByEllipsis_paramsKey{
		Params: struct{}{},
		Hashes: struct{ P hash.Hash }{
			P: pUsedHash,
		},
	}
}

func (m *MoqUsual_recorder) PassByMap(p map[string]testmoqs.Params) *MoqUsual_PassByMap_recorder {
	return &MoqUsual_PassByMap_recorder{
		Recorder: m.Moq.Moq_PassByMap.OnCall(MoqUsual_PassByMap_params{
			P: p,
		}),
	}
}

func (r *MoqUsual_PassByMap_recorder) Any() *MoqUsual_PassByMap_anyParams {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.IsAnyPermitted(true) {
		return nil
	}
	return &MoqUsual_PassByMap_anyParams{Recorder: r}
}

func (a *MoqUsual_PassByMap_anyParams) P() *MoqUsual_PassByMap_recorder {
	a.Recorder.Recorder.AnyParam(1)
	return a.Recorder
}

func (r *MoqUsual_PassByMap_recorder) Seq() *MoqUsual_PassByMap_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(true, "Seq", true) {
		return nil
	}
	return r
}

func (r *MoqUsual_PassByMap_recorder) NoSeq() *MoqUsual_PassByMap_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(false, "NoSeq", true) {
		return nil
	}
	return r
}

func (r *MoqUsual_PassByMap_recorder) ReturnResults(result1 map[string]testmoqs.Results) *MoqUsual_PassByMap_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.ReturnResults(MoqUsual_PassByMap_results{
		Result1: result1,
	})
	return r
}

func (r *MoqUsual_PassByMap_recorder) AndDo(fn MoqUsual_PassByMap_doFn) *MoqUsual_PassByMap_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.AndDo(func(params MoqUsual_PassByMap_params) {
		fn(params.P)
	}, true) {
		return nil
	}
	return r
}

func (r *MoqUsual_PassByMap_recorder) DoReturnResults(fn MoqUsual_PassByMap_doReturnFn) *MoqUsual_PassByMap_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.DoReturnResults(func(params MoqUsual_PassByMap_params) *MoqUsual_PassByMap_results {
		result1 := fn(params.P)
		return &MoqUsual_PassByMap_results{
			Result1: result1,
		}
	})
	return r
}

func (r *MoqUsual_PassByMap_recorder) Repeat(repeaters ...moq.Repeater) *MoqUsual_PassByMap_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Repeat(repeaters, true) {
		return nil
	}
	return r
}

func (*MoqUsual_PassByMap_adaptor) PrettyParams(params MoqUsual_PassByMap_params) string {
	return fmt.Sprintf("PassByMap(%#v)", params.P)
}

func (a *MoqUsual_PassByMap_adaptor) ParamsKey(params MoqUsual_PassByMap_params, anyParams uint64) MoqUsual_PassByMap_paramsKey {
	a.Moq.Moq_PassByMap.Scene.T.Helper()
	pUsedHash := impl.HashOnlyParamKey(a.Moq.Moq_PassByMap.Scene.T,
		params.P, "p", 1, a.Moq.Runtime.ParameterIndexing.PassByMap.P, anyParams)
	return MoqUsual_PassByMap_paramsKey{
		Params: struct{}{},
		Hashes: struct{ P hash.Hash }{
			P: pUsedHash,
		},
	}
}

func (m *MoqUsual_recorder) PassByReference(p *testmoqs.Params) *MoqUsual_PassByReference_recorder {
	return &MoqUsual_PassByReference_recorder{
		Recorder: m.Moq.Moq_PassByReference.OnCall(MoqUsual_PassByReference_params{
			P: p,
		}),
	}
}

func (r *MoqUsual_PassByReference_recorder) Any() *MoqUsual_PassByReference_anyParams {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.IsAnyPermitted(true) {
		return nil
	}
	return &MoqUsual_PassByReference_anyParams{Recorder: r}
}

func (a *MoqUsual_PassByReference_anyParams) P() *MoqUsual_PassByReference_recorder {
	a.Recorder.Recorder.AnyParam(1)
	return a.Recorder
}

func (r *MoqUsual_PassByReference_recorder) Seq() *MoqUsual_PassByReference_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(true, "Seq", true) {
		return nil
	}
	return r
}

func (r *MoqUsual_PassByReference_recorder) NoSeq() *MoqUsual_PassByReference_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(false, "NoSeq", true) {
		return nil
	}
	return r
}

func (r *MoqUsual_PassByReference_recorder) ReturnResults(result1 *testmoqs.Results) *MoqUsual_PassByReference_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.ReturnResults(MoqUsual_PassByReference_results{
		Result1: result1,
	})
	return r
}

func (r *MoqUsual_PassByReference_recorder) AndDo(fn MoqUsual_PassByReference_doFn) *MoqUsual_PassByReference_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.AndDo(func(params MoqUsual_PassByReference_params) {
		fn(params.P)
	}, true) {
		return nil
	}
	return r
}

func (r *MoqUsual_PassByReference_recorder) DoReturnResults(fn MoqUsual_PassByReference_doReturnFn) *MoqUsual_PassByReference_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.DoReturnResults(func(params MoqUsual_PassByReference_params) *MoqUsual_PassByReference_results {
		result1 := fn(params.P)
		return &MoqUsual_PassByReference_results{
			Result1: result1,
		}
	})
	return r
}

func (r *MoqUsual_PassByReference_recorder) Repeat(repeaters ...moq.Repeater) *MoqUsual_PassByReference_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Repeat(repeaters, true) {
		return nil
	}
	return r
}

func (*MoqUsual_PassByReference_adaptor) PrettyParams(params MoqUsual_PassByReference_params) string {
	return fmt.Sprintf("PassByReference(%#v)", params.P)
}

func (a *MoqUsual_PassByReference_adaptor) ParamsKey(params MoqUsual_PassByReference_params, anyParams uint64) MoqUsual_PassByReference_paramsKey {
	a.Moq.Moq_PassByReference.Scene.T.Helper()
	pUsed, pUsedHash := impl.ParamKey(
		params.P, 1, a.Moq.Runtime.ParameterIndexing.PassByReference.P, anyParams)
	return MoqUsual_PassByReference_paramsKey{
		Params: struct{ P *testmoqs.Params }{
			P: pUsed,
		},
		Hashes: struct{ P hash.Hash }{
			P: pUsedHash,
		},
	}
}

func (m *MoqUsual_recorder) PassBySlice(p []testmoqs.Params) *MoqUsual_PassBySlice_recorder {
	return &MoqUsual_PassBySlice_recorder{
		Recorder: m.Moq.Moq_PassBySlice.OnCall(MoqUsual_PassBySlice_params{
			P: p,
		}),
	}
}

func (r *MoqUsual_PassBySlice_recorder) Any() *MoqUsual_PassBySlice_anyParams {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.IsAnyPermitted(true) {
		return nil
	}
	return &MoqUsual_PassBySlice_anyParams{Recorder: r}
}

func (a *MoqUsual_PassBySlice_anyParams) P() *MoqUsual_PassBySlice_recorder {
	a.Recorder.Recorder.AnyParam(1)
	return a.Recorder
}

func (r *MoqUsual_PassBySlice_recorder) Seq() *MoqUsual_PassBySlice_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(true, "Seq", true) {
		return nil
	}
	return r
}

func (r *MoqUsual_PassBySlice_recorder) NoSeq() *MoqUsual_PassBySlice_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(false, "NoSeq", true) {
		return nil
	}
	return r
}

func (r *MoqUsual_PassBySlice_recorder) ReturnResults(result1 []testmoqs.Results) *MoqUsual_PassBySlice_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.ReturnResults(MoqUsual_PassBySlice_results{
		Result1: result1,
	})
	return r
}

func (r *MoqUsual_PassBySlice_recorder) AndDo(fn MoqUsual_PassBySlice_doFn) *MoqUsual_PassBySlice_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.AndDo(func(params MoqUsual_PassBySlice_params) {
		fn(params.P)
	}, true) {
		return nil
	}
	return r
}

func (r *MoqUsual_PassBySlice_recorder) DoReturnResults(fn MoqUsual_PassBySlice_doReturnFn) *MoqUsual_PassBySlice_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.DoReturnResults(func(params MoqUsual_PassBySlice_params) *MoqUsual_PassBySlice_results {
		result1 := fn(params.P)
		return &MoqUsual_PassBySlice_results{
			Result1: result1,
		}
	})
	return r
}

func (r *MoqUsual_PassBySlice_recorder) Repeat(repeaters ...moq.Repeater) *MoqUsual_PassBySlice_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Repeat(repeaters, true) {
		return nil
	}
	return r
}

func (*MoqUsual_PassBySlice_adaptor) PrettyParams(params MoqUsual_PassBySlice_params) string {
	return fmt.Sprintf("PassBySlice(%#v)", params.P)
}

func (a *MoqUsual_PassBySlice_adaptor) ParamsKey(params MoqUsual_PassBySlice_params, anyParams uint64) MoqUsual_PassBySlice_paramsKey {
	a.Moq.Moq_PassBySlice.Scene.T.Helper()
	pUsedHash := impl.HashOnlyParamKey(a.Moq.Moq_PassBySlice.Scene.T,
		params.P, "p", 1, a.Moq.Runtime.ParameterIndexing.PassBySlice.P, anyParams)
	return MoqUsual_PassBySlice_paramsKey{
		Params: struct{}{},
		Hashes: struct{ P hash.Hash }{
			P: pUsedHash,
		},
	}
}

func (m *MoqUsual_recorder) PassByValue(p testmoqs.Params) *MoqUsual_PassByValue_recorder {
	return &MoqUsual_PassByValue_recorder{
		Recorder: m.Moq.Moq_PassByValue.OnCall(MoqUsual_PassByValue_params{
			P: p,
		}),
	}
}

func (r *MoqUsual_PassByValue_recorder) Any() *MoqUsual_PassByValue_anyParams {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.IsAnyPermitted(true) {
		return nil
	}
	return &MoqUsual_PassByValue_anyParams{Recorder: r}
}

func (a *MoqUsual_PassByValue_anyParams) P() *MoqUsual_PassByValue_recorder {
	a.Recorder.Recorder.AnyParam(1)
	return a.Recorder
}

func (r *MoqUsual_PassByValue_recorder) Seq() *MoqUsual_PassByValue_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(true, "Seq", true) {
		return nil
	}
	return r
}

func (r *MoqUsual_PassByValue_recorder) NoSeq() *MoqUsual_PassByValue_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(false, "NoSeq", true) {
		return nil
	}
	return r
}

func (r *MoqUsual_PassByValue_recorder) ReturnResults(result1 testmoqs.Results) *MoqUsual_PassByValue_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.ReturnResults(MoqUsual_PassByValue_results{
		Result1: result1,
	})
	return r
}

func (r *MoqUsual_PassByValue_recorder) AndDo(fn MoqUsual_PassByValue_doFn) *MoqUsual_PassByValue_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.AndDo(func(params MoqUsual_PassByValue_params) {
		fn(params.P)
	}, true) {
		return nil
	}
	return r
}

func (r *MoqUsual_PassByValue_recorder) DoReturnResults(fn MoqUsual_PassByValue_doReturnFn) *MoqUsual_PassByValue_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.DoReturnResults(func(params MoqUsual_PassByValue_params) *MoqUsual_PassByValue_results {
		result1 := fn(params.P)
		return &MoqUsual_PassByValue_results{
			Result1: result1,
		}
	})
	return r
}

func (r *MoqUsual_PassByValue_recorder) Repeat(repeaters ...moq.Repeater) *MoqUsual_PassByValue_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Repeat(repeaters, true) {
		return nil
	}
	return r
}

func (*MoqUsual_PassByValue_adaptor) PrettyParams(params MoqUsual_PassByValue_params) string {
	return fmt.Sprintf("PassByValue(%#v)", params.P)
}

func (a *MoqUsual_PassByValue_adaptor) ParamsKey(params MoqUsual_PassByValue_params, anyParams uint64) MoqUsual_PassByValue_paramsKey {
	a.Moq.Moq_PassByValue.Scene.T.Helper()
	pUsed, pUsedHash := impl.ParamKey(
		params.P, 1, a.Moq.Runtime.ParameterIndexing.PassByValue.P, anyParams)
	return MoqUsual_PassByValue_paramsKey{
		Params: struct{ P testmoqs.Params }{
			P: pUsed,
		},
		Hashes: struct{ P hash.Hash }{
			P: pUsedHash,
		},
	}
}

func (m *MoqUsual_recorder) InterfaceParam(w io.Writer) *MoqUsual_InterfaceParam_recorder {
	return &MoqUsual_InterfaceParam_recorder{
		Recorder: m.Moq.Moq_InterfaceParam.OnCall(MoqUsual_InterfaceParam_params{
			W: w,
		}),
	}
}

func (r *MoqUsual_InterfaceParam_recorder) Any() *MoqUsual_InterfaceParam_anyParams {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.IsAnyPermitted(true) {
		return nil
	}
	return &MoqUsual_InterfaceParam_anyParams{Recorder: r}
}

func (a *MoqUsual_InterfaceParam_anyParams) W() *MoqUsual_InterfaceParam_recorder {
	a.Recorder.Recorder.AnyParam(1)
	return a.Recorder
}

func (r *MoqUsual_InterfaceParam_recorder) Seq() *MoqUsual_InterfaceParam_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(true, "Seq", true) {
		return nil
	}
	return r
}

func (r *MoqUsual_InterfaceParam_recorder) NoSeq() *MoqUsual_InterfaceParam_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(false, "NoSeq", true) {
		return nil
	}
	return r
}

func (r *MoqUsual_InterfaceParam_recorder) ReturnResults(sResult string, err error) *MoqUsual_InterfaceParam_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.ReturnResults(MoqUsual_InterfaceParam_results{
		SResult: sResult,
		Err:     err,
	})
	return r
}

func (r *MoqUsual_InterfaceParam_recorder) AndDo(fn MoqUsual_InterfaceParam_doFn) *MoqUsual_InterfaceParam_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.AndDo(func(params MoqUsual_InterfaceParam_params) {
		fn(params.W)
	}, true) {
		return nil
	}
	return r
}

func (r *MoqUsual_InterfaceParam_recorder) DoReturnResults(fn MoqUsual_InterfaceParam_doReturnFn) *MoqUsual_InterfaceParam_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.DoReturnResults(func(params MoqUsual_InterfaceParam_params) *MoqUsual_InterfaceParam_results {
		sResult, err := fn(params.W)
		return &MoqUsual_InterfaceParam_results{
			SResult: sResult,
			Err:     err,
		}
	})
	return r
}

func (r *MoqUsual_InterfaceParam_recorder) Repeat(repeaters ...moq.Repeater) *MoqUsual_InterfaceParam_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Repeat(repeaters, true) {
		return nil
	}
	return r
}

func (*MoqUsual_InterfaceParam_adaptor) PrettyParams(params MoqUsual_InterfaceParam_params) string {
	return fmt.Sprintf("InterfaceParam(%#v)", params.W)
}

func (a *MoqUsual_InterfaceParam_adaptor) ParamsKey(params MoqUsual_InterfaceParam_params, anyParams uint64) MoqUsual_InterfaceParam_paramsKey {
	a.Moq.Moq_InterfaceParam.Scene.T.Helper()
	wUsed, wUsedHash := impl.ParamKey(
		params.W, 1, a.Moq.Runtime.ParameterIndexing.InterfaceParam.W, anyParams)
	return MoqUsual_InterfaceParam_paramsKey{
		Params: struct{ W io.Writer }{
			W: wUsed,
		},
		Hashes: struct{ W hash.Hash }{
			W: wUsedHash,
		},
	}
}

func (m *MoqUsual_recorder) InterfaceResult(sParam string, bParam bool) *MoqUsual_InterfaceResult_recorder {
	return &MoqUsual_InterfaceResult_recorder{
		Recorder: m.Moq.Moq_InterfaceResult.OnCall(MoqUsual_InterfaceResult_params{
			SParam: sParam,
			BParam: bParam,
		}),
	}
}

func (r *MoqUsual_InterfaceResult_recorder) Any() *MoqUsual_InterfaceResult_anyParams {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.IsAnyPermitted(true) {
		return nil
	}
	return &MoqUsual_InterfaceResult_anyParams{Recorder: r}
}

func (a *MoqUsual_InterfaceResult_anyParams) SParam() *MoqUsual_InterfaceResult_recorder {
	a.Recorder.Recorder.AnyParam(1)
	return a.Recorder
}

func (a *MoqUsual_InterfaceResult_anyParams) BParam() *MoqUsual_InterfaceResult_recorder {
	a.Recorder.Recorder.AnyParam(2)
	return a.Recorder
}

func (r *MoqUsual_InterfaceResult_recorder) Seq() *MoqUsual_InterfaceResult_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(true, "Seq", true) {
		return nil
	}
	return r
}

func (r *MoqUsual_InterfaceResult_recorder) NoSeq() *MoqUsual_InterfaceResult_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(false, "NoSeq", true) {
		return nil
	}
	return r
}

func (r *MoqUsual_InterfaceResult_recorder) ReturnResults(result1 io.Reader) *MoqUsual_InterfaceResult_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.ReturnResults(MoqUsual_InterfaceResult_results{
		Result1: result1,
	})
	return r
}

func (r *MoqUsual_InterfaceResult_recorder) AndDo(fn MoqUsual_InterfaceResult_doFn) *MoqUsual_InterfaceResult_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.AndDo(func(params MoqUsual_InterfaceResult_params) {
		fn(params.SParam, params.BParam)
	}, true) {
		return nil
	}
	return r
}

func (r *MoqUsual_InterfaceResult_recorder) DoReturnResults(fn MoqUsual_InterfaceResult_doReturnFn) *MoqUsual_InterfaceResult_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.DoReturnResults(func(params MoqUsual_InterfaceResult_params) *MoqUsual_InterfaceResult_results {
		result1 := fn(params.SParam, params.BParam)
		return &MoqUsual_InterfaceResult_results{
			Result1: result1,
		}
	})
	return r
}

func (r *MoqUsual_InterfaceResult_recorder) Repeat(repeaters ...moq.Repeater) *MoqUsual_InterfaceResult_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Repeat(repeaters, true) {
		return nil
	}
	return r
}

func (*MoqUsual_InterfaceResult_adaptor) PrettyParams(params MoqUsual_InterfaceResult_params) string {
	return fmt.Sprintf("InterfaceResult(%#v, %#v)", params.SParam, params.BParam)
}

func (a *MoqUsual_InterfaceResult_adaptor) ParamsKey(params MoqUsual_InterfaceResult_params, anyParams uint64) MoqUsual_InterfaceResult_paramsKey {
	a.Moq.Moq_InterfaceResult.Scene.T.Helper()
	sParamUsed, sParamUsedHash := impl.ParamKey(
		params.SParam, 1, a.Moq.Runtime.ParameterIndexing.InterfaceResult.SParam, anyParams)
	bParamUsed, bParamUsedHash := impl.ParamKey(
		params.BParam, 2, a.Moq.Runtime.ParameterIndexing.InterfaceResult.BParam, anyParams)
	return MoqUsual_InterfaceResult_paramsKey{
		Params: struct {
			SParam string
			BParam bool
		}{
			SParam: sParamUsed,
			BParam: bParamUsed,
		},
		Hashes: struct {
			SParam hash.Hash
			BParam hash.Hash
		}{
			SParam: sParamUsedHash,
			BParam: bParamUsedHash,
		},
	}
}

func (m *MoqUsual_recorder) FnParam(fn func()) *MoqUsual_FnParam_recorder {
	return &MoqUsual_FnParam_recorder{
		Recorder: m.Moq.Moq_FnParam.OnCall(MoqUsual_FnParam_params{
			Fn: fn,
		}),
	}
}

func (r *MoqUsual_FnParam_recorder) Any() *MoqUsual_FnParam_anyParams {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.IsAnyPermitted(true) {
		return nil
	}
	return &MoqUsual_FnParam_anyParams{Recorder: r}
}

func (a *MoqUsual_FnParam_anyParams) Fn() *MoqUsual_FnParam_recorder {
	a.Recorder.Recorder.AnyParam(1)
	return a.Recorder
}

func (r *MoqUsual_FnParam_recorder) Seq() *MoqUsual_FnParam_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(true, "Seq", true) {
		return nil
	}
	return r
}

func (r *MoqUsual_FnParam_recorder) NoSeq() *MoqUsual_FnParam_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(false, "NoSeq", true) {
		return nil
	}
	return r
}

func (r *MoqUsual_FnParam_recorder) ReturnResults() *MoqUsual_FnParam_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.ReturnResults(MoqUsual_FnParam_results{})
	return r
}

func (r *MoqUsual_FnParam_recorder) AndDo(fn MoqUsual_FnParam_doFn) *MoqUsual_FnParam_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.AndDo(func(params MoqUsual_FnParam_params) {
		fn(params.Fn)
	}, true) {
		return nil
	}
	return r
}

func (r *MoqUsual_FnParam_recorder) DoReturnResults(fn MoqUsual_FnParam_doReturnFn) *MoqUsual_FnParam_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.DoReturnResults(func(params MoqUsual_FnParam_params) *MoqUsual_FnParam_results {
		fn(params.Fn)
		return &MoqUsual_FnParam_results{}
	})
	return r
}

func (r *MoqUsual_FnParam_recorder) Repeat(repeaters ...moq.Repeater) *MoqUsual_FnParam_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Repeat(repeaters, true) {
		return nil
	}
	return r
}

func (*MoqUsual_FnParam_adaptor) PrettyParams(params MoqUsual_FnParam_params) string {
	return fmt.Sprintf("FnParam(%#v)", moq.FnString(params.Fn))
}

func (a *MoqUsual_FnParam_adaptor) ParamsKey(params MoqUsual_FnParam_params, anyParams uint64) MoqUsual_FnParam_paramsKey {
	a.Moq.Moq_FnParam.Scene.T.Helper()
	fnUsedHash := impl.HashOnlyParamKey(a.Moq.Moq_FnParam.Scene.T,
		params.Fn, "fn", 1, a.Moq.Runtime.ParameterIndexing.FnParam.Fn, anyParams)
	return MoqUsual_FnParam_paramsKey{
		Params: struct{}{},
		Hashes: struct{ Fn hash.Hash }{
			Fn: fnUsedHash,
		},
	}
}

func (m *MoqUsual_recorder) Other(param1 other.Params) *MoqUsual_Other_recorder {
	return &MoqUsual_Other_recorder{
		Recorder: m.Moq.Moq_Other.OnCall(MoqUsual_Other_params{
			Param1: param1,
		}),
	}
}

func (r *MoqUsual_Other_recorder) Any() *MoqUsual_Other_anyParams {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.IsAnyPermitted(true) {
		return nil
	}
	return &MoqUsual_Other_anyParams{Recorder: r}
}

func (a *MoqUsual_Other_anyParams) Param1() *MoqUsual_Other_recorder {
	a.Recorder.Recorder.AnyParam(1)
	return a.Recorder
}

func (r *MoqUsual_Other_recorder) Seq() *MoqUsual_Other_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(true, "Seq", true) {
		return nil
	}
	return r
}

func (r *MoqUsual_Other_recorder) NoSeq() *MoqUsual_Other_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(false, "NoSeq", true) {
		return nil
	}
	return r
}

func (r *MoqUsual_Other_recorder) ReturnResults(result1 other.Results) *MoqUsual_Other_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.ReturnResults(MoqUsual_Other_results{
		Result1: result1,
	})
	return r
}

func (r *MoqUsual_Other_recorder) AndDo(fn MoqUsual_Other_doFn) *MoqUsual_Other_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.AndDo(func(params MoqUsual_Other_params) {
		fn(params.Param1)
	}, true) {
		return nil
	}
	return r
}

func (r *MoqUsual_Other_recorder) DoReturnResults(fn MoqUsual_Other_doReturnFn) *MoqUsual_Other_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.DoReturnResults(func(params MoqUsual_Other_params) *MoqUsual_Other_results {
		result1 := fn(params.Param1)
		return &MoqUsual_Other_results{
			Result1: result1,
		}
	})
	return r
}

func (r *MoqUsual_Other_recorder) Repeat(repeaters ...moq.Repeater) *MoqUsual_Other_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Repeat(repeaters, true) {
		return nil
	}
	return r
}

func (*MoqUsual_Other_adaptor) PrettyParams(params MoqUsual_Other_params) string {
	return fmt.Sprintf("Other(%#v)", params.Param1)
}

func (a *MoqUsual_Other_adaptor) ParamsKey(params MoqUsual_Other_params, anyParams uint64) MoqUsual_Other_paramsKey {
	a.Moq.Moq_Other.Scene.T.Helper()
	param1Used, param1UsedHash := impl.ParamKey(
		params.Param1, 1, a.Moq.Runtime.ParameterIndexing.Other.Param1, anyParams)
	return MoqUsual_Other_paramsKey{
		Params: struct{ Param1 other.Params }{
			Param1: param1Used,
		},
		Hashes: struct{ Param1 hash.Hash }{
			Param1: param1UsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *MoqUsual) Reset() {
	m.Moq_Usual.Reset()
	m.Moq_NoNames.Reset()
	m.Moq_NoResults.Reset()
	m.Moq_NoParams.Reset()
	m.Moq_Nothing.Reset()
	m.Moq_Variadic.Reset()
	m.Moq_RepeatedIds.Reset()
	m.Moq_Times.Reset()
	m.Moq_DifficultParamNames.Reset()
	m.Moq_DifficultResultNames.Reset()
	m.Moq_PassByArray.Reset()
	m.Moq_PassByChan.Reset()
	m.Moq_PassByEllipsis.Reset()
	m.Moq_PassByMap.Reset()
	m.Moq_PassByReference.Reset()
	m.Moq_PassBySlice.Reset()
	m.Moq_PassByValue.Reset()
	m.Moq_InterfaceParam.Reset()
	m.Moq_InterfaceResult.Reset()
	m.Moq_FnParam.Reset()
	m.Moq_Other.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqUsual) AssertExpectationsMet() {
	m.Moq_Usual.Scene.T.Helper()
	m.Moq_Usual.AssertExpectationsMet()
	m.Moq_NoNames.AssertExpectationsMet()
	m.Moq_NoResults.AssertExpectationsMet()
	m.Moq_NoParams.AssertExpectationsMet()
	m.Moq_Nothing.AssertExpectationsMet()
	m.Moq_Variadic.AssertExpectationsMet()
	m.Moq_RepeatedIds.AssertExpectationsMet()
	m.Moq_Times.AssertExpectationsMet()
	m.Moq_DifficultParamNames.AssertExpectationsMet()
	m.Moq_DifficultResultNames.AssertExpectationsMet()
	m.Moq_PassByArray.AssertExpectationsMet()
	m.Moq_PassByChan.AssertExpectationsMet()
	m.Moq_PassByEllipsis.AssertExpectationsMet()
	m.Moq_PassByMap.AssertExpectationsMet()
	m.Moq_PassByReference.AssertExpectationsMet()
	m.Moq_PassBySlice.AssertExpectationsMet()
	m.Moq_PassByValue.AssertExpectationsMet()
	m.Moq_InterfaceParam.AssertExpectationsMet()
	m.Moq_InterfaceResult.AssertExpectationsMet()
	m.Moq_FnParam.AssertExpectationsMet()
	m.Moq_Other.AssertExpectationsMet()
}

// The following type assertion assures that testmoqs.GenericParams is mocked
// completely
var _ testmoqs.GenericParams[any, any] = (*MoqGenericParams_mock[any, any])(nil)

// MoqGenericParams holds the state of a moq of the GenericParams type
type MoqGenericParams[S, B any] struct {
	Moq *MoqGenericParams_mock[S, B]

	Moq_Usual *impl.Moq[
		*MoqGenericParams_Usual_adaptor[S, B],
		MoqGenericParams_Usual_params[S, B],
		MoqGenericParams_Usual_paramsKey[S, B],
		MoqGenericParams_Usual_results[S, B]]

	Runtime MoqGenericParams_runtime
}

// MoqGenericParams_mock isolates the mock interface of the GenericParams type
type MoqGenericParams_mock[S, B any] struct {
	Moq *MoqGenericParams[S, B]
}

// MoqGenericParams_recorder isolates the recorder interface of the
// GenericParams type
type MoqGenericParams_recorder[S, B any] struct {
	Moq *MoqGenericParams[S, B]
}

// MoqGenericParams_runtime holds runtime configuration for the GenericParams
// type
type MoqGenericParams_runtime struct {
	ParameterIndexing struct {
		Usual MoqGenericParams_Usual_paramIndexing
	}
}

// MoqGenericParams_Usual_adaptor adapts MoqGenericParams as needed by the
// runtime
type MoqGenericParams_Usual_adaptor[S, B any] struct {
	Moq *MoqGenericParams[S, B]
}

// MoqGenericParams_Usual_params holds the params of the GenericParams type
type MoqGenericParams_Usual_params[S, B any] struct {
	Param1 S
	Param2 B
}

// MoqGenericParams_Usual_paramsKey holds the map key params of the
// GenericParams type
type MoqGenericParams_Usual_paramsKey[S, B any] struct {
	Params struct{}
	Hashes struct {
		Param1 hash.Hash
		Param2 hash.Hash
	}
}

// MoqGenericParams_Usual_results holds the results of the GenericParams type
type MoqGenericParams_Usual_results[S, B any] struct {
	Result1 string
	Result2 error
}

// MoqGenericParams_Usual_paramIndexing holds the parameter indexing runtime
// configuration for the GenericParams type
type MoqGenericParams_Usual_paramIndexing struct {
	Param1 moq.ParamIndexing
	Param2 moq.ParamIndexing
}

// MoqGenericParams_Usual_doFn defines the type of function needed when calling
// AndDo for the GenericParams type
type MoqGenericParams_Usual_doFn[S, B any] func(S, B)

// MoqGenericParams_Usual_doReturnFn defines the type of function needed when
// calling DoReturnResults for the GenericParams type
type MoqGenericParams_Usual_doReturnFn[S, B any] func(S, B) (string, error)

// MoqGenericParams_Usual_recorder routes recorded function calls to the
// MoqGenericParams moq
type MoqGenericParams_Usual_recorder[S, B any] struct {
	Recorder *impl.Recorder[
		*MoqGenericParams_Usual_adaptor[S, B],
		MoqGenericParams_Usual_params[S, B],
		MoqGenericParams_Usual_paramsKey[S, B],
		MoqGenericParams_Usual_results[S, B]]
}

// MoqGenericParams_Usual_anyParams isolates the any params functions of the
// GenericParams type
type MoqGenericParams_Usual_anyParams[S, B any] struct {
	Recorder *MoqGenericParams_Usual_recorder[S, B]
}

// NewMoqGenericParams creates a new moq of the GenericParams type
func NewMoqGenericParams[S, B any](scene *moq.Scene, config *moq.Config) *MoqGenericParams[S, B] {
	adaptor1 := &MoqGenericParams_Usual_adaptor[S, B]{}
	m := &MoqGenericParams[S, B]{
		Moq: &MoqGenericParams_mock[S, B]{},

		Moq_Usual: impl.NewMoq[
			*MoqGenericParams_Usual_adaptor[S, B],
			MoqGenericParams_Usual_params[S, B],
			MoqGenericParams_Usual_paramsKey[S, B],
			MoqGenericParams_Usual_results[S, B]](scene, adaptor1, config),

		Runtime: MoqGenericParams_runtime{ParameterIndexing: struct {
			Usual MoqGenericParams_Usual_paramIndexing
		}{
			Usual: MoqGenericParams_Usual_paramIndexing{
				Param1: moq.ParamIndexByHash,
				Param2: moq.ParamIndexByHash,
			},
		}},
	}
	m.Moq.Moq = m

	adaptor1.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the mock implementation of the GenericParams type
func (m *MoqGenericParams[S, B]) Mock() *MoqGenericParams_mock[S, B] { return m.Moq }

func (m *MoqGenericParams_mock[S, B]) Usual(param1 S, param2 B) (string, error) {
	m.Moq.Moq_Usual.Scene.T.Helper()
	params := MoqGenericParams_Usual_params[S, B]{
		Param1: param1,
		Param2: param2,
	}

	var result1 string
	var result2 error
	if result := m.Moq.Moq_Usual.Function(params); result != nil {
		result1 = result.Result1
		result2 = result.Result2
	}
	return result1, result2
}

// OnCall returns the recorder implementation of the GenericParams type
func (m *MoqGenericParams[S, B]) OnCall() *MoqGenericParams_recorder[S, B] {
	return &MoqGenericParams_recorder[S, B]{
		Moq: m,
	}
}

func (m *MoqGenericParams_recorder[S, B]) Usual(param1 S, param2 B) *MoqGenericParams_Usual_recorder[S, B] {
	return &MoqGenericParams_Usual_recorder[S, B]{
		Recorder: m.Moq.Moq_Usual.OnCall(MoqGenericParams_Usual_params[S, B]{
			Param1: param1,
			Param2: param2,
		}),
	}
}

func (r *MoqGenericParams_Usual_recorder[S, B]) Any() *MoqGenericParams_Usual_anyParams[S, B] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.IsAnyPermitted(true) {
		return nil
	}
	return &MoqGenericParams_Usual_anyParams[S, B]{Recorder: r}
}

func (a *MoqGenericParams_Usual_anyParams[S, B]) Param1() *MoqGenericParams_Usual_recorder[S, B] {
	a.Recorder.Recorder.AnyParam(1)
	return a.Recorder
}

func (a *MoqGenericParams_Usual_anyParams[S, B]) Param2() *MoqGenericParams_Usual_recorder[S, B] {
	a.Recorder.Recorder.AnyParam(2)
	return a.Recorder
}

func (r *MoqGenericParams_Usual_recorder[S, B]) Seq() *MoqGenericParams_Usual_recorder[S, B] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(true, "Seq", true) {
		return nil
	}
	return r
}

func (r *MoqGenericParams_Usual_recorder[S, B]) NoSeq() *MoqGenericParams_Usual_recorder[S, B] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(false, "NoSeq", true) {
		return nil
	}
	return r
}

func (r *MoqGenericParams_Usual_recorder[S, B]) ReturnResults(result1 string, result2 error) *MoqGenericParams_Usual_recorder[S, B] {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.ReturnResults(MoqGenericParams_Usual_results[S, B]{
		Result1: result1,
		Result2: result2,
	})
	return r
}

func (r *MoqGenericParams_Usual_recorder[S, B]) AndDo(fn MoqGenericParams_Usual_doFn[S, B]) *MoqGenericParams_Usual_recorder[S, B] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.AndDo(func(params MoqGenericParams_Usual_params[S, B]) {
		fn(params.Param1, params.Param2)
	}, true) {
		return nil
	}
	return r
}

func (r *MoqGenericParams_Usual_recorder[S, B]) DoReturnResults(fn MoqGenericParams_Usual_doReturnFn[S, B]) *MoqGenericParams_Usual_recorder[S, B] {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.DoReturnResults(func(params MoqGenericParams_Usual_params[S, B]) *MoqGenericParams_Usual_results[S, B] {
		result1, result2 := fn(params.Param1, params.Param2)
		return &MoqGenericParams_Usual_results[S, B]{
			Result1: result1,
			Result2: result2,
		}
	})
	return r
}

func (r *MoqGenericParams_Usual_recorder[S, B]) Repeat(repeaters ...moq.Repeater) *MoqGenericParams_Usual_recorder[S, B] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Repeat(repeaters, true) {
		return nil
	}
	return r
}

func (*MoqGenericParams_Usual_adaptor[S, B]) PrettyParams(params MoqGenericParams_Usual_params[S, B]) string {
	return fmt.Sprintf("Usual(%#v, %#v)", params.Param1, params.Param2)
}

func (a *MoqGenericParams_Usual_adaptor[S, B]) ParamsKey(params MoqGenericParams_Usual_params[S, B], anyParams uint64) MoqGenericParams_Usual_paramsKey[S, B] {
	a.Moq.Moq_Usual.Scene.T.Helper()
	param1UsedHash := impl.HashOnlyParamKey(a.Moq.Moq_Usual.Scene.T,
		params.Param1, "param1", 1, a.Moq.Runtime.ParameterIndexing.Usual.Param1, anyParams)
	param2UsedHash := impl.HashOnlyParamKey(a.Moq.Moq_Usual.Scene.T,
		params.Param2, "param2", 2, a.Moq.Runtime.ParameterIndexing.Usual.Param2, anyParams)
	return MoqGenericParams_Usual_paramsKey[S, B]{
		Params: struct{}{},
		Hashes: struct {
			Param1 hash.Hash
			Param2 hash.Hash
		}{
			Param1: param1UsedHash,
			Param2: param2UsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *MoqGenericParams[S, B]) Reset() {
	m.Moq_Usual.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqGenericParams[S, B]) AssertExpectationsMet() {
	m.Moq_Usual.Scene.T.Helper()
	m.Moq_Usual.AssertExpectationsMet()
}

// The following type assertion assures that testmoqs.PartialGenericParams is
// mocked completely
var _ testmoqs.PartialGenericParams[any] = (*MoqPartialGenericParams_mock[any])(nil)

// MoqPartialGenericParams holds the state of a moq of the PartialGenericParams
// type
type MoqPartialGenericParams[S any] struct {
	Moq *MoqPartialGenericParams_mock[S]

	Moq_Usual *impl.Moq[
		*MoqPartialGenericParams_Usual_adaptor[S],
		MoqPartialGenericParams_Usual_params[S],
		MoqPartialGenericParams_Usual_paramsKey[S],
		MoqPartialGenericParams_Usual_results[S]]

	Runtime MoqPartialGenericParams_runtime
}

// MoqPartialGenericParams_mock isolates the mock interface of the
// PartialGenericParams type
type MoqPartialGenericParams_mock[S any] struct {
	Moq *MoqPartialGenericParams[S]
}

// MoqPartialGenericParams_recorder isolates the recorder interface of the
// PartialGenericParams type
type MoqPartialGenericParams_recorder[S any] struct {
	Moq *MoqPartialGenericParams[S]
}

// MoqPartialGenericParams_runtime holds runtime configuration for the
// PartialGenericParams type
type MoqPartialGenericParams_runtime struct {
	ParameterIndexing struct {
		Usual MoqPartialGenericParams_Usual_paramIndexing
	}
}

// MoqPartialGenericParams_Usual_adaptor adapts MoqPartialGenericParams as
// needed by the runtime
type MoqPartialGenericParams_Usual_adaptor[S any] struct {
	Moq *MoqPartialGenericParams[S]
}

// MoqPartialGenericParams_Usual_params holds the params of the
// PartialGenericParams type
type MoqPartialGenericParams_Usual_params[S any] struct {
	Param1 S
	Param2 bool
}

// MoqPartialGenericParams_Usual_paramsKey holds the map key params of the
// PartialGenericParams type
type MoqPartialGenericParams_Usual_paramsKey[S any] struct {
	Params struct{ Param2 bool }
	Hashes struct {
		Param1 hash.Hash
		Param2 hash.Hash
	}
}

// MoqPartialGenericParams_Usual_results holds the results of the
// PartialGenericParams type
type MoqPartialGenericParams_Usual_results[S any] struct {
	Result1 string
	Result2 error
}

// MoqPartialGenericParams_Usual_paramIndexing holds the parameter indexing
// runtime configuration for the PartialGenericParams type
type MoqPartialGenericParams_Usual_paramIndexing struct {
	Param1 moq.ParamIndexing
	Param2 moq.ParamIndexing
}

// MoqPartialGenericParams_Usual_doFn defines the type of function needed when
// calling AndDo for the PartialGenericParams type
type MoqPartialGenericParams_Usual_doFn[S any] func(S, bool)

// MoqPartialGenericParams_Usual_doReturnFn defines the type of function needed
// when calling DoReturnResults for the PartialGenericParams type
type MoqPartialGenericParams_Usual_doReturnFn[S any] func(S, bool) (string, error)

// MoqPartialGenericParams_Usual_recorder routes recorded function calls to the
// MoqPartialGenericParams moq
type MoqPartialGenericParams_Usual_recorder[S any] struct {
	Recorder *impl.Recorder[
		*MoqPartialGenericParams_Usual_adaptor[S],
		MoqPartialGenericParams_Usual_params[S],
		MoqPartialGenericParams_Usual_paramsKey[S],
		MoqPartialGenericParams_Usual_results[S]]
}

// MoqPartialGenericParams_Usual_anyParams isolates the any params functions of
// the PartialGenericParams type
type MoqPartialGenericParams_Usual_anyParams[S any] struct {
	Recorder *MoqPartialGenericParams_Usual_recorder[S]
}

// NewMoqPartialGenericParams creates a new moq of the PartialGenericParams
// type
func NewMoqPartialGenericParams[S any](scene *moq.Scene, config *moq.Config) *MoqPartialGenericParams[S] {
	adaptor1 := &MoqPartialGenericParams_Usual_adaptor[S]{}
	m := &MoqPartialGenericParams[S]{
		Moq: &MoqPartialGenericParams_mock[S]{},

		Moq_Usual: impl.NewMoq[
			*MoqPartialGenericParams_Usual_adaptor[S],
			MoqPartialGenericParams_Usual_params[S],
			MoqPartialGenericParams_Usual_paramsKey[S],
			MoqPartialGenericParams_Usual_results[S]](scene, adaptor1, config),

		Runtime: MoqPartialGenericParams_runtime{ParameterIndexing: struct {
			Usual MoqPartialGenericParams_Usual_paramIndexing
		}{
			Usual: MoqPartialGenericParams_Usual_paramIndexing{
				Param1: moq.ParamIndexByHash,
				Param2: moq.ParamIndexByValue,
			},
		}},
	}
	m.Moq.Moq = m

	adaptor1.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the mock implementation of the PartialGenericParams type
func (m *MoqPartialGenericParams[S]) Mock() *MoqPartialGenericParams_mock[S] { return m.Moq }

func (m *MoqPartialGenericParams_mock[S]) Usual(param1 S, param2 bool) (string, error) {
	m.Moq.Moq_Usual.Scene.T.Helper()
	params := MoqPartialGenericParams_Usual_params[S]{
		Param1: param1,
		Param2: param2,
	}

	var result1 string
	var result2 error
	if result := m.Moq.Moq_Usual.Function(params); result != nil {
		result1 = result.Result1
		result2 = result.Result2
	}
	return result1, result2
}

// OnCall returns the recorder implementation of the PartialGenericParams type
func (m *MoqPartialGenericParams[S]) OnCall() *MoqPartialGenericParams_recorder[S] {
	return &MoqPartialGenericParams_recorder[S]{
		Moq: m,
	}
}

func (m *MoqPartialGenericParams_recorder[S]) Usual(param1 S, param2 bool) *MoqPartialGenericParams_Usual_recorder[S] {
	return &MoqPartialGenericParams_Usual_recorder[S]{
		Recorder: m.Moq.Moq_Usual.OnCall(MoqPartialGenericParams_Usual_params[S]{
			Param1: param1,
			Param2: param2,
		}),
	}
}

func (r *MoqPartialGenericParams_Usual_recorder[S]) Any() *MoqPartialGenericParams_Usual_anyParams[S] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.IsAnyPermitted(true) {
		return nil
	}
	return &MoqPartialGenericParams_Usual_anyParams[S]{Recorder: r}
}

func (a *MoqPartialGenericParams_Usual_anyParams[S]) Param1() *MoqPartialGenericParams_Usual_recorder[S] {
	a.Recorder.Recorder.AnyParam(1)
	return a.Recorder
}

func (a *MoqPartialGenericParams_Usual_anyParams[S]) Param2() *MoqPartialGenericParams_Usual_recorder[S] {
	a.Recorder.Recorder.AnyParam(2)
	return a.Recorder
}

func (r *MoqPartialGenericParams_Usual_recorder[S]) Seq() *MoqPartialGenericParams_Usual_recorder[S] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(true, "Seq", true) {
		return nil
	}
	return r
}

func (r *MoqPartialGenericParams_Usual_recorder[S]) NoSeq() *MoqPartialGenericParams_Usual_recorder[S] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(false, "NoSeq", true) {
		return nil
	}
	return r
}

func (r *MoqPartialGenericParams_Usual_recorder[S]) ReturnResults(result1 string, result2 error) *MoqPartialGenericParams_Usual_recorder[S] {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.ReturnResults(MoqPartialGenericParams_Usual_results[S]{
		Result1: result1,
		Result2: result2,
	})
	return r
}

func (r *MoqPartialGenericParams_Usual_recorder[S]) AndDo(fn MoqPartialGenericParams_Usual_doFn[S]) *MoqPartialGenericParams_Usual_recorder[S] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.AndDo(func(params MoqPartialGenericParams_Usual_params[S]) {
		fn(params.Param1, params.Param2)
	}, true) {
		return nil
	}
	return r
}

func (r *MoqPartialGenericParams_Usual_recorder[S]) DoReturnResults(fn MoqPartialGenericParams_Usual_doReturnFn[S]) *MoqPartialGenericParams_Usual_recorder[S] {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.DoReturnResults(func(params MoqPartialGenericParams_Usual_params[S]) *MoqPartialGenericParams_Usual_results[S] {
		result1, result2 := fn(params.Param1, params.Param2)
		return &MoqPartialGenericParams_Usual_results[S]{
			Result1: result1,
			Result2: result2,
		}
	})
	return r
}

func (r *MoqPartialGenericParams_Usual_recorder[S]) Repeat(repeaters ...moq.Repeater) *MoqPartialGenericParams_Usual_recorder[S] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Repeat(repeaters, true) {
		return nil
	}
	return r
}

func (*MoqPartialGenericParams_Usual_adaptor[S]) PrettyParams(params MoqPartialGenericParams_Usual_params[S]) string {
	return fmt.Sprintf("Usual(%#v, %#v)", params.Param1, params.Param2)
}

func (a *MoqPartialGenericParams_Usual_adaptor[S]) ParamsKey(params MoqPartialGenericParams_Usual_params[S], anyParams uint64) MoqPartialGenericParams_Usual_paramsKey[S] {
	a.Moq.Moq_Usual.Scene.T.Helper()
	param1UsedHash := impl.HashOnlyParamKey(a.Moq.Moq_Usual.Scene.T,
		params.Param1, "param1", 1, a.Moq.Runtime.ParameterIndexing.Usual.Param1, anyParams)
	param2Used, param2UsedHash := impl.ParamKey(
		params.Param2, 2, a.Moq.Runtime.ParameterIndexing.Usual.Param2, anyParams)
	return MoqPartialGenericParams_Usual_paramsKey[S]{
		Params: struct{ Param2 bool }{
			Param2: param2Used,
		},
		Hashes: struct {
			Param1 hash.Hash
			Param2 hash.Hash
		}{
			Param1: param1UsedHash,
			Param2: param2UsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *MoqPartialGenericParams[S]) Reset() {
	m.Moq_Usual.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqPartialGenericParams[S]) AssertExpectationsMet() {
	m.Moq_Usual.Scene.T.Helper()
	m.Moq_Usual.AssertExpectationsMet()
}

// The following type assertion assures that testmoqs.GenericResults is mocked
// completely
var _ testmoqs.GenericResults[string, error] = (*MoqGenericResults_mock[string, error])(nil)

// MoqGenericResults holds the state of a moq of the GenericResults type
type MoqGenericResults[S ~string, E error] struct {
	Moq *MoqGenericResults_mock[S, E]

	Moq_Usual *impl.Moq[
		*MoqGenericResults_Usual_adaptor[S, E],
		MoqGenericResults_Usual_params[S, E],
		MoqGenericResults_Usual_paramsKey[S, E],
		MoqGenericResults_Usual_results[S, E]]

	Runtime MoqGenericResults_runtime
}

// MoqGenericResults_mock isolates the mock interface of the GenericResults
// type
type MoqGenericResults_mock[S ~string, E error] struct {
	Moq *MoqGenericResults[S, E]
}

// MoqGenericResults_recorder isolates the recorder interface of the
// GenericResults type
type MoqGenericResults_recorder[S ~string, E error] struct {
	Moq *MoqGenericResults[S, E]
}

// MoqGenericResults_runtime holds runtime configuration for the GenericResults
// type
type MoqGenericResults_runtime struct {
	ParameterIndexing struct {
		Usual MoqGenericResults_Usual_paramIndexing
	}
}

// MoqGenericResults_Usual_adaptor adapts MoqGenericResults as needed by the
// runtime
type MoqGenericResults_Usual_adaptor[S ~string, E error] struct {
	Moq *MoqGenericResults[S, E]
}

// MoqGenericResults_Usual_params holds the params of the GenericResults type
type MoqGenericResults_Usual_params[S ~string, E error] struct {
	Param1 string
	Param2 bool
}

// MoqGenericResults_Usual_paramsKey holds the map key params of the
// GenericResults type
type MoqGenericResults_Usual_paramsKey[S ~string, E error] struct {
	Params struct {
		Param1 string
		Param2 bool
	}
	Hashes struct {
		Param1 hash.Hash
		Param2 hash.Hash
	}
}

// MoqGenericResults_Usual_results holds the results of the GenericResults type
type MoqGenericResults_Usual_results[S ~string, E error] struct {
	Result1 S
	Result2 E
}

// MoqGenericResults_Usual_paramIndexing holds the parameter indexing runtime
// configuration for the GenericResults type
type MoqGenericResults_Usual_paramIndexing struct {
	Param1 moq.ParamIndexing
	Param2 moq.ParamIndexing
}

// MoqGenericResults_Usual_doFn defines the type of function needed when
// calling AndDo for the GenericResults type
type MoqGenericResults_Usual_doFn[S ~string, E error] func(string, bool)

// MoqGenericResults_Usual_doReturnFn defines the type of function needed when
// calling DoReturnResults for the GenericResults type
type MoqGenericResults_Usual_doReturnFn[S ~string, E error] func(string, bool) (S, E)

// MoqGenericResults_Usual_recorder routes recorded function calls to the
// MoqGenericResults moq
type MoqGenericResults_Usual_recorder[S ~string, E error] struct {
	Recorder *impl.Recorder[
		*MoqGenericResults_Usual_adaptor[S, E],
		MoqGenericResults_Usual_params[S, E],
		MoqGenericResults_Usual_paramsKey[S, E],
		MoqGenericResults_Usual_results[S, E]]
}

// MoqGenericResults_Usual_anyParams isolates the any params functions of the
// GenericResults type
type MoqGenericResults_Usual_anyParams[S ~string, E error] struct {
	Recorder *MoqGenericResults_Usual_recorder[S, E]
}

// NewMoqGenericResults creates a new moq of the GenericResults type
func NewMoqGenericResults[S ~string, E error](scene *moq.Scene, config *moq.Config) *MoqGenericResults[S, E] {
	adaptor1 := &MoqGenericResults_Usual_adaptor[S, E]{}
	m := &MoqGenericResults[S, E]{
		Moq: &MoqGenericResults_mock[S, E]{},

		Moq_Usual: impl.NewMoq[
			*MoqGenericResults_Usual_adaptor[S, E],
			MoqGenericResults_Usual_params[S, E],
			MoqGenericResults_Usual_paramsKey[S, E],
			MoqGenericResults_Usual_results[S, E]](scene, adaptor1, config),

		Runtime: MoqGenericResults_runtime{ParameterIndexing: struct {
			Usual MoqGenericResults_Usual_paramIndexing
		}{
			Usual: MoqGenericResults_Usual_paramIndexing{
				Param1: moq.ParamIndexByValue,
				Param2: moq.ParamIndexByValue,
			},
		}},
	}
	m.Moq.Moq = m

	adaptor1.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the mock implementation of the GenericResults type
func (m *MoqGenericResults[S, E]) Mock() *MoqGenericResults_mock[S, E] { return m.Moq }

func (m *MoqGenericResults_mock[S, E]) Usual(param1 string, param2 bool) (S, E) {
	m.Moq.Moq_Usual.Scene.T.Helper()
	params := MoqGenericResults_Usual_params[S, E]{
		Param1: param1,
		Param2: param2,
	}

	var result1 S
	var result2 E
	if result := m.Moq.Moq_Usual.Function(params); result != nil {
		result1 = result.Result1
		result2 = result.Result2
	}
	return result1, result2
}

// OnCall returns the recorder implementation of the GenericResults type
func (m *MoqGenericResults[S, E]) OnCall() *MoqGenericResults_recorder[S, E] {
	return &MoqGenericResults_recorder[S, E]{
		Moq: m,
	}
}

func (m *MoqGenericResults_recorder[S, E]) Usual(param1 string, param2 bool) *MoqGenericResults_Usual_recorder[S, E] {
	return &MoqGenericResults_Usual_recorder[S, E]{
		Recorder: m.Moq.Moq_Usual.OnCall(MoqGenericResults_Usual_params[S, E]{
			Param1: param1,
			Param2: param2,
		}),
	}
}

func (r *MoqGenericResults_Usual_recorder[S, E]) Any() *MoqGenericResults_Usual_anyParams[S, E] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.IsAnyPermitted(true) {
		return nil
	}
	return &MoqGenericResults_Usual_anyParams[S, E]{Recorder: r}
}

func (a *MoqGenericResults_Usual_anyParams[S, E]) Param1() *MoqGenericResults_Usual_recorder[S, E] {
	a.Recorder.Recorder.AnyParam(1)
	return a.Recorder
}

func (a *MoqGenericResults_Usual_anyParams[S, E]) Param2() *MoqGenericResults_Usual_recorder[S, E] {
	a.Recorder.Recorder.AnyParam(2)
	return a.Recorder
}

func (r *MoqGenericResults_Usual_recorder[S, E]) Seq() *MoqGenericResults_Usual_recorder[S, E] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(true, "Seq", true) {
		return nil
	}
	return r
}

func (r *MoqGenericResults_Usual_recorder[S, E]) NoSeq() *MoqGenericResults_Usual_recorder[S, E] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(false, "NoSeq", true) {
		return nil
	}
	return r
}

func (r *MoqGenericResults_Usual_recorder[S, E]) ReturnResults(result1 S, result2 E) *MoqGenericResults_Usual_recorder[S, E] {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.ReturnResults(MoqGenericResults_Usual_results[S, E]{
		Result1: result1,
		Result2: result2,
	})
	return r
}

func (r *MoqGenericResults_Usual_recorder[S, E]) AndDo(fn MoqGenericResults_Usual_doFn[S, E]) *MoqGenericResults_Usual_recorder[S, E] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.AndDo(func(params MoqGenericResults_Usual_params[S, E]) {
		fn(params.Param1, params.Param2)
	}, true) {
		return nil
	}
	return r
}

func (r *MoqGenericResults_Usual_recorder[S, E]) DoReturnResults(fn MoqGenericResults_Usual_doReturnFn[S, E]) *MoqGenericResults_Usual_recorder[S, E] {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.DoReturnResults(func(params MoqGenericResults_Usual_params[S, E]) *MoqGenericResults_Usual_results[S, E] {
		result1, result2 := fn(params.Param1, params.Param2)
		return &MoqGenericResults_Usual_results[S, E]{
			Result1: result1,
			Result2: result2,
		}
	})
	return r
}

func (r *MoqGenericResults_Usual_recorder[S, E]) Repeat(repeaters ...moq.Repeater) *MoqGenericResults_Usual_recorder[S, E] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Repeat(repeaters, true) {
		return nil
	}
	return r
}

func (*MoqGenericResults_Usual_adaptor[S, E]) PrettyParams(params MoqGenericResults_Usual_params[S, E]) string {
	return fmt.Sprintf("Usual(%#v, %#v)", params.Param1, params.Param2)
}

func (a *MoqGenericResults_Usual_adaptor[S, E]) ParamsKey(params MoqGenericResults_Usual_params[S, E], anyParams uint64) MoqGenericResults_Usual_paramsKey[S, E] {
	a.Moq.Moq_Usual.Scene.T.Helper()
	param1Used, param1UsedHash := impl.ParamKey(
		params.Param1, 1, a.Moq.Runtime.ParameterIndexing.Usual.Param1, anyParams)
	param2Used, param2UsedHash := impl.ParamKey(
		params.Param2, 2, a.Moq.Runtime.ParameterIndexing.Usual.Param2, anyParams)
	return MoqGenericResults_Usual_paramsKey[S, E]{
		Params: struct {
			Param1 string
			Param2 bool
		}{
			Param1: param1Used,
			Param2: param2Used,
		},
		Hashes: struct {
			Param1 hash.Hash
			Param2 hash.Hash
		}{
			Param1: param1UsedHash,
			Param2: param2UsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *MoqGenericResults[S, E]) Reset() {
	m.Moq_Usual.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqGenericResults[S, E]) AssertExpectationsMet() {
	m.Moq_Usual.Scene.T.Helper()
	m.Moq_Usual.AssertExpectationsMet()
}

// The following type assertion assures that testmoqs.PartialGenericResults is
// mocked completely
var _ testmoqs.PartialGenericResults[string] = (*MoqPartialGenericResults_mock[string])(nil)

// MoqPartialGenericResults holds the state of a moq of the
// PartialGenericResults type
type MoqPartialGenericResults[S ~string] struct {
	Moq *MoqPartialGenericResults_mock[S]

	Moq_Usual *impl.Moq[
		*MoqPartialGenericResults_Usual_adaptor[S],
		MoqPartialGenericResults_Usual_params[S],
		MoqPartialGenericResults_Usual_paramsKey[S],
		MoqPartialGenericResults_Usual_results[S]]

	Runtime MoqPartialGenericResults_runtime
}

// MoqPartialGenericResults_mock isolates the mock interface of the
// PartialGenericResults type
type MoqPartialGenericResults_mock[S ~string] struct {
	Moq *MoqPartialGenericResults[S]
}

// MoqPartialGenericResults_recorder isolates the recorder interface of the
// PartialGenericResults type
type MoqPartialGenericResults_recorder[S ~string] struct {
	Moq *MoqPartialGenericResults[S]
}

// MoqPartialGenericResults_runtime holds runtime configuration for the
// PartialGenericResults type
type MoqPartialGenericResults_runtime struct {
	ParameterIndexing struct {
		Usual MoqPartialGenericResults_Usual_paramIndexing
	}
}

// MoqPartialGenericResults_Usual_adaptor adapts MoqPartialGenericResults as
// needed by the runtime
type MoqPartialGenericResults_Usual_adaptor[S ~string] struct {
	Moq *MoqPartialGenericResults[S]
}

// MoqPartialGenericResults_Usual_params holds the params of the
// PartialGenericResults type
type MoqPartialGenericResults_Usual_params[S ~string] struct {
	Param1 string
	Param2 bool
}

// MoqPartialGenericResults_Usual_paramsKey holds the map key params of the
// PartialGenericResults type
type MoqPartialGenericResults_Usual_paramsKey[S ~string] struct {
	Params struct {
		Param1 string
		Param2 bool
	}
	Hashes struct {
		Param1 hash.Hash
		Param2 hash.Hash
	}
}

// MoqPartialGenericResults_Usual_results holds the results of the
// PartialGenericResults type
type MoqPartialGenericResults_Usual_results[S ~string] struct {
	Result1 S
	Result2 error
}

// MoqPartialGenericResults_Usual_paramIndexing holds the parameter indexing
// runtime configuration for the PartialGenericResults type
type MoqPartialGenericResults_Usual_paramIndexing struct {
	Param1 moq.ParamIndexing
	Param2 moq.ParamIndexing
}

// MoqPartialGenericResults_Usual_doFn defines the type of function needed when
// calling AndDo for the PartialGenericResults type
type MoqPartialGenericResults_Usual_doFn[S ~string] func(string, bool)

// MoqPartialGenericResults_Usual_doReturnFn defines the type of function
// needed when calling DoReturnResults for the PartialGenericResults type
type MoqPartialGenericResults_Usual_doReturnFn[S ~string] func(string, bool) (S, error)

// MoqPartialGenericResults_Usual_recorder routes recorded function calls to
// the MoqPartialGenericResults moq
type MoqPartialGenericResults_Usual_recorder[S ~string] struct {
	Recorder *impl.Recorder[
		*MoqPartialGenericResults_Usual_adaptor[S],
		MoqPartialGenericResults_Usual_params[S],
		MoqPartialGenericResults_Usual_paramsKey[S],
		MoqPartialGenericResults_Usual_results[S]]
}

// MoqPartialGenericResults_Usual_anyParams isolates the any params functions
// of the PartialGenericResults type
type MoqPartialGenericResults_Usual_anyParams[S ~string] struct {
	Recorder *MoqPartialGenericResults_Usual_recorder[S]
}

// NewMoqPartialGenericResults creates a new moq of the PartialGenericResults
// type
func NewMoqPartialGenericResults[S ~string](scene *moq.Scene, config *moq.Config) *MoqPartialGenericResults[S] {
	adaptor1 := &MoqPartialGenericResults_Usual_adaptor[S]{}
	m := &MoqPartialGenericResults[S]{
		Moq: &MoqPartialGenericResults_mock[S]{},

		Moq_Usual: impl.NewMoq[
			*MoqPartialGenericResults_Usual_adaptor[S],
			MoqPartialGenericResults_Usual_params[S],
			MoqPartialGenericResults_Usual_paramsKey[S],
			MoqPartialGenericResults_Usual_results[S]](scene, adaptor1, config),

		Runtime: MoqPartialGenericResults_runtime{ParameterIndexing: struct {
			Usual MoqPartialGenericResults_Usual_paramIndexing
		}{
			Usual: MoqPartialGenericResults_Usual_paramIndexing{
				Param1: moq.ParamIndexByValue,
				Param2: moq.ParamIndexByValue,
			},
		}},
	}
	m.Moq.Moq = m

	adaptor1.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the mock implementation of the PartialGenericResults type
func (m *MoqPartialGenericResults[S]) Mock() *MoqPartialGenericResults_mock[S] { return m.Moq }

func (m *MoqPartialGenericResults_mock[S]) Usual(param1 string, param2 bool) (S, error) {
	m.Moq.Moq_Usual.Scene.T.Helper()
	params := MoqPartialGenericResults_Usual_params[S]{
		Param1: param1,
		Param2: param2,
	}

	var result1 S
	var result2 error
	if result := m.Moq.Moq_Usual.Function(params); result != nil {
		result1 = result.Result1
		result2 = result.Result2
	}
	return result1, result2
}

// OnCall returns the recorder implementation of the PartialGenericResults type
func (m *MoqPartialGenericResults[S]) OnCall() *MoqPartialGenericResults_recorder[S] {
	return &MoqPartialGenericResults_recorder[S]{
		Moq: m,
	}
}

func (m *MoqPartialGenericResults_recorder[S]) Usual(param1 string, param2 bool) *MoqPartialGenericResults_Usual_recorder[S] {
	return &MoqPartialGenericResults_Usual_recorder[S]{
		Recorder: m.Moq.Moq_Usual.OnCall(MoqPartialGenericResults_Usual_params[S]{
			Param1: param1,
			Param2: param2,
		}),
	}
}

func (r *MoqPartialGenericResults_Usual_recorder[S]) Any() *MoqPartialGenericResults_Usual_anyParams[S] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.IsAnyPermitted(true) {
		return nil
	}
	return &MoqPartialGenericResults_Usual_anyParams[S]{Recorder: r}
}

func (a *MoqPartialGenericResults_Usual_anyParams[S]) Param1() *MoqPartialGenericResults_Usual_recorder[S] {
	a.Recorder.Recorder.AnyParam(1)
	return a.Recorder
}

func (a *MoqPartialGenericResults_Usual_anyParams[S]) Param2() *MoqPartialGenericResults_Usual_recorder[S] {
	a.Recorder.Recorder.AnyParam(2)
	return a.Recorder
}

func (r *MoqPartialGenericResults_Usual_recorder[S]) Seq() *MoqPartialGenericResults_Usual_recorder[S] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(true, "Seq", true) {
		return nil
	}
	return r
}

func (r *MoqPartialGenericResults_Usual_recorder[S]) NoSeq() *MoqPartialGenericResults_Usual_recorder[S] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(false, "NoSeq", true) {
		return nil
	}
	return r
}

func (r *MoqPartialGenericResults_Usual_recorder[S]) ReturnResults(result1 S, result2 error) *MoqPartialGenericResults_Usual_recorder[S] {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.ReturnResults(MoqPartialGenericResults_Usual_results[S]{
		Result1: result1,
		Result2: result2,
	})
	return r
}

func (r *MoqPartialGenericResults_Usual_recorder[S]) AndDo(fn MoqPartialGenericResults_Usual_doFn[S]) *MoqPartialGenericResults_Usual_recorder[S] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.AndDo(func(params MoqPartialGenericResults_Usual_params[S]) {
		fn(params.Param1, params.Param2)
	}, true) {
		return nil
	}
	return r
}

func (r *MoqPartialGenericResults_Usual_recorder[S]) DoReturnResults(fn MoqPartialGenericResults_Usual_doReturnFn[S]) *MoqPartialGenericResults_Usual_recorder[S] {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.DoReturnResults(func(params MoqPartialGenericResults_Usual_params[S]) *MoqPartialGenericResults_Usual_results[S] {
		result1, result2 := fn(params.Param1, params.Param2)
		return &MoqPartialGenericResults_Usual_results[S]{
			Result1: result1,
			Result2: result2,
		}
	})
	return r
}

func (r *MoqPartialGenericResults_Usual_recorder[S]) Repeat(repeaters ...moq.Repeater) *MoqPartialGenericResults_Usual_recorder[S] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Repeat(repeaters, true) {
		return nil
	}
	return r
}

func (*MoqPartialGenericResults_Usual_adaptor[S]) PrettyParams(params MoqPartialGenericResults_Usual_params[S]) string {
	return fmt.Sprintf("Usual(%#v, %#v)", params.Param1, params.Param2)
}

func (a *MoqPartialGenericResults_Usual_adaptor[S]) ParamsKey(params MoqPartialGenericResults_Usual_params[S], anyParams uint64) MoqPartialGenericResults_Usual_paramsKey[S] {
	a.Moq.Moq_Usual.Scene.T.Helper()
	param1Used, param1UsedHash := impl.ParamKey(
		params.Param1, 1, a.Moq.Runtime.ParameterIndexing.Usual.Param1, anyParams)
	param2Used, param2UsedHash := impl.ParamKey(
		params.Param2, 2, a.Moq.Runtime.ParameterIndexing.Usual.Param2, anyParams)
	return MoqPartialGenericResults_Usual_paramsKey[S]{
		Params: struct {
			Param1 string
			Param2 bool
		}{
			Param1: param1Used,
			Param2: param2Used,
		},
		Hashes: struct {
			Param1 hash.Hash
			Param2 hash.Hash
		}{
			Param1: param1UsedHash,
			Param2: param2UsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *MoqPartialGenericResults[S]) Reset() {
	m.Moq_Usual.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqPartialGenericResults[S]) AssertExpectationsMet() {
	m.Moq_Usual.Scene.T.Helper()
	m.Moq_Usual.AssertExpectationsMet()
}

// The following type assertion assures that testmoqs.GenericInterfaceParam is
// mocked completely
var _ testmoqs.GenericInterfaceParam[testmoqs.MyWriter] = (*MoqGenericInterfaceParam_mock[testmoqs.MyWriter])(nil)

// MoqGenericInterfaceParam holds the state of a moq of the
// GenericInterfaceParam type
type MoqGenericInterfaceParam[W testmoqs.MyWriter] struct {
	Moq *MoqGenericInterfaceParam_mock[W]

	Moq_Usual *impl.Moq[
		*MoqGenericInterfaceParam_Usual_adaptor[W],
		MoqGenericInterfaceParam_Usual_params[W],
		MoqGenericInterfaceParam_Usual_paramsKey[W],
		MoqGenericInterfaceParam_Usual_results[W]]

	Runtime MoqGenericInterfaceParam_runtime
}

// MoqGenericInterfaceParam_mock isolates the mock interface of the
// GenericInterfaceParam type
type MoqGenericInterfaceParam_mock[W testmoqs.MyWriter] struct {
	Moq *MoqGenericInterfaceParam[W]
}

// MoqGenericInterfaceParam_recorder isolates the recorder interface of the
// GenericInterfaceParam type
type MoqGenericInterfaceParam_recorder[W testmoqs.MyWriter] struct {
	Moq *MoqGenericInterfaceParam[W]
}

// MoqGenericInterfaceParam_runtime holds runtime configuration for the
// GenericInterfaceParam type
type MoqGenericInterfaceParam_runtime struct {
	ParameterIndexing struct {
		Usual MoqGenericInterfaceParam_Usual_paramIndexing
	}
}

// MoqGenericInterfaceParam_Usual_adaptor adapts MoqGenericInterfaceParam as
// needed by the runtime
type MoqGenericInterfaceParam_Usual_adaptor[W testmoqs.MyWriter] struct {
	Moq *MoqGenericInterfaceParam[W]
}

// MoqGenericInterfaceParam_Usual_params holds the params of the
// GenericInterfaceParam type
type MoqGenericInterfaceParam_Usual_params[W testmoqs.MyWriter] struct{ W W }

// MoqGenericInterfaceParam_Usual_paramsKey holds the map key params of the
// GenericInterfaceParam type
type MoqGenericInterfaceParam_Usual_paramsKey[W testmoqs.MyWriter] struct {
	Params struct{}
	Hashes struct{ W hash.Hash }
}

// MoqGenericInterfaceParam_Usual_results holds the results of the
// GenericInterfaceParam type
type MoqGenericInterfaceParam_Usual_results[W testmoqs.MyWriter] struct {
	SResult string
	Err     error
}

// MoqGenericInterfaceParam_Usual_paramIndexing holds the parameter indexing
// runtime configuration for the GenericInterfaceParam type
type MoqGenericInterfaceParam_Usual_paramIndexing struct {
	W moq.ParamIndexing
}

// MoqGenericInterfaceParam_Usual_doFn defines the type of function needed when
// calling AndDo for the GenericInterfaceParam type
type MoqGenericInterfaceParam_Usual_doFn[W testmoqs.MyWriter] func(w W)

// MoqGenericInterfaceParam_Usual_doReturnFn defines the type of function
// needed when calling DoReturnResults for the GenericInterfaceParam type
type MoqGenericInterfaceParam_Usual_doReturnFn[W testmoqs.MyWriter] func(w W) (sResult string, err error)

// MoqGenericInterfaceParam_Usual_recorder routes recorded function calls to
// the MoqGenericInterfaceParam moq
type MoqGenericInterfaceParam_Usual_recorder[W testmoqs.MyWriter] struct {
	Recorder *impl.Recorder[
		*MoqGenericInterfaceParam_Usual_adaptor[W],
		MoqGenericInterfaceParam_Usual_params[W],
		MoqGenericInterfaceParam_Usual_paramsKey[W],
		MoqGenericInterfaceParam_Usual_results[W]]
}

// MoqGenericInterfaceParam_Usual_anyParams isolates the any params functions
// of the GenericInterfaceParam type
type MoqGenericInterfaceParam_Usual_anyParams[W testmoqs.MyWriter] struct {
	Recorder *MoqGenericInterfaceParam_Usual_recorder[W]
}

// NewMoqGenericInterfaceParam creates a new moq of the GenericInterfaceParam
// type
func NewMoqGenericInterfaceParam[W testmoqs.MyWriter](scene *moq.Scene, config *moq.Config) *MoqGenericInterfaceParam[W] {
	adaptor1 := &MoqGenericInterfaceParam_Usual_adaptor[W]{}
	m := &MoqGenericInterfaceParam[W]{
		Moq: &MoqGenericInterfaceParam_mock[W]{},

		Moq_Usual: impl.NewMoq[
			*MoqGenericInterfaceParam_Usual_adaptor[W],
			MoqGenericInterfaceParam_Usual_params[W],
			MoqGenericInterfaceParam_Usual_paramsKey[W],
			MoqGenericInterfaceParam_Usual_results[W]](scene, adaptor1, config),

		Runtime: MoqGenericInterfaceParam_runtime{ParameterIndexing: struct {
			Usual MoqGenericInterfaceParam_Usual_paramIndexing
		}{
			Usual: MoqGenericInterfaceParam_Usual_paramIndexing{
				W: moq.ParamIndexByHash,
			},
		}},
	}
	m.Moq.Moq = m

	adaptor1.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the mock implementation of the GenericInterfaceParam type
func (m *MoqGenericInterfaceParam[W]) Mock() *MoqGenericInterfaceParam_mock[W] { return m.Moq }

func (m *MoqGenericInterfaceParam_mock[W]) Usual(w W) (string, error) {
	m.Moq.Moq_Usual.Scene.T.Helper()
	params := MoqGenericInterfaceParam_Usual_params[W]{
		W: w,
	}

	var result1 string
	var result2 error
	if result := m.Moq.Moq_Usual.Function(params); result != nil {
		result1 = result.SResult
		result2 = result.Err
	}
	return result1, result2
}

// OnCall returns the recorder implementation of the GenericInterfaceParam type
func (m *MoqGenericInterfaceParam[W]) OnCall() *MoqGenericInterfaceParam_recorder[W] {
	return &MoqGenericInterfaceParam_recorder[W]{
		Moq: m,
	}
}

func (m *MoqGenericInterfaceParam_recorder[W]) Usual(w W) *MoqGenericInterfaceParam_Usual_recorder[W] {
	return &MoqGenericInterfaceParam_Usual_recorder[W]{
		Recorder: m.Moq.Moq_Usual.OnCall(MoqGenericInterfaceParam_Usual_params[W]{
			W: w,
		}),
	}
}

func (r *MoqGenericInterfaceParam_Usual_recorder[W]) Any() *MoqGenericInterfaceParam_Usual_anyParams[W] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.IsAnyPermitted(true) {
		return nil
	}
	return &MoqGenericInterfaceParam_Usual_anyParams[W]{Recorder: r}
}

func (a *MoqGenericInterfaceParam_Usual_anyParams[W]) W() *MoqGenericInterfaceParam_Usual_recorder[W] {
	a.Recorder.Recorder.AnyParam(1)
	return a.Recorder
}

func (r *MoqGenericInterfaceParam_Usual_recorder[W]) Seq() *MoqGenericInterfaceParam_Usual_recorder[W] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(true, "Seq", true) {
		return nil
	}
	return r
}

func (r *MoqGenericInterfaceParam_Usual_recorder[W]) NoSeq() *MoqGenericInterfaceParam_Usual_recorder[W] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(false, "NoSeq", true) {
		return nil
	}
	return r
}

func (r *MoqGenericInterfaceParam_Usual_recorder[W]) ReturnResults(sResult string, err error) *MoqGenericInterfaceParam_Usual_recorder[W] {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.ReturnResults(MoqGenericInterfaceParam_Usual_results[W]{
		SResult: sResult,
		Err:     err,
	})
	return r
}

func (r *MoqGenericInterfaceParam_Usual_recorder[W]) AndDo(fn MoqGenericInterfaceParam_Usual_doFn[W]) *MoqGenericInterfaceParam_Usual_recorder[W] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.AndDo(func(params MoqGenericInterfaceParam_Usual_params[W]) {
		fn(params.W)
	}, true) {
		return nil
	}
	return r
}

func (r *MoqGenericInterfaceParam_Usual_recorder[W]) DoReturnResults(fn MoqGenericInterfaceParam_Usual_doReturnFn[W]) *MoqGenericInterfaceParam_Usual_recorder[W] {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.DoReturnResults(func(params MoqGenericInterfaceParam_Usual_params[W]) *MoqGenericInterfaceParam_Usual_results[W] {
		sResult, err := fn(params.W)
		return &MoqGenericInterfaceParam_Usual_results[W]{
			SResult: sResult,
			Err:     err,
		}
	})
	return r
}

func (r *MoqGenericInterfaceParam_Usual_recorder[W]) Repeat(repeaters ...moq.Repeater) *MoqGenericInterfaceParam_Usual_recorder[W] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Repeat(repeaters, true) {
		return nil
	}
	return r
}

func (*MoqGenericInterfaceParam_Usual_adaptor[W]) PrettyParams(params MoqGenericInterfaceParam_Usual_params[W]) string {
	return fmt.Sprintf("Usual(%#v)", params.W)
}

func (a *MoqGenericInterfaceParam_Usual_adaptor[W]) ParamsKey(params MoqGenericInterfaceParam_Usual_params[W], anyParams uint64) MoqGenericInterfaceParam_Usual_paramsKey[W] {
	a.Moq.Moq_Usual.Scene.T.Helper()
	wUsedHash := impl.HashOnlyParamKey(a.Moq.Moq_Usual.Scene.T,
		params.W, "w", 1, a.Moq.Runtime.ParameterIndexing.Usual.W, anyParams)
	return MoqGenericInterfaceParam_Usual_paramsKey[W]{
		Params: struct{}{},
		Hashes: struct{ W hash.Hash }{
			W: wUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *MoqGenericInterfaceParam[W]) Reset() {
	m.Moq_Usual.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqGenericInterfaceParam[W]) AssertExpectationsMet() {
	m.Moq_Usual.Scene.T.Helper()
	m.Moq_Usual.AssertExpectationsMet()
}

// The following type assertion assures that testmoqs.GenericInterfaceResult is
// mocked completely
var _ testmoqs.GenericInterfaceResult[testmoqs.MyReader] = (*MoqGenericInterfaceResult_mock[testmoqs.MyReader])(nil)

// MoqGenericInterfaceResult holds the state of a moq of the
// GenericInterfaceResult type
type MoqGenericInterfaceResult[R testmoqs.MyReader] struct {
	Moq *MoqGenericInterfaceResult_mock[R]

	Moq_Usual *impl.Moq[
		*MoqGenericInterfaceResult_Usual_adaptor[R],
		MoqGenericInterfaceResult_Usual_params[R],
		MoqGenericInterfaceResult_Usual_paramsKey[R],
		MoqGenericInterfaceResult_Usual_results[R]]

	Runtime MoqGenericInterfaceResult_runtime
}

// MoqGenericInterfaceResult_mock isolates the mock interface of the
// GenericInterfaceResult type
type MoqGenericInterfaceResult_mock[R testmoqs.MyReader] struct {
	Moq *MoqGenericInterfaceResult[R]
}

// MoqGenericInterfaceResult_recorder isolates the recorder interface of the
// GenericInterfaceResult type
type MoqGenericInterfaceResult_recorder[R testmoqs.MyReader] struct {
	Moq *MoqGenericInterfaceResult[R]
}

// MoqGenericInterfaceResult_runtime holds runtime configuration for the
// GenericInterfaceResult type
type MoqGenericInterfaceResult_runtime struct {
	ParameterIndexing struct {
		Usual MoqGenericInterfaceResult_Usual_paramIndexing
	}
}

// MoqGenericInterfaceResult_Usual_adaptor adapts MoqGenericInterfaceResult as
// needed by the runtime
type MoqGenericInterfaceResult_Usual_adaptor[R testmoqs.MyReader] struct {
	Moq *MoqGenericInterfaceResult[R]
}

// MoqGenericInterfaceResult_Usual_params holds the params of the
// GenericInterfaceResult type
type MoqGenericInterfaceResult_Usual_params[R testmoqs.MyReader] struct {
	SParam string
	BParam bool
}

// MoqGenericInterfaceResult_Usual_paramsKey holds the map key params of the
// GenericInterfaceResult type
type MoqGenericInterfaceResult_Usual_paramsKey[R testmoqs.MyReader] struct {
	Params struct {
		SParam string
		BParam bool
	}
	Hashes struct {
		SParam hash.Hash
		BParam hash.Hash
	}
}

// MoqGenericInterfaceResult_Usual_results holds the results of the
// GenericInterfaceResult type
type MoqGenericInterfaceResult_Usual_results[R testmoqs.MyReader] struct{ Result1 R }

// MoqGenericInterfaceResult_Usual_paramIndexing holds the parameter indexing
// runtime configuration for the GenericInterfaceResult type
type MoqGenericInterfaceResult_Usual_paramIndexing struct {
	SParam moq.ParamIndexing
	BParam moq.ParamIndexing
}

// MoqGenericInterfaceResult_Usual_doFn defines the type of function needed
// when calling AndDo for the GenericInterfaceResult type
type MoqGenericInterfaceResult_Usual_doFn[R testmoqs.MyReader] func(sParam string, bParam bool)

// MoqGenericInterfaceResult_Usual_doReturnFn defines the type of function
// needed when calling DoReturnResults for the GenericInterfaceResult type
type MoqGenericInterfaceResult_Usual_doReturnFn[R testmoqs.MyReader] func(sParam string, bParam bool) (r R)

// MoqGenericInterfaceResult_Usual_recorder routes recorded function calls to
// the MoqGenericInterfaceResult moq
type MoqGenericInterfaceResult_Usual_recorder[R testmoqs.MyReader] struct {
	Recorder *impl.Recorder[
		*MoqGenericInterfaceResult_Usual_adaptor[R],
		MoqGenericInterfaceResult_Usual_params[R],
		MoqGenericInterfaceResult_Usual_paramsKey[R],
		MoqGenericInterfaceResult_Usual_results[R]]
}

// MoqGenericInterfaceResult_Usual_anyParams isolates the any params functions
// of the GenericInterfaceResult type
type MoqGenericInterfaceResult_Usual_anyParams[R testmoqs.MyReader] struct {
	Recorder *MoqGenericInterfaceResult_Usual_recorder[R]
}

// NewMoqGenericInterfaceResult creates a new moq of the GenericInterfaceResult
// type
func NewMoqGenericInterfaceResult[R testmoqs.MyReader](scene *moq.Scene, config *moq.Config) *MoqGenericInterfaceResult[R] {
	adaptor1 := &MoqGenericInterfaceResult_Usual_adaptor[R]{}
	m := &MoqGenericInterfaceResult[R]{
		Moq: &MoqGenericInterfaceResult_mock[R]{},

		Moq_Usual: impl.NewMoq[
			*MoqGenericInterfaceResult_Usual_adaptor[R],
			MoqGenericInterfaceResult_Usual_params[R],
			MoqGenericInterfaceResult_Usual_paramsKey[R],
			MoqGenericInterfaceResult_Usual_results[R]](scene, adaptor1, config),

		Runtime: MoqGenericInterfaceResult_runtime{ParameterIndexing: struct {
			Usual MoqGenericInterfaceResult_Usual_paramIndexing
		}{
			Usual: MoqGenericInterfaceResult_Usual_paramIndexing{
				SParam: moq.ParamIndexByValue,
				BParam: moq.ParamIndexByValue,
			},
		}},
	}
	m.Moq.Moq = m

	adaptor1.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the mock implementation of the GenericInterfaceResult type
func (m *MoqGenericInterfaceResult[R]) Mock() *MoqGenericInterfaceResult_mock[R] { return m.Moq }

func (m *MoqGenericInterfaceResult_mock[R]) Usual(sParam string, bParam bool) R {
	m.Moq.Moq_Usual.Scene.T.Helper()
	params := MoqGenericInterfaceResult_Usual_params[R]{
		SParam: sParam,
		BParam: bParam,
	}

	var result1 R
	if result := m.Moq.Moq_Usual.Function(params); result != nil {
		result1 = result.Result1
	}
	return result1
}

// OnCall returns the recorder implementation of the GenericInterfaceResult
// type
func (m *MoqGenericInterfaceResult[R]) OnCall() *MoqGenericInterfaceResult_recorder[R] {
	return &MoqGenericInterfaceResult_recorder[R]{
		Moq: m,
	}
}

func (m *MoqGenericInterfaceResult_recorder[R]) Usual(sParam string, bParam bool) *MoqGenericInterfaceResult_Usual_recorder[R] {
	return &MoqGenericInterfaceResult_Usual_recorder[R]{
		Recorder: m.Moq.Moq_Usual.OnCall(MoqGenericInterfaceResult_Usual_params[R]{
			SParam: sParam,
			BParam: bParam,
		}),
	}
}

func (r *MoqGenericInterfaceResult_Usual_recorder[R]) Any() *MoqGenericInterfaceResult_Usual_anyParams[R] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.IsAnyPermitted(true) {
		return nil
	}
	return &MoqGenericInterfaceResult_Usual_anyParams[R]{Recorder: r}
}

func (a *MoqGenericInterfaceResult_Usual_anyParams[R]) SParam() *MoqGenericInterfaceResult_Usual_recorder[R] {
	a.Recorder.Recorder.AnyParam(1)
	return a.Recorder
}

func (a *MoqGenericInterfaceResult_Usual_anyParams[R]) BParam() *MoqGenericInterfaceResult_Usual_recorder[R] {
	a.Recorder.Recorder.AnyParam(2)
	return a.Recorder
}

func (r *MoqGenericInterfaceResult_Usual_recorder[R]) Seq() *MoqGenericInterfaceResult_Usual_recorder[R] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(true, "Seq", true) {
		return nil
	}
	return r
}

func (r *MoqGenericInterfaceResult_Usual_recorder[R]) NoSeq() *MoqGenericInterfaceResult_Usual_recorder[R] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(false, "NoSeq", true) {
		return nil
	}
	return r
}

func (r *MoqGenericInterfaceResult_Usual_recorder[R]) ReturnResults(result1 R) *MoqGenericInterfaceResult_Usual_recorder[R] {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.ReturnResults(MoqGenericInterfaceResult_Usual_results[R]{
		Result1: result1,
	})
	return r
}

func (r *MoqGenericInterfaceResult_Usual_recorder[R]) AndDo(fn MoqGenericInterfaceResult_Usual_doFn[R]) *MoqGenericInterfaceResult_Usual_recorder[R] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.AndDo(func(params MoqGenericInterfaceResult_Usual_params[R]) {
		fn(params.SParam, params.BParam)
	}, true) {
		return nil
	}
	return r
}

func (r *MoqGenericInterfaceResult_Usual_recorder[R]) DoReturnResults(fn MoqGenericInterfaceResult_Usual_doReturnFn[R]) *MoqGenericInterfaceResult_Usual_recorder[R] {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.DoReturnResults(func(params MoqGenericInterfaceResult_Usual_params[R]) *MoqGenericInterfaceResult_Usual_results[R] {
		result1 := fn(params.SParam, params.BParam)
		return &MoqGenericInterfaceResult_Usual_results[R]{
			Result1: result1,
		}
	})
	return r
}

func (r *MoqGenericInterfaceResult_Usual_recorder[R]) Repeat(repeaters ...moq.Repeater) *MoqGenericInterfaceResult_Usual_recorder[R] {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Repeat(repeaters, true) {
		return nil
	}
	return r
}

func (*MoqGenericInterfaceResult_Usual_adaptor[R]) PrettyParams(params MoqGenericInterfaceResult_Usual_params[R]) string {
	return fmt.Sprintf("Usual(%#v, %#v)", params.SParam, params.BParam)
}

func (a *MoqGenericInterfaceResult_Usual_adaptor[R]) ParamsKey(params MoqGenericInterfaceResult_Usual_params[R], anyParams uint64) MoqGenericInterfaceResult_Usual_paramsKey[R] {
	a.Moq.Moq_Usual.Scene.T.Helper()
	sParamUsed, sParamUsedHash := impl.ParamKey(
		params.SParam, 1, a.Moq.Runtime.ParameterIndexing.Usual.SParam, anyParams)
	bParamUsed, bParamUsedHash := impl.ParamKey(
		params.BParam, 2, a.Moq.Runtime.ParameterIndexing.Usual.BParam, anyParams)
	return MoqGenericInterfaceResult_Usual_paramsKey[R]{
		Params: struct {
			SParam string
			BParam bool
		}{
			SParam: sParamUsed,
			BParam: bParamUsed,
		},
		Hashes: struct {
			SParam hash.Hash
			BParam hash.Hash
		}{
			SParam: sParamUsedHash,
			BParam: bParamUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *MoqGenericInterfaceResult[R]) Reset() {
	m.Moq_Usual.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqGenericInterfaceResult[R]) AssertExpectationsMet() {
	m.Moq_Usual.Scene.T.Helper()
	m.Moq_Usual.AssertExpectationsMet()
}

// MoqUnsafePointerFn holds the state of a moq of the UnsafePointerFn type
type MoqUnsafePointerFn struct {
	Moq *impl.Moq[
		*MoqUnsafePointerFn_adaptor,
		MoqUnsafePointerFn_params,
		MoqUnsafePointerFn_paramsKey,
		MoqUnsafePointerFn_results,
	]

	Runtime MoqUnsafePointerFn_runtime
}

// MoqUnsafePointerFn_runtime holds runtime configuration for the
// UnsafePointerFn type
type MoqUnsafePointerFn_runtime struct {
	ParameterIndexing MoqUnsafePointerFn_paramIndexing
}

// MoqUnsafePointerFn_adaptor adapts MoqUnsafePointerFn as needed by the
// runtime
type MoqUnsafePointerFn_adaptor struct {
	Moq *MoqUnsafePointerFn
}

// MoqUnsafePointerFn_params holds the params of the UnsafePointerFn type
type MoqUnsafePointerFn_params struct{}

// MoqUnsafePointerFn_paramsKey holds the map key params of the UnsafePointerFn
// type
type MoqUnsafePointerFn_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqUnsafePointerFn_results holds the results of the UnsafePointerFn type
type MoqUnsafePointerFn_results struct {
	Result1 unsafe.Pointer
}

// MoqUnsafePointerFn_paramIndexing holds the parameter indexing runtime
// configuration for the UnsafePointerFn type
type MoqUnsafePointerFn_paramIndexing struct{}

// MoqUnsafePointerFn_doFn defines the type of function needed when calling
// AndDo for the UnsafePointerFn type
type MoqUnsafePointerFn_doFn func()

// MoqUnsafePointerFn_doReturnFn defines the type of function needed when
// calling DoReturnResults for the UnsafePointerFn type
type MoqUnsafePointerFn_doReturnFn func() unsafe.Pointer

// MoqUnsafePointerFn_recorder routes recorded function calls to the
// MoqUnsafePointerFn moq
type MoqUnsafePointerFn_recorder struct {
	Recorder *impl.Recorder[
		*MoqUnsafePointerFn_adaptor,
		MoqUnsafePointerFn_params,
		MoqUnsafePointerFn_paramsKey,
		MoqUnsafePointerFn_results,
	]
}

// MoqUnsafePointerFn_anyParams isolates the any params functions of the
// UnsafePointerFn type
type MoqUnsafePointerFn_anyParams struct {
	Recorder *MoqUnsafePointerFn_recorder
}

// NewMoqUnsafePointerFn creates a new moq of the UnsafePointerFn type
func NewMoqUnsafePointerFn(scene *moq.Scene, config *moq.Config) *MoqUnsafePointerFn {
	adaptor1 := &MoqUnsafePointerFn_adaptor{}
	m := &MoqUnsafePointerFn{
		Moq: impl.NewMoq[
			*MoqUnsafePointerFn_adaptor,
			MoqUnsafePointerFn_params,
			MoqUnsafePointerFn_paramsKey,
			MoqUnsafePointerFn_results,
		](scene, adaptor1, config),

		Runtime: MoqUnsafePointerFn_runtime{ParameterIndexing: MoqUnsafePointerFn_paramIndexing{}},
	}
	adaptor1.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the moq implementation of the UnsafePointerFn type
func (m *MoqUnsafePointerFn) Mock() testmoqs.UnsafePointerFn {
	return func() unsafe.Pointer {
		m.Moq.Scene.T.Helper()
		params := MoqUnsafePointerFn_params{}

		var result1 unsafe.Pointer
		if result := m.Moq.Function(params); result != nil {
			result1 = result.Result1
		}
		return result1
	}
}

func (m *MoqUnsafePointerFn) OnCall() *MoqUnsafePointerFn_recorder {
	return &MoqUnsafePointerFn_recorder{
		Recorder: m.Moq.OnCall(MoqUnsafePointerFn_params{}),
	}
}

func (r *MoqUnsafePointerFn_recorder) Any() *MoqUnsafePointerFn_anyParams {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.IsAnyPermitted(true) {
		return nil
	}
	return &MoqUnsafePointerFn_anyParams{Recorder: r}
}

func (r *MoqUnsafePointerFn_recorder) Seq() *MoqUnsafePointerFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(true, "Seq", true) {
		return nil
	}
	return r
}

func (r *MoqUnsafePointerFn_recorder) NoSeq() *MoqUnsafePointerFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Seq(false, "NoSeq", true) {
		return nil
	}
	return r
}

func (r *MoqUnsafePointerFn_recorder) ReturnResults(result1 unsafe.Pointer) *MoqUnsafePointerFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.ReturnResults(MoqUnsafePointerFn_results{
		Result1: result1,
	})
	return r
}

func (r *MoqUnsafePointerFn_recorder) AndDo(fn MoqUnsafePointerFn_doFn) *MoqUnsafePointerFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.AndDo(func(params MoqUnsafePointerFn_params) {
		fn()
	}, true) {
		return nil
	}
	return r
}

func (r *MoqUnsafePointerFn_recorder) DoReturnResults(fn MoqUnsafePointerFn_doReturnFn) *MoqUnsafePointerFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	r.Recorder.DoReturnResults(func(params MoqUnsafePointerFn_params) *MoqUnsafePointerFn_results {
		result1 := fn()
		return &MoqUnsafePointerFn_results{
			Result1: result1,
		}
	})
	return r
}

func (r *MoqUnsafePointerFn_recorder) Repeat(repeaters ...moq.Repeater) *MoqUnsafePointerFn_recorder {
	r.Recorder.Moq.Scene.T.Helper()
	if !r.Recorder.Repeat(repeaters, true) {
		return nil
	}
	return r
}

func (*MoqUnsafePointerFn_adaptor) PrettyParams(params MoqUnsafePointerFn_params) string {
	return fmt.Sprintf("UnsafePointerFn()")
}

func (a *MoqUnsafePointerFn_adaptor) ParamsKey(params MoqUnsafePointerFn_params, anyParams uint64) MoqUnsafePointerFn_paramsKey {
	a.Moq.Moq.Scene.T.Helper()
	return MoqUnsafePointerFn_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

// Reset resets the state of the moq
func (m *MoqUnsafePointerFn) Reset() {
	m.Moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqUnsafePointerFn) AssertExpectationsMet() {
	m.Moq.Scene.T.Helper()
	m.Moq.AssertExpectationsMet()
}
