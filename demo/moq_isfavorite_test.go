// Code generated by Moqueries - https://moqueries.org - DO NOT EDIT.

package demo_test

import (
	"fmt"

	"moqueries.org/cli/demo"
	"moqueries.org/runtime/hash"
	"moqueries.org/runtime/impl"
	"moqueries.org/runtime/moq"
)

// moqIsFavorite holds the state of a moq of the IsFavorite type
type moqIsFavorite struct {
	moq *impl.Moq[
		*moqIsFavorite_adaptor,
		moqIsFavorite_params,
		moqIsFavorite_paramsKey,
		moqIsFavorite_results,
	]

	runtime moqIsFavorite_runtime
}

// moqIsFavorite_runtime holds runtime configuration for the IsFavorite type
type moqIsFavorite_runtime struct {
	parameterIndexing moqIsFavorite_paramIndexing
}

// moqIsFavorite_adaptor adapts moqIsFavorite as needed by the runtime
type moqIsFavorite_adaptor struct {
	moq *moqIsFavorite
}

// moqIsFavorite_params holds the params of the IsFavorite type
type moqIsFavorite_params struct{ n int }

// moqIsFavorite_paramsKey holds the map key params of the IsFavorite type
type moqIsFavorite_paramsKey struct {
	params struct{ n int }
	hashes struct{ n hash.Hash }
}

// moqIsFavorite_results holds the results of the IsFavorite type
type moqIsFavorite_results struct {
	result1 bool
}

// moqIsFavorite_paramIndexing holds the parameter indexing runtime
// configuration for the IsFavorite type
type moqIsFavorite_paramIndexing struct {
	n moq.ParamIndexing
}

// moqIsFavorite_doFn defines the type of function needed when calling andDo
// for the IsFavorite type
type moqIsFavorite_doFn func(n int)

// moqIsFavorite_doReturnFn defines the type of function needed when calling
// doReturnResults for the IsFavorite type
type moqIsFavorite_doReturnFn func(n int) bool

// moqIsFavorite_recorder routes recorded function calls to the moqIsFavorite
// moq
type moqIsFavorite_recorder struct {
	recorder *impl.Recorder[
		*moqIsFavorite_adaptor,
		moqIsFavorite_params,
		moqIsFavorite_paramsKey,
		moqIsFavorite_results,
	]
}

// moqIsFavorite_anyParams isolates the any params functions of the IsFavorite
// type
type moqIsFavorite_anyParams struct {
	recorder *moqIsFavorite_recorder
}

// newMoqIsFavorite creates a new moq of the IsFavorite type
func newMoqIsFavorite(scene *moq.Scene, config *moq.Config) *moqIsFavorite {
	adaptor1 := &moqIsFavorite_adaptor{}
	m := &moqIsFavorite{
		moq: impl.NewMoq[
			*moqIsFavorite_adaptor,
			moqIsFavorite_params,
			moqIsFavorite_paramsKey,
			moqIsFavorite_results,
		](scene, adaptor1, config),

		runtime: moqIsFavorite_runtime{parameterIndexing: moqIsFavorite_paramIndexing{
			n: moq.ParamIndexByValue,
		}},
	}
	adaptor1.moq = m

	scene.AddMoq(m)
	return m
}

// mock returns the moq implementation of the IsFavorite type
func (m *moqIsFavorite) mock() demo.IsFavorite {
	return func(n int) bool {
		m.moq.Scene.T.Helper()
		params := moqIsFavorite_params{
			n: n,
		}

		var result1 bool
		if result := m.moq.Function(params); result != nil {
			result1 = result.result1
		}
		return result1
	}
}

func (m *moqIsFavorite) onCall(n int) *moqIsFavorite_recorder {
	return &moqIsFavorite_recorder{
		recorder: m.moq.OnCall(moqIsFavorite_params{
			n: n,
		}),
	}
}

func (r *moqIsFavorite_recorder) any() *moqIsFavorite_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqIsFavorite_anyParams{recorder: r}
}

func (a *moqIsFavorite_anyParams) n() *moqIsFavorite_recorder {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (r *moqIsFavorite_recorder) seq() *moqIsFavorite_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqIsFavorite_recorder) noSeq() *moqIsFavorite_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqIsFavorite_recorder) returnResults(result1 bool) *moqIsFavorite_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqIsFavorite_results{
		result1: result1,
	})
	return r
}

func (r *moqIsFavorite_recorder) andDo(fn moqIsFavorite_doFn) *moqIsFavorite_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqIsFavorite_params) {
		fn(params.n)
	}, false) {
		return nil
	}
	return r
}

func (r *moqIsFavorite_recorder) doReturnResults(fn moqIsFavorite_doReturnFn) *moqIsFavorite_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqIsFavorite_params) *moqIsFavorite_results {
		result1 := fn(params.n)
		return &moqIsFavorite_results{
			result1: result1,
		}
	})
	return r
}

func (r *moqIsFavorite_recorder) repeat(repeaters ...moq.Repeater) *moqIsFavorite_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqIsFavorite_adaptor) PrettyParams(params moqIsFavorite_params) string {
	return fmt.Sprintf("IsFavorite(%#v)", params.n)
}

func (a *moqIsFavorite_adaptor) ParamsKey(params moqIsFavorite_params, anyParams uint64) moqIsFavorite_paramsKey {
	a.moq.moq.Scene.T.Helper()
	nUsed, nUsedHash := impl.ParamKey(
		params.n, 1, a.moq.runtime.parameterIndexing.n, anyParams)
	return moqIsFavorite_paramsKey{
		params: struct{ n int }{
			n: nUsed,
		},
		hashes: struct{ n hash.Hash }{
			n: nUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *moqIsFavorite) Reset() {
	m.moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *moqIsFavorite) AssertExpectationsMet() {
	m.moq.Scene.T.Helper()
	m.moq.AssertExpectationsMet()
}
