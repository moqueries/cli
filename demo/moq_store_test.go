// Code generated by Moqueries - https://moqueries.org - DO NOT EDIT.

package demo_test

import (
	"fmt"

	"moqueries.org/cli/demo"
	"moqueries.org/runtime/hash"
	"moqueries.org/runtime/impl"
	"moqueries.org/runtime/moq"
)

// The following type assertion assures that demo.Store is mocked completely
var _ demo.Store = (*moqStore_mock)(nil)

// moqStore holds the state of a moq of the Store type
type moqStore struct {
	moq *moqStore_mock

	moq_AllWidgetsIds *impl.Moq[
		*moqStore_AllWidgetsIds_adaptor,
		moqStore_AllWidgetsIds_params,
		moqStore_AllWidgetsIds_paramsKey,
		moqStore_AllWidgetsIds_results,
	]
	moq_GadgetsByWidgetId *impl.Moq[
		*moqStore_GadgetsByWidgetId_adaptor,
		moqStore_GadgetsByWidgetId_params,
		moqStore_GadgetsByWidgetId_paramsKey,
		moqStore_GadgetsByWidgetId_results,
	]
	moq_LightGadgetsByWidgetId *impl.Moq[
		*moqStore_LightGadgetsByWidgetId_adaptor,
		moqStore_LightGadgetsByWidgetId_params,
		moqStore_LightGadgetsByWidgetId_paramsKey,
		moqStore_LightGadgetsByWidgetId_results,
	]

	runtime moqStore_runtime
}

// moqStore_mock isolates the mock interface of the Store type
type moqStore_mock struct {
	moq *moqStore
}

// moqStore_recorder isolates the recorder interface of the Store type
type moqStore_recorder struct {
	moq *moqStore
}

// moqStore_runtime holds runtime configuration for the Store type
type moqStore_runtime struct {
	parameterIndexing struct {
		AllWidgetsIds          moqStore_AllWidgetsIds_paramIndexing
		GadgetsByWidgetId      moqStore_GadgetsByWidgetId_paramIndexing
		LightGadgetsByWidgetId moqStore_LightGadgetsByWidgetId_paramIndexing
	}
}

// moqStore_AllWidgetsIds_adaptor adapts moqStore as needed by the runtime
type moqStore_AllWidgetsIds_adaptor struct {
	moq *moqStore
}

// moqStore_AllWidgetsIds_params holds the params of the Store type
type moqStore_AllWidgetsIds_params struct{}

// moqStore_AllWidgetsIds_paramsKey holds the map key params of the Store type
type moqStore_AllWidgetsIds_paramsKey struct {
	params struct{}
	hashes struct{}
}

// moqStore_AllWidgetsIds_results holds the results of the Store type
type moqStore_AllWidgetsIds_results struct {
	result1 []int
	result2 error
}

// moqStore_AllWidgetsIds_paramIndexing holds the parameter indexing runtime
// configuration for the Store type
type moqStore_AllWidgetsIds_paramIndexing struct{}

// moqStore_AllWidgetsIds_doFn defines the type of function needed when calling
// andDo for the Store type
type moqStore_AllWidgetsIds_doFn func()

// moqStore_AllWidgetsIds_doReturnFn defines the type of function needed when
// calling doReturnResults for the Store type
type moqStore_AllWidgetsIds_doReturnFn func() ([]int, error)

// moqStore_AllWidgetsIds_recorder routes recorded function calls to the
// moqStore moq
type moqStore_AllWidgetsIds_recorder struct {
	recorder *impl.Recorder[
		*moqStore_AllWidgetsIds_adaptor,
		moqStore_AllWidgetsIds_params,
		moqStore_AllWidgetsIds_paramsKey,
		moqStore_AllWidgetsIds_results,
	]
}

// moqStore_AllWidgetsIds_anyParams isolates the any params functions of the
// Store type
type moqStore_AllWidgetsIds_anyParams struct {
	recorder *moqStore_AllWidgetsIds_recorder
}

// moqStore_GadgetsByWidgetId_adaptor adapts moqStore as needed by the runtime
type moqStore_GadgetsByWidgetId_adaptor struct {
	moq *moqStore
}

// moqStore_GadgetsByWidgetId_params holds the params of the Store type
type moqStore_GadgetsByWidgetId_params struct{ widgetId int }

// moqStore_GadgetsByWidgetId_paramsKey holds the map key params of the Store
// type
type moqStore_GadgetsByWidgetId_paramsKey struct {
	params struct{ widgetId int }
	hashes struct{ widgetId hash.Hash }
}

// moqStore_GadgetsByWidgetId_results holds the results of the Store type
type moqStore_GadgetsByWidgetId_results struct {
	result1 []demo.Gadget
	result2 error
}

// moqStore_GadgetsByWidgetId_paramIndexing holds the parameter indexing
// runtime configuration for the Store type
type moqStore_GadgetsByWidgetId_paramIndexing struct {
	widgetId moq.ParamIndexing
}

// moqStore_GadgetsByWidgetId_doFn defines the type of function needed when
// calling andDo for the Store type
type moqStore_GadgetsByWidgetId_doFn func(widgetId int)

// moqStore_GadgetsByWidgetId_doReturnFn defines the type of function needed
// when calling doReturnResults for the Store type
type moqStore_GadgetsByWidgetId_doReturnFn func(widgetId int) ([]demo.Gadget, error)

// moqStore_GadgetsByWidgetId_recorder routes recorded function calls to the
// moqStore moq
type moqStore_GadgetsByWidgetId_recorder struct {
	recorder *impl.Recorder[
		*moqStore_GadgetsByWidgetId_adaptor,
		moqStore_GadgetsByWidgetId_params,
		moqStore_GadgetsByWidgetId_paramsKey,
		moqStore_GadgetsByWidgetId_results,
	]
}

// moqStore_GadgetsByWidgetId_anyParams isolates the any params functions of
// the Store type
type moqStore_GadgetsByWidgetId_anyParams struct {
	recorder *moqStore_GadgetsByWidgetId_recorder
}

// moqStore_LightGadgetsByWidgetId_adaptor adapts moqStore as needed by the
// runtime
type moqStore_LightGadgetsByWidgetId_adaptor struct {
	moq *moqStore
}

// moqStore_LightGadgetsByWidgetId_params holds the params of the Store type
type moqStore_LightGadgetsByWidgetId_params struct {
	widgetId  int
	maxWeight uint32
}

// moqStore_LightGadgetsByWidgetId_paramsKey holds the map key params of the
// Store type
type moqStore_LightGadgetsByWidgetId_paramsKey struct {
	params struct {
		widgetId  int
		maxWeight uint32
	}
	hashes struct {
		widgetId  hash.Hash
		maxWeight hash.Hash
	}
}

// moqStore_LightGadgetsByWidgetId_results holds the results of the Store type
type moqStore_LightGadgetsByWidgetId_results struct {
	result1 []demo.Gadget
	result2 error
}

// moqStore_LightGadgetsByWidgetId_paramIndexing holds the parameter indexing
// runtime configuration for the Store type
type moqStore_LightGadgetsByWidgetId_paramIndexing struct {
	widgetId  moq.ParamIndexing
	maxWeight moq.ParamIndexing
}

// moqStore_LightGadgetsByWidgetId_doFn defines the type of function needed
// when calling andDo for the Store type
type moqStore_LightGadgetsByWidgetId_doFn func(widgetId int, maxWeight uint32)

// moqStore_LightGadgetsByWidgetId_doReturnFn defines the type of function
// needed when calling doReturnResults for the Store type
type moqStore_LightGadgetsByWidgetId_doReturnFn func(widgetId int, maxWeight uint32) ([]demo.Gadget, error)

// moqStore_LightGadgetsByWidgetId_recorder routes recorded function calls to
// the moqStore moq
type moqStore_LightGadgetsByWidgetId_recorder struct {
	recorder *impl.Recorder[
		*moqStore_LightGadgetsByWidgetId_adaptor,
		moqStore_LightGadgetsByWidgetId_params,
		moqStore_LightGadgetsByWidgetId_paramsKey,
		moqStore_LightGadgetsByWidgetId_results,
	]
}

// moqStore_LightGadgetsByWidgetId_anyParams isolates the any params functions
// of the Store type
type moqStore_LightGadgetsByWidgetId_anyParams struct {
	recorder *moqStore_LightGadgetsByWidgetId_recorder
}

// newMoqStore creates a new moq of the Store type
func newMoqStore(scene *moq.Scene, config *moq.Config) *moqStore {
	adaptor1 := &moqStore_AllWidgetsIds_adaptor{}
	adaptor2 := &moqStore_GadgetsByWidgetId_adaptor{}
	adaptor3 := &moqStore_LightGadgetsByWidgetId_adaptor{}
	m := &moqStore{
		moq: &moqStore_mock{},

		moq_AllWidgetsIds: impl.NewMoq[
			*moqStore_AllWidgetsIds_adaptor,
			moqStore_AllWidgetsIds_params,
			moqStore_AllWidgetsIds_paramsKey,
			moqStore_AllWidgetsIds_results,
		](scene, adaptor1, config),
		moq_GadgetsByWidgetId: impl.NewMoq[
			*moqStore_GadgetsByWidgetId_adaptor,
			moqStore_GadgetsByWidgetId_params,
			moqStore_GadgetsByWidgetId_paramsKey,
			moqStore_GadgetsByWidgetId_results,
		](scene, adaptor2, config),
		moq_LightGadgetsByWidgetId: impl.NewMoq[
			*moqStore_LightGadgetsByWidgetId_adaptor,
			moqStore_LightGadgetsByWidgetId_params,
			moqStore_LightGadgetsByWidgetId_paramsKey,
			moqStore_LightGadgetsByWidgetId_results,
		](scene, adaptor3, config),

		runtime: moqStore_runtime{parameterIndexing: struct {
			AllWidgetsIds          moqStore_AllWidgetsIds_paramIndexing
			GadgetsByWidgetId      moqStore_GadgetsByWidgetId_paramIndexing
			LightGadgetsByWidgetId moqStore_LightGadgetsByWidgetId_paramIndexing
		}{
			AllWidgetsIds: moqStore_AllWidgetsIds_paramIndexing{},
			GadgetsByWidgetId: moqStore_GadgetsByWidgetId_paramIndexing{
				widgetId: moq.ParamIndexByValue,
			},
			LightGadgetsByWidgetId: moqStore_LightGadgetsByWidgetId_paramIndexing{
				widgetId:  moq.ParamIndexByValue,
				maxWeight: moq.ParamIndexByValue,
			},
		}},
	}
	m.moq.moq = m

	adaptor1.moq = m
	adaptor2.moq = m
	adaptor3.moq = m

	scene.AddMoq(m)
	return m
}

// mock returns the mock implementation of the Store type
func (m *moqStore) mock() *moqStore_mock { return m.moq }

func (m *moqStore_mock) AllWidgetsIds() ([]int, error) {
	m.moq.moq_AllWidgetsIds.Scene.T.Helper()
	params := moqStore_AllWidgetsIds_params{}

	var result1 []int
	var result2 error
	if result := m.moq.moq_AllWidgetsIds.Function(params); result != nil {
		result1 = result.result1
		result2 = result.result2
	}
	return result1, result2
}

func (m *moqStore_mock) GadgetsByWidgetId(widgetId int) ([]demo.Gadget, error) {
	m.moq.moq_GadgetsByWidgetId.Scene.T.Helper()
	params := moqStore_GadgetsByWidgetId_params{
		widgetId: widgetId,
	}

	var result1 []demo.Gadget
	var result2 error
	if result := m.moq.moq_GadgetsByWidgetId.Function(params); result != nil {
		result1 = result.result1
		result2 = result.result2
	}
	return result1, result2
}

func (m *moqStore_mock) LightGadgetsByWidgetId(widgetId int, maxWeight uint32) ([]demo.Gadget, error) {
	m.moq.moq_LightGadgetsByWidgetId.Scene.T.Helper()
	params := moqStore_LightGadgetsByWidgetId_params{
		widgetId:  widgetId,
		maxWeight: maxWeight,
	}

	var result1 []demo.Gadget
	var result2 error
	if result := m.moq.moq_LightGadgetsByWidgetId.Function(params); result != nil {
		result1 = result.result1
		result2 = result.result2
	}
	return result1, result2
}

// onCall returns the recorder implementation of the Store type
func (m *moqStore) onCall() *moqStore_recorder {
	return &moqStore_recorder{
		moq: m,
	}
}

func (m *moqStore_recorder) AllWidgetsIds() *moqStore_AllWidgetsIds_recorder {
	return &moqStore_AllWidgetsIds_recorder{
		recorder: m.moq.moq_AllWidgetsIds.OnCall(moqStore_AllWidgetsIds_params{}),
	}
}

func (r *moqStore_AllWidgetsIds_recorder) any() *moqStore_AllWidgetsIds_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqStore_AllWidgetsIds_anyParams{recorder: r}
}

func (r *moqStore_AllWidgetsIds_recorder) seq() *moqStore_AllWidgetsIds_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqStore_AllWidgetsIds_recorder) noSeq() *moqStore_AllWidgetsIds_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqStore_AllWidgetsIds_recorder) returnResults(result1 []int, result2 error) *moqStore_AllWidgetsIds_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqStore_AllWidgetsIds_results{
		result1: result1,
		result2: result2,
	})
	return r
}

func (r *moqStore_AllWidgetsIds_recorder) andDo(fn moqStore_AllWidgetsIds_doFn) *moqStore_AllWidgetsIds_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqStore_AllWidgetsIds_params) {
		fn()
	}, false) {
		return nil
	}
	return r
}

func (r *moqStore_AllWidgetsIds_recorder) doReturnResults(fn moqStore_AllWidgetsIds_doReturnFn) *moqStore_AllWidgetsIds_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqStore_AllWidgetsIds_params) *moqStore_AllWidgetsIds_results {
		result1, result2 := fn()
		return &moqStore_AllWidgetsIds_results{
			result1: result1,
			result2: result2,
		}
	})
	return r
}

func (r *moqStore_AllWidgetsIds_recorder) repeat(repeaters ...moq.Repeater) *moqStore_AllWidgetsIds_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqStore_AllWidgetsIds_adaptor) PrettyParams(params moqStore_AllWidgetsIds_params) string {
	return fmt.Sprintf("AllWidgetsIds()")
}

func (a *moqStore_AllWidgetsIds_adaptor) ParamsKey(params moqStore_AllWidgetsIds_params, anyParams uint64) moqStore_AllWidgetsIds_paramsKey {
	a.moq.moq_AllWidgetsIds.Scene.T.Helper()
	return moqStore_AllWidgetsIds_paramsKey{
		params: struct{}{},
		hashes: struct{}{},
	}
}

func (m *moqStore_recorder) GadgetsByWidgetId(widgetId int) *moqStore_GadgetsByWidgetId_recorder {
	return &moqStore_GadgetsByWidgetId_recorder{
		recorder: m.moq.moq_GadgetsByWidgetId.OnCall(moqStore_GadgetsByWidgetId_params{
			widgetId: widgetId,
		}),
	}
}

func (r *moqStore_GadgetsByWidgetId_recorder) any() *moqStore_GadgetsByWidgetId_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqStore_GadgetsByWidgetId_anyParams{recorder: r}
}

func (a *moqStore_GadgetsByWidgetId_anyParams) widgetId() *moqStore_GadgetsByWidgetId_recorder {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (r *moqStore_GadgetsByWidgetId_recorder) seq() *moqStore_GadgetsByWidgetId_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqStore_GadgetsByWidgetId_recorder) noSeq() *moqStore_GadgetsByWidgetId_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqStore_GadgetsByWidgetId_recorder) returnResults(result1 []demo.Gadget, result2 error) *moqStore_GadgetsByWidgetId_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqStore_GadgetsByWidgetId_results{
		result1: result1,
		result2: result2,
	})
	return r
}

func (r *moqStore_GadgetsByWidgetId_recorder) andDo(fn moqStore_GadgetsByWidgetId_doFn) *moqStore_GadgetsByWidgetId_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqStore_GadgetsByWidgetId_params) {
		fn(params.widgetId)
	}, false) {
		return nil
	}
	return r
}

func (r *moqStore_GadgetsByWidgetId_recorder) doReturnResults(fn moqStore_GadgetsByWidgetId_doReturnFn) *moqStore_GadgetsByWidgetId_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqStore_GadgetsByWidgetId_params) *moqStore_GadgetsByWidgetId_results {
		result1, result2 := fn(params.widgetId)
		return &moqStore_GadgetsByWidgetId_results{
			result1: result1,
			result2: result2,
		}
	})
	return r
}

func (r *moqStore_GadgetsByWidgetId_recorder) repeat(repeaters ...moq.Repeater) *moqStore_GadgetsByWidgetId_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqStore_GadgetsByWidgetId_adaptor) PrettyParams(params moqStore_GadgetsByWidgetId_params) string {
	return fmt.Sprintf("GadgetsByWidgetId(%#v)", params.widgetId)
}

func (a *moqStore_GadgetsByWidgetId_adaptor) ParamsKey(params moqStore_GadgetsByWidgetId_params, anyParams uint64) moqStore_GadgetsByWidgetId_paramsKey {
	a.moq.moq_GadgetsByWidgetId.Scene.T.Helper()
	widgetIdUsed, widgetIdUsedHash := impl.ParamKey(
		params.widgetId, 1, a.moq.runtime.parameterIndexing.GadgetsByWidgetId.widgetId, anyParams)
	return moqStore_GadgetsByWidgetId_paramsKey{
		params: struct{ widgetId int }{
			widgetId: widgetIdUsed,
		},
		hashes: struct{ widgetId hash.Hash }{
			widgetId: widgetIdUsedHash,
		},
	}
}

func (m *moqStore_recorder) LightGadgetsByWidgetId(widgetId int, maxWeight uint32) *moqStore_LightGadgetsByWidgetId_recorder {
	return &moqStore_LightGadgetsByWidgetId_recorder{
		recorder: m.moq.moq_LightGadgetsByWidgetId.OnCall(moqStore_LightGadgetsByWidgetId_params{
			widgetId:  widgetId,
			maxWeight: maxWeight,
		}),
	}
}

func (r *moqStore_LightGadgetsByWidgetId_recorder) any() *moqStore_LightGadgetsByWidgetId_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqStore_LightGadgetsByWidgetId_anyParams{recorder: r}
}

func (a *moqStore_LightGadgetsByWidgetId_anyParams) widgetId() *moqStore_LightGadgetsByWidgetId_recorder {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (a *moqStore_LightGadgetsByWidgetId_anyParams) maxWeight() *moqStore_LightGadgetsByWidgetId_recorder {
	a.recorder.recorder.AnyParam(2)
	return a.recorder
}

func (r *moqStore_LightGadgetsByWidgetId_recorder) seq() *moqStore_LightGadgetsByWidgetId_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqStore_LightGadgetsByWidgetId_recorder) noSeq() *moqStore_LightGadgetsByWidgetId_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqStore_LightGadgetsByWidgetId_recorder) returnResults(result1 []demo.Gadget, result2 error) *moqStore_LightGadgetsByWidgetId_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqStore_LightGadgetsByWidgetId_results{
		result1: result1,
		result2: result2,
	})
	return r
}

func (r *moqStore_LightGadgetsByWidgetId_recorder) andDo(fn moqStore_LightGadgetsByWidgetId_doFn) *moqStore_LightGadgetsByWidgetId_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqStore_LightGadgetsByWidgetId_params) {
		fn(params.widgetId, params.maxWeight)
	}, false) {
		return nil
	}
	return r
}

func (r *moqStore_LightGadgetsByWidgetId_recorder) doReturnResults(fn moqStore_LightGadgetsByWidgetId_doReturnFn) *moqStore_LightGadgetsByWidgetId_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqStore_LightGadgetsByWidgetId_params) *moqStore_LightGadgetsByWidgetId_results {
		result1, result2 := fn(params.widgetId, params.maxWeight)
		return &moqStore_LightGadgetsByWidgetId_results{
			result1: result1,
			result2: result2,
		}
	})
	return r
}

func (r *moqStore_LightGadgetsByWidgetId_recorder) repeat(repeaters ...moq.Repeater) *moqStore_LightGadgetsByWidgetId_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqStore_LightGadgetsByWidgetId_adaptor) PrettyParams(params moqStore_LightGadgetsByWidgetId_params) string {
	return fmt.Sprintf("LightGadgetsByWidgetId(%#v, %#v)", params.widgetId, params.maxWeight)
}

func (a *moqStore_LightGadgetsByWidgetId_adaptor) ParamsKey(params moqStore_LightGadgetsByWidgetId_params, anyParams uint64) moqStore_LightGadgetsByWidgetId_paramsKey {
	a.moq.moq_LightGadgetsByWidgetId.Scene.T.Helper()
	widgetIdUsed, widgetIdUsedHash := impl.ParamKey(
		params.widgetId, 1, a.moq.runtime.parameterIndexing.LightGadgetsByWidgetId.widgetId, anyParams)
	maxWeightUsed, maxWeightUsedHash := impl.ParamKey(
		params.maxWeight, 2, a.moq.runtime.parameterIndexing.LightGadgetsByWidgetId.maxWeight, anyParams)
	return moqStore_LightGadgetsByWidgetId_paramsKey{
		params: struct {
			widgetId  int
			maxWeight uint32
		}{
			widgetId:  widgetIdUsed,
			maxWeight: maxWeightUsed,
		},
		hashes: struct {
			widgetId  hash.Hash
			maxWeight hash.Hash
		}{
			widgetId:  widgetIdUsedHash,
			maxWeight: maxWeightUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *moqStore) Reset() {
	m.moq_AllWidgetsIds.Reset()
	m.moq_GadgetsByWidgetId.Reset()
	m.moq_LightGadgetsByWidgetId.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *moqStore) AssertExpectationsMet() {
	m.moq_AllWidgetsIds.Scene.T.Helper()
	m.moq_AllWidgetsIds.AssertExpectationsMet()
	m.moq_GadgetsByWidgetId.AssertExpectationsMet()
	m.moq_LightGadgetsByWidgetId.AssertExpectationsMet()
}
