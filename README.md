# Moqueries - Lock-free interface and function mocks for Go
Moqueries makes mocks, but not just interface mocks &mdash; `moqueries` builds mocks for functions too. But these aren't your typical mocks!

Moqueries mocks are, as mentioned above, lock free. But they are also true to the interface and function types they mock &mdash; several mock generators record your intentions with method signatures like `DoIt(arg0, arg1, arg2 interface{})` when your interface is something like `DoIt(lFac, rFac *xyz.Factor, msg string)`. This applies to both parameters passed into the recorder and result values. Having a true implementation means that your IDE and the compiler both know what the types should be which saves time.

## Generating mocks
Mocks can generated by directly invoking `moqueries` from your terminal but typically you want to capture the command in a `//go:generate` directive. The following directive (in a working example [here](https://github.com/myshkin5/moqueries/blob/master/demo/demo.go#L9)) generates a mock for Go's ubiquitous [`io.Writer`](https://golang.org/pkg/io/#Writer) interface:
```go
//go:generate moqueries --destination moq_writer_test.go --import io Writer
```

Note that because of the `--destination` option, the mock is written to a file called [`moq_writer_test.go`](https://github.com/myshkin5/moqueries/blob/master/demo/moq_writer_test.go) in the same directory containing this directive. Also note that since we presumably didn't put this directive in Go's standard library `io` package, we have to include a `--import io` option so that Moqueries can find the interface.

Generating mocks for function types is just as easy. In [this example](https://github.com/myshkin5/moqueries/blob/master/demo/demo.go#L11-L13), we put the Go generate directive directly above the type definition (the best place for the directive unless you are mocking third-party types):
```go
//go:generate moqueries --destination moq_isfavorite_test.go IsFavorite

type IsFavorite func(n int) bool
```

## Using mocks

### Creating a mock instance
Code generation creates a `newMockXXX` function for each mock you generate. Simply [invoke the function and hold on to the mock](https://github.com/myshkin5/moqueries/blob/master/demo/demo_test.go#L15-L16) for further testing:
```go
isFavMock := newMockIsFavorite()
writerMock := newMockWriter()
```

### Expectations
To get a mock to perform specific behaviors, you have to tell it what to expect and how to behave. For function mocks, the `onCall` function (generated for you) has the same parameter signature as the function itself. The return value of the `onCall` function is a type that (via its `ret` method) informs the mock what to return when invoked with the given parameters. For our `IsFavorite` function mock, we can tell it to expect to be called with parameters `1`, `2` and then `3` but only `3` is our favorite number [like so](https://github.com/myshkin5/moqueries/blob/master/demo/demo_test.go#L18-L20):
```go
isFavMock.onCall(1).ret(false)
isFavMock.onCall(2).ret(false)
isFavMock.onCall(3).ret(true)
```

Working with interface mocks is very similar to working with function mocks. For interface mocks, the generated `onCall` method returns the expectation recorder of the mocked interface (a full implementation of the interface for recording expectations). For our `Writer` mock example, we can tell it to expect a call to `Write` with the [following call](https://github.com/myshkin5/moqueries/blob/master/demo/demo_test.go#L22):
```go
writerMock.onCall().Write([]byte("3"))
```

Note that in the above call, we didn't specify what to return (the `Write` function returns the number of bytes written and any error encountered). The mock returns zero values if none are specified in an expectation. To specify the return values, [use](https://github.com/myshkin5/moqueries/blob/master/demo/demo_test.go#L41) the generated `ret` method (in this example, we are saying we wrote 0 bytes, and we did get an error):
```go
writerMock.onCall().Write([]byte("3")).ret(0, errors.New("couldn't write"))
```

### Passing the mock to production code
Each mock gets a generated `mock` method. This function accesses the implementation of the interface or function invoked by production code. In [our example](https://github.com/myshkin5/moqueries/blob/master/demo/demo_test.go#L24-L27), we have a type called `FavWriter` that needs an `IsFavorite` function and a `Writer`:
```go
d := demo.FavWriter{
    IsFav: isFavMock.mock(),
    W:     writerMock.mock(),
}
```

## More command line options
Below is a loose collection of out-of-the-ordinary command line options for use in out-of-the-ordinary situations.

### Interfaces or functions in test packages
When the type you want to mock is defined in a test package, you can use one of the following two solutions:

1. Specify the test package (with its `_test` suffix) in the `--import` option:
    ```go
    //go:generate moqueries --destination moq_isfavorite_test.go --import github.com/myshkin5/moqueries/demo_test IsFavorite
    ```
   Note: This solution requires the `--import` option even if your Go generate directive is in the same package being imported.

   *_--- OR ---_*

1. Use the `--test-import` option:
    ```go
    //go:generate moqueries --destination moq_isfavorite_test.go --test-import IsFavorite
    ```

### Exported (public) mocks
Mocks are typically generated in the test package of the destination directory. This works well in most cases including when the code you want to test lives in the same package as the code you wan to mock out. When you have lots of different packages all using the same mocks, it's better to generate the mocks once and import the mocks where needed. This is where the `--export` command line option comes into play:
```go
//go:generate moqueries --destination moq_writer.go --export --import io Writer
```

Now all of the mock's structs and methods are exported, so they can be used from any package:

```go
writerMock := mockpkg.NewMockWriter()

writerMock.OnCall().Write([]byte("3")).Ret(0, errors.New("couldn't write"))
```
