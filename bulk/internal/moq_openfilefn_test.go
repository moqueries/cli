// Code generated by Moqueries - https://moqueries.org - DO NOT EDIT.

package internal_test

import (
	"fmt"
	"os"

	"moqueries.org/cli/bulk/internal"
	"moqueries.org/runtime/hash"
	"moqueries.org/runtime/impl"
	"moqueries.org/runtime/moq"
)

// moqOpenFileFn holds the state of a moq of the OpenFileFn type
type moqOpenFileFn struct {
	moq *impl.Moq[
		*moqOpenFileFn_adaptor,
		moqOpenFileFn_params,
		moqOpenFileFn_paramsKey,
		moqOpenFileFn_results,
	]

	runtime moqOpenFileFn_runtime
}

// moqOpenFileFn_runtime holds runtime configuration for the OpenFileFn type
type moqOpenFileFn_runtime struct {
	parameterIndexing moqOpenFileFn_paramIndexing
}

// moqOpenFileFn_adaptor adapts moqOpenFileFn as needed by the runtime
type moqOpenFileFn_adaptor struct {
	moq *moqOpenFileFn
}

// moqOpenFileFn_params holds the params of the OpenFileFn type
type moqOpenFileFn_params struct {
	name string
	flag int
	perm os.FileMode
}

// moqOpenFileFn_paramsKey holds the map key params of the OpenFileFn type
type moqOpenFileFn_paramsKey struct {
	params struct {
		name string
		flag int
		perm os.FileMode
	}
	hashes struct {
		name hash.Hash
		flag hash.Hash
		perm hash.Hash
	}
}

// moqOpenFileFn_results holds the results of the OpenFileFn type
type moqOpenFileFn_results struct {
	result1 internal.ReadWriteSeekCloser
	result2 error
}

// moqOpenFileFn_paramIndexing holds the parameter indexing runtime
// configuration for the OpenFileFn type
type moqOpenFileFn_paramIndexing struct {
	name moq.ParamIndexing
	flag moq.ParamIndexing
	perm moq.ParamIndexing
}

// moqOpenFileFn_doFn defines the type of function needed when calling andDo
// for the OpenFileFn type
type moqOpenFileFn_doFn func(name string, flag int, perm os.FileMode)

// moqOpenFileFn_doReturnFn defines the type of function needed when calling
// doReturnResults for the OpenFileFn type
type moqOpenFileFn_doReturnFn func(name string, flag int, perm os.FileMode) (internal.ReadWriteSeekCloser, error)

// moqOpenFileFn_recorder routes recorded function calls to the moqOpenFileFn
// moq
type moqOpenFileFn_recorder struct {
	recorder *impl.Recorder[
		*moqOpenFileFn_adaptor,
		moqOpenFileFn_params,
		moqOpenFileFn_paramsKey,
		moqOpenFileFn_results,
	]
}

// moqOpenFileFn_anyParams isolates the any params functions of the OpenFileFn
// type
type moqOpenFileFn_anyParams struct {
	recorder *moqOpenFileFn_recorder
}

// newMoqOpenFileFn creates a new moq of the OpenFileFn type
func newMoqOpenFileFn(scene *moq.Scene, config *moq.Config) *moqOpenFileFn {
	adaptor1 := &moqOpenFileFn_adaptor{}
	m := &moqOpenFileFn{
		moq: impl.NewMoq[
			*moqOpenFileFn_adaptor,
			moqOpenFileFn_params,
			moqOpenFileFn_paramsKey,
			moqOpenFileFn_results,
		](scene, adaptor1, config),

		runtime: moqOpenFileFn_runtime{parameterIndexing: moqOpenFileFn_paramIndexing{
			name: moq.ParamIndexByValue,
			flag: moq.ParamIndexByValue,
			perm: moq.ParamIndexByValue,
		}},
	}
	adaptor1.moq = m

	scene.AddMoq(m)
	return m
}

// mock returns the moq implementation of the OpenFileFn type
func (m *moqOpenFileFn) mock() internal.OpenFileFn {
	return func(name string, flag int, perm os.FileMode) (internal.ReadWriteSeekCloser, error) {
		m.moq.Scene.T.Helper()
		params := moqOpenFileFn_params{
			name: name,
			flag: flag,
			perm: perm,
		}

		var result1 internal.ReadWriteSeekCloser
		var result2 error
		if result := m.moq.Function(params); result != nil {
			result1 = result.result1
			result2 = result.result2
		}
		return result1, result2
	}
}

func (m *moqOpenFileFn) onCall(name string, flag int, perm os.FileMode) *moqOpenFileFn_recorder {
	return &moqOpenFileFn_recorder{
		recorder: m.moq.OnCall(moqOpenFileFn_params{
			name: name,
			flag: flag,
			perm: perm,
		}),
	}
}

func (r *moqOpenFileFn_recorder) any() *moqOpenFileFn_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqOpenFileFn_anyParams{recorder: r}
}

func (a *moqOpenFileFn_anyParams) name() *moqOpenFileFn_recorder {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (a *moqOpenFileFn_anyParams) flag() *moqOpenFileFn_recorder {
	a.recorder.recorder.AnyParam(2)
	return a.recorder
}

func (a *moqOpenFileFn_anyParams) perm() *moqOpenFileFn_recorder {
	a.recorder.recorder.AnyParam(3)
	return a.recorder
}

func (r *moqOpenFileFn_recorder) seq() *moqOpenFileFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqOpenFileFn_recorder) noSeq() *moqOpenFileFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqOpenFileFn_recorder) returnResults(result1 internal.ReadWriteSeekCloser, result2 error) *moqOpenFileFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqOpenFileFn_results{
		result1: result1,
		result2: result2,
	})
	return r
}

func (r *moqOpenFileFn_recorder) andDo(fn moqOpenFileFn_doFn) *moqOpenFileFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqOpenFileFn_params) {
		fn(params.name, params.flag, params.perm)
	}, false) {
		return nil
	}
	return r
}

func (r *moqOpenFileFn_recorder) doReturnResults(fn moqOpenFileFn_doReturnFn) *moqOpenFileFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqOpenFileFn_params) *moqOpenFileFn_results {
		result1, result2 := fn(params.name, params.flag, params.perm)
		return &moqOpenFileFn_results{
			result1: result1,
			result2: result2,
		}
	})
	return r
}

func (r *moqOpenFileFn_recorder) repeat(repeaters ...moq.Repeater) *moqOpenFileFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqOpenFileFn_adaptor) PrettyParams(params moqOpenFileFn_params) string {
	return fmt.Sprintf("OpenFileFn(%#v, %#v, %#v)", params.name, params.flag, params.perm)
}

func (a *moqOpenFileFn_adaptor) ParamsKey(params moqOpenFileFn_params, anyParams uint64) moqOpenFileFn_paramsKey {
	a.moq.moq.Scene.T.Helper()
	nameUsed, nameUsedHash := impl.ParamKey(
		params.name, 1, a.moq.runtime.parameterIndexing.name, anyParams)
	flagUsed, flagUsedHash := impl.ParamKey(
		params.flag, 2, a.moq.runtime.parameterIndexing.flag, anyParams)
	permUsed, permUsedHash := impl.ParamKey(
		params.perm, 3, a.moq.runtime.parameterIndexing.perm, anyParams)
	return moqOpenFileFn_paramsKey{
		params: struct {
			name string
			flag int
			perm os.FileMode
		}{
			name: nameUsed,
			flag: flagUsed,
			perm: permUsed,
		},
		hashes: struct {
			name hash.Hash
			flag hash.Hash
			perm hash.Hash
		}{
			name: nameUsedHash,
			flag: flagUsedHash,
			perm: permUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *moqOpenFileFn) Reset() {
	m.moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *moqOpenFileFn) AssertExpectationsMet() {
	m.moq.Scene.T.Helper()
	m.moq.AssertExpectationsMet()
}
