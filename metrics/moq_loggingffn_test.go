// Code generated by Moqueries - https://moqueries.org - DO NOT EDIT.

package metrics_test

import (
	"fmt"

	"moqueries.org/cli/metrics"
	"moqueries.org/runtime/hash"
	"moqueries.org/runtime/impl"
	"moqueries.org/runtime/moq"
)

// moqLoggingfFn holds the state of a moq of the LoggingfFn type
type moqLoggingfFn struct {
	moq *impl.Moq[
		*moqLoggingfFn_adaptor,
		moqLoggingfFn_params,
		moqLoggingfFn_paramsKey,
		moqLoggingfFn_results,
	]

	runtime moqLoggingfFn_runtime
}

// moqLoggingfFn_runtime holds runtime configuration for the LoggingfFn type
type moqLoggingfFn_runtime struct {
	parameterIndexing moqLoggingfFn_paramIndexing
}

// moqLoggingfFn_adaptor adapts moqLoggingfFn as needed by the runtime
type moqLoggingfFn_adaptor struct {
	moq *moqLoggingfFn
}

// moqLoggingfFn_params holds the params of the LoggingfFn type
type moqLoggingfFn_params struct {
	format string
	args   []interface{}
}

// moqLoggingfFn_paramsKey holds the map key params of the LoggingfFn type
type moqLoggingfFn_paramsKey struct {
	params struct{ format string }
	hashes struct {
		format hash.Hash
		args   hash.Hash
	}
}

// moqLoggingfFn_results holds the results of the LoggingfFn type
type moqLoggingfFn_results struct{}

// moqLoggingfFn_paramIndexing holds the parameter indexing runtime
// configuration for the LoggingfFn type
type moqLoggingfFn_paramIndexing struct {
	format moq.ParamIndexing
	args   moq.ParamIndexing
}

// moqLoggingfFn_doFn defines the type of function needed when calling andDo
// for the LoggingfFn type
type moqLoggingfFn_doFn func(format string, args ...interface{})

// moqLoggingfFn_doReturnFn defines the type of function needed when calling
// doReturnResults for the LoggingfFn type
type moqLoggingfFn_doReturnFn func(format string, args ...interface{})

// moqLoggingfFn_recorder routes recorded function calls to the moqLoggingfFn
// moq
type moqLoggingfFn_recorder struct {
	recorder *impl.Recorder[
		*moqLoggingfFn_adaptor,
		moqLoggingfFn_params,
		moqLoggingfFn_paramsKey,
		moqLoggingfFn_results,
	]
}

// moqLoggingfFn_anyParams isolates the any params functions of the LoggingfFn
// type
type moqLoggingfFn_anyParams struct {
	recorder *moqLoggingfFn_recorder
}

// newMoqLoggingfFn creates a new moq of the LoggingfFn type
func newMoqLoggingfFn(scene *moq.Scene, config *moq.Config) *moqLoggingfFn {
	adaptor1 := &moqLoggingfFn_adaptor{}
	m := &moqLoggingfFn{
		moq: impl.NewMoq[
			*moqLoggingfFn_adaptor,
			moqLoggingfFn_params,
			moqLoggingfFn_paramsKey,
			moqLoggingfFn_results,
		](scene, adaptor1, config),

		runtime: moqLoggingfFn_runtime{parameterIndexing: moqLoggingfFn_paramIndexing{
			format: moq.ParamIndexByValue,
			args:   moq.ParamIndexByHash,
		}},
	}
	adaptor1.moq = m

	scene.AddMoq(m)
	return m
}

// mock returns the moq implementation of the LoggingfFn type
func (m *moqLoggingfFn) mock() metrics.LoggingfFn {
	return func(format string, args ...interface{}) {
		m.moq.Scene.T.Helper()
		params := moqLoggingfFn_params{
			format: format,
			args:   args,
		}

		m.moq.Function(params)
	}
}

func (m *moqLoggingfFn) onCall(format string, args ...interface{}) *moqLoggingfFn_recorder {
	return &moqLoggingfFn_recorder{
		recorder: m.moq.OnCall(moqLoggingfFn_params{
			format: format,
			args:   args,
		}),
	}
}

func (r *moqLoggingfFn_recorder) any() *moqLoggingfFn_anyParams {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.IsAnyPermitted(false) {
		return nil
	}
	return &moqLoggingfFn_anyParams{recorder: r}
}

func (a *moqLoggingfFn_anyParams) format() *moqLoggingfFn_recorder {
	a.recorder.recorder.AnyParam(1)
	return a.recorder
}

func (a *moqLoggingfFn_anyParams) args() *moqLoggingfFn_recorder {
	a.recorder.recorder.AnyParam(2)
	return a.recorder
}

func (r *moqLoggingfFn_recorder) seq() *moqLoggingfFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(true, "seq", false) {
		return nil
	}
	return r
}

func (r *moqLoggingfFn_recorder) noSeq() *moqLoggingfFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Seq(false, "noSeq", false) {
		return nil
	}
	return r
}

func (r *moqLoggingfFn_recorder) returnResults() *moqLoggingfFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.ReturnResults(moqLoggingfFn_results{})
	return r
}

func (r *moqLoggingfFn_recorder) andDo(fn moqLoggingfFn_doFn) *moqLoggingfFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.AndDo(func(params moqLoggingfFn_params) {
		fn(params.format, params.args...)
	}, false) {
		return nil
	}
	return r
}

func (r *moqLoggingfFn_recorder) doReturnResults(fn moqLoggingfFn_doReturnFn) *moqLoggingfFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	r.recorder.DoReturnResults(func(params moqLoggingfFn_params) *moqLoggingfFn_results {
		fn(params.format, params.args...)
		return &moqLoggingfFn_results{}
	})
	return r
}

func (r *moqLoggingfFn_recorder) repeat(repeaters ...moq.Repeater) *moqLoggingfFn_recorder {
	r.recorder.Moq.Scene.T.Helper()
	if !r.recorder.Repeat(repeaters, false) {
		return nil
	}
	return r
}

func (*moqLoggingfFn_adaptor) PrettyParams(params moqLoggingfFn_params) string {
	return fmt.Sprintf("LoggingfFn(%#v, %#v)", params.format, params.args)
}

func (a *moqLoggingfFn_adaptor) ParamsKey(params moqLoggingfFn_params, anyParams uint64) moqLoggingfFn_paramsKey {
	a.moq.moq.Scene.T.Helper()
	formatUsed, formatUsedHash := impl.ParamKey(
		params.format, 1, a.moq.runtime.parameterIndexing.format, anyParams)
	argsUsedHash := impl.HashOnlyParamKey(a.moq.moq.Scene.T,
		params.args, "args", 2, a.moq.runtime.parameterIndexing.args, anyParams)
	return moqLoggingfFn_paramsKey{
		params: struct{ format string }{
			format: formatUsed,
		},
		hashes: struct {
			format hash.Hash
			args   hash.Hash
		}{
			format: formatUsedHash,
			args:   argsUsedHash,
		},
	}
}

// Reset resets the state of the moq
func (m *moqLoggingfFn) Reset() {
	m.moq.Reset()
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *moqLoggingfFn) AssertExpectationsMet() {
	m.moq.Scene.T.Helper()
	m.moq.AssertExpectationsMet()
}
