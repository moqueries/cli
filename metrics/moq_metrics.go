// Code generated by Moqueries - https://moqueries.org - DO NOT EDIT!

package metrics

import (
	"fmt"
	"math/bits"
	"sync/atomic"
	"time"

	"moqueries.org/cli/hash"
	"moqueries.org/cli/moq"
)

// The following type assertion assures that metrics.Metrics is mocked
// completely
var _ Metrics = (*MoqMetrics_mock)(nil)

// MoqMetrics holds the state of a moq of the Metrics type
type MoqMetrics struct {
	Scene  *moq.Scene
	Config moq.Config
	Moq    *MoqMetrics_mock

	ResultsByParams_ASTPkgCacheHitsInc        []MoqMetrics_ASTPkgCacheHitsInc_resultsByParams
	ResultsByParams_ASTPkgCacheMissesInc      []MoqMetrics_ASTPkgCacheMissesInc_resultsByParams
	ResultsByParams_ASTTypeCacheHitsInc       []MoqMetrics_ASTTypeCacheHitsInc_resultsByParams
	ResultsByParams_ASTTypeCacheMissesInc     []MoqMetrics_ASTTypeCacheMissesInc_resultsByParams
	ResultsByParams_ASTTotalLoadTimeInc       []MoqMetrics_ASTTotalLoadTimeInc_resultsByParams
	ResultsByParams_ASTTotalDecorationTimeInc []MoqMetrics_ASTTotalDecorationTimeInc_resultsByParams
	ResultsByParams_TotalProcessingTimeInc    []MoqMetrics_TotalProcessingTimeInc_resultsByParams
	ResultsByParams_Finalize                  []MoqMetrics_Finalize_resultsByParams

	Runtime struct {
		ParameterIndexing struct {
			ASTPkgCacheHitsInc    struct{}
			ASTPkgCacheMissesInc  struct{}
			ASTTypeCacheHitsInc   struct{}
			ASTTypeCacheMissesInc struct{}
			ASTTotalLoadTimeInc   struct {
				D moq.ParamIndexing
			}
			ASTTotalDecorationTimeInc struct {
				D moq.ParamIndexing
			}
			TotalProcessingTimeInc struct {
				D moq.ParamIndexing
			}
			Finalize struct{}
		}
	}
}

// MoqMetrics_mock isolates the mock interface of the Metrics type
type MoqMetrics_mock struct {
	Moq *MoqMetrics
}

// MoqMetrics_recorder isolates the recorder interface of the Metrics type
type MoqMetrics_recorder struct {
	Moq *MoqMetrics
}

// MoqMetrics_ASTPkgCacheHitsInc_params holds the params of the Metrics type
type MoqMetrics_ASTPkgCacheHitsInc_params struct{}

// MoqMetrics_ASTPkgCacheHitsInc_paramsKey holds the map key params of the
// Metrics type
type MoqMetrics_ASTPkgCacheHitsInc_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqMetrics_ASTPkgCacheHitsInc_resultsByParams contains the results for a
// given set of parameters for the Metrics type
type MoqMetrics_ASTPkgCacheHitsInc_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqMetrics_ASTPkgCacheHitsInc_paramsKey]*MoqMetrics_ASTPkgCacheHitsInc_results
}

// MoqMetrics_ASTPkgCacheHitsInc_doFn defines the type of function needed when
// calling AndDo for the Metrics type
type MoqMetrics_ASTPkgCacheHitsInc_doFn func()

// MoqMetrics_ASTPkgCacheHitsInc_doReturnFn defines the type of function needed
// when calling DoReturnResults for the Metrics type
type MoqMetrics_ASTPkgCacheHitsInc_doReturnFn func()

// MoqMetrics_ASTPkgCacheHitsInc_results holds the results of the Metrics type
type MoqMetrics_ASTPkgCacheHitsInc_results struct {
	Params  MoqMetrics_ASTPkgCacheHitsInc_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqMetrics_ASTPkgCacheHitsInc_doFn
		DoReturnFn MoqMetrics_ASTPkgCacheHitsInc_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqMetrics_ASTPkgCacheHitsInc_fnRecorder routes recorded function calls to
// the MoqMetrics moq
type MoqMetrics_ASTPkgCacheHitsInc_fnRecorder struct {
	Params    MoqMetrics_ASTPkgCacheHitsInc_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqMetrics_ASTPkgCacheHitsInc_results
	Moq       *MoqMetrics
}

// MoqMetrics_ASTPkgCacheHitsInc_anyParams isolates the any params functions of
// the Metrics type
type MoqMetrics_ASTPkgCacheHitsInc_anyParams struct {
	Recorder *MoqMetrics_ASTPkgCacheHitsInc_fnRecorder
}

// MoqMetrics_ASTPkgCacheMissesInc_params holds the params of the Metrics type
type MoqMetrics_ASTPkgCacheMissesInc_params struct{}

// MoqMetrics_ASTPkgCacheMissesInc_paramsKey holds the map key params of the
// Metrics type
type MoqMetrics_ASTPkgCacheMissesInc_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqMetrics_ASTPkgCacheMissesInc_resultsByParams contains the results for a
// given set of parameters for the Metrics type
type MoqMetrics_ASTPkgCacheMissesInc_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqMetrics_ASTPkgCacheMissesInc_paramsKey]*MoqMetrics_ASTPkgCacheMissesInc_results
}

// MoqMetrics_ASTPkgCacheMissesInc_doFn defines the type of function needed
// when calling AndDo for the Metrics type
type MoqMetrics_ASTPkgCacheMissesInc_doFn func()

// MoqMetrics_ASTPkgCacheMissesInc_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Metrics type
type MoqMetrics_ASTPkgCacheMissesInc_doReturnFn func()

// MoqMetrics_ASTPkgCacheMissesInc_results holds the results of the Metrics
// type
type MoqMetrics_ASTPkgCacheMissesInc_results struct {
	Params  MoqMetrics_ASTPkgCacheMissesInc_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqMetrics_ASTPkgCacheMissesInc_doFn
		DoReturnFn MoqMetrics_ASTPkgCacheMissesInc_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqMetrics_ASTPkgCacheMissesInc_fnRecorder routes recorded function calls to
// the MoqMetrics moq
type MoqMetrics_ASTPkgCacheMissesInc_fnRecorder struct {
	Params    MoqMetrics_ASTPkgCacheMissesInc_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqMetrics_ASTPkgCacheMissesInc_results
	Moq       *MoqMetrics
}

// MoqMetrics_ASTPkgCacheMissesInc_anyParams isolates the any params functions
// of the Metrics type
type MoqMetrics_ASTPkgCacheMissesInc_anyParams struct {
	Recorder *MoqMetrics_ASTPkgCacheMissesInc_fnRecorder
}

// MoqMetrics_ASTTypeCacheHitsInc_params holds the params of the Metrics type
type MoqMetrics_ASTTypeCacheHitsInc_params struct{}

// MoqMetrics_ASTTypeCacheHitsInc_paramsKey holds the map key params of the
// Metrics type
type MoqMetrics_ASTTypeCacheHitsInc_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqMetrics_ASTTypeCacheHitsInc_resultsByParams contains the results for a
// given set of parameters for the Metrics type
type MoqMetrics_ASTTypeCacheHitsInc_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqMetrics_ASTTypeCacheHitsInc_paramsKey]*MoqMetrics_ASTTypeCacheHitsInc_results
}

// MoqMetrics_ASTTypeCacheHitsInc_doFn defines the type of function needed when
// calling AndDo for the Metrics type
type MoqMetrics_ASTTypeCacheHitsInc_doFn func()

// MoqMetrics_ASTTypeCacheHitsInc_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Metrics type
type MoqMetrics_ASTTypeCacheHitsInc_doReturnFn func()

// MoqMetrics_ASTTypeCacheHitsInc_results holds the results of the Metrics type
type MoqMetrics_ASTTypeCacheHitsInc_results struct {
	Params  MoqMetrics_ASTTypeCacheHitsInc_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqMetrics_ASTTypeCacheHitsInc_doFn
		DoReturnFn MoqMetrics_ASTTypeCacheHitsInc_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqMetrics_ASTTypeCacheHitsInc_fnRecorder routes recorded function calls to
// the MoqMetrics moq
type MoqMetrics_ASTTypeCacheHitsInc_fnRecorder struct {
	Params    MoqMetrics_ASTTypeCacheHitsInc_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqMetrics_ASTTypeCacheHitsInc_results
	Moq       *MoqMetrics
}

// MoqMetrics_ASTTypeCacheHitsInc_anyParams isolates the any params functions
// of the Metrics type
type MoqMetrics_ASTTypeCacheHitsInc_anyParams struct {
	Recorder *MoqMetrics_ASTTypeCacheHitsInc_fnRecorder
}

// MoqMetrics_ASTTypeCacheMissesInc_params holds the params of the Metrics type
type MoqMetrics_ASTTypeCacheMissesInc_params struct{}

// MoqMetrics_ASTTypeCacheMissesInc_paramsKey holds the map key params of the
// Metrics type
type MoqMetrics_ASTTypeCacheMissesInc_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqMetrics_ASTTypeCacheMissesInc_resultsByParams contains the results for a
// given set of parameters for the Metrics type
type MoqMetrics_ASTTypeCacheMissesInc_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqMetrics_ASTTypeCacheMissesInc_paramsKey]*MoqMetrics_ASTTypeCacheMissesInc_results
}

// MoqMetrics_ASTTypeCacheMissesInc_doFn defines the type of function needed
// when calling AndDo for the Metrics type
type MoqMetrics_ASTTypeCacheMissesInc_doFn func()

// MoqMetrics_ASTTypeCacheMissesInc_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Metrics type
type MoqMetrics_ASTTypeCacheMissesInc_doReturnFn func()

// MoqMetrics_ASTTypeCacheMissesInc_results holds the results of the Metrics
// type
type MoqMetrics_ASTTypeCacheMissesInc_results struct {
	Params  MoqMetrics_ASTTypeCacheMissesInc_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqMetrics_ASTTypeCacheMissesInc_doFn
		DoReturnFn MoqMetrics_ASTTypeCacheMissesInc_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqMetrics_ASTTypeCacheMissesInc_fnRecorder routes recorded function calls
// to the MoqMetrics moq
type MoqMetrics_ASTTypeCacheMissesInc_fnRecorder struct {
	Params    MoqMetrics_ASTTypeCacheMissesInc_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqMetrics_ASTTypeCacheMissesInc_results
	Moq       *MoqMetrics
}

// MoqMetrics_ASTTypeCacheMissesInc_anyParams isolates the any params functions
// of the Metrics type
type MoqMetrics_ASTTypeCacheMissesInc_anyParams struct {
	Recorder *MoqMetrics_ASTTypeCacheMissesInc_fnRecorder
}

// MoqMetrics_ASTTotalLoadTimeInc_params holds the params of the Metrics type
type MoqMetrics_ASTTotalLoadTimeInc_params struct{ D time.Duration }

// MoqMetrics_ASTTotalLoadTimeInc_paramsKey holds the map key params of the
// Metrics type
type MoqMetrics_ASTTotalLoadTimeInc_paramsKey struct {
	Params struct{ D time.Duration }
	Hashes struct{ D hash.Hash }
}

// MoqMetrics_ASTTotalLoadTimeInc_resultsByParams contains the results for a
// given set of parameters for the Metrics type
type MoqMetrics_ASTTotalLoadTimeInc_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqMetrics_ASTTotalLoadTimeInc_paramsKey]*MoqMetrics_ASTTotalLoadTimeInc_results
}

// MoqMetrics_ASTTotalLoadTimeInc_doFn defines the type of function needed when
// calling AndDo for the Metrics type
type MoqMetrics_ASTTotalLoadTimeInc_doFn func(d time.Duration)

// MoqMetrics_ASTTotalLoadTimeInc_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Metrics type
type MoqMetrics_ASTTotalLoadTimeInc_doReturnFn func(d time.Duration)

// MoqMetrics_ASTTotalLoadTimeInc_results holds the results of the Metrics type
type MoqMetrics_ASTTotalLoadTimeInc_results struct {
	Params  MoqMetrics_ASTTotalLoadTimeInc_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqMetrics_ASTTotalLoadTimeInc_doFn
		DoReturnFn MoqMetrics_ASTTotalLoadTimeInc_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqMetrics_ASTTotalLoadTimeInc_fnRecorder routes recorded function calls to
// the MoqMetrics moq
type MoqMetrics_ASTTotalLoadTimeInc_fnRecorder struct {
	Params    MoqMetrics_ASTTotalLoadTimeInc_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqMetrics_ASTTotalLoadTimeInc_results
	Moq       *MoqMetrics
}

// MoqMetrics_ASTTotalLoadTimeInc_anyParams isolates the any params functions
// of the Metrics type
type MoqMetrics_ASTTotalLoadTimeInc_anyParams struct {
	Recorder *MoqMetrics_ASTTotalLoadTimeInc_fnRecorder
}

// MoqMetrics_ASTTotalDecorationTimeInc_params holds the params of the Metrics
// type
type MoqMetrics_ASTTotalDecorationTimeInc_params struct{ D time.Duration }

// MoqMetrics_ASTTotalDecorationTimeInc_paramsKey holds the map key params of
// the Metrics type
type MoqMetrics_ASTTotalDecorationTimeInc_paramsKey struct {
	Params struct{ D time.Duration }
	Hashes struct{ D hash.Hash }
}

// MoqMetrics_ASTTotalDecorationTimeInc_resultsByParams contains the results
// for a given set of parameters for the Metrics type
type MoqMetrics_ASTTotalDecorationTimeInc_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqMetrics_ASTTotalDecorationTimeInc_paramsKey]*MoqMetrics_ASTTotalDecorationTimeInc_results
}

// MoqMetrics_ASTTotalDecorationTimeInc_doFn defines the type of function
// needed when calling AndDo for the Metrics type
type MoqMetrics_ASTTotalDecorationTimeInc_doFn func(d time.Duration)

// MoqMetrics_ASTTotalDecorationTimeInc_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Metrics type
type MoqMetrics_ASTTotalDecorationTimeInc_doReturnFn func(d time.Duration)

// MoqMetrics_ASTTotalDecorationTimeInc_results holds the results of the
// Metrics type
type MoqMetrics_ASTTotalDecorationTimeInc_results struct {
	Params  MoqMetrics_ASTTotalDecorationTimeInc_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqMetrics_ASTTotalDecorationTimeInc_doFn
		DoReturnFn MoqMetrics_ASTTotalDecorationTimeInc_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqMetrics_ASTTotalDecorationTimeInc_fnRecorder routes recorded function
// calls to the MoqMetrics moq
type MoqMetrics_ASTTotalDecorationTimeInc_fnRecorder struct {
	Params    MoqMetrics_ASTTotalDecorationTimeInc_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqMetrics_ASTTotalDecorationTimeInc_results
	Moq       *MoqMetrics
}

// MoqMetrics_ASTTotalDecorationTimeInc_anyParams isolates the any params
// functions of the Metrics type
type MoqMetrics_ASTTotalDecorationTimeInc_anyParams struct {
	Recorder *MoqMetrics_ASTTotalDecorationTimeInc_fnRecorder
}

// MoqMetrics_TotalProcessingTimeInc_params holds the params of the Metrics
// type
type MoqMetrics_TotalProcessingTimeInc_params struct{ D time.Duration }

// MoqMetrics_TotalProcessingTimeInc_paramsKey holds the map key params of the
// Metrics type
type MoqMetrics_TotalProcessingTimeInc_paramsKey struct {
	Params struct{ D time.Duration }
	Hashes struct{ D hash.Hash }
}

// MoqMetrics_TotalProcessingTimeInc_resultsByParams contains the results for a
// given set of parameters for the Metrics type
type MoqMetrics_TotalProcessingTimeInc_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqMetrics_TotalProcessingTimeInc_paramsKey]*MoqMetrics_TotalProcessingTimeInc_results
}

// MoqMetrics_TotalProcessingTimeInc_doFn defines the type of function needed
// when calling AndDo for the Metrics type
type MoqMetrics_TotalProcessingTimeInc_doFn func(d time.Duration)

// MoqMetrics_TotalProcessingTimeInc_doReturnFn defines the type of function
// needed when calling DoReturnResults for the Metrics type
type MoqMetrics_TotalProcessingTimeInc_doReturnFn func(d time.Duration)

// MoqMetrics_TotalProcessingTimeInc_results holds the results of the Metrics
// type
type MoqMetrics_TotalProcessingTimeInc_results struct {
	Params  MoqMetrics_TotalProcessingTimeInc_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqMetrics_TotalProcessingTimeInc_doFn
		DoReturnFn MoqMetrics_TotalProcessingTimeInc_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqMetrics_TotalProcessingTimeInc_fnRecorder routes recorded function calls
// to the MoqMetrics moq
type MoqMetrics_TotalProcessingTimeInc_fnRecorder struct {
	Params    MoqMetrics_TotalProcessingTimeInc_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqMetrics_TotalProcessingTimeInc_results
	Moq       *MoqMetrics
}

// MoqMetrics_TotalProcessingTimeInc_anyParams isolates the any params
// functions of the Metrics type
type MoqMetrics_TotalProcessingTimeInc_anyParams struct {
	Recorder *MoqMetrics_TotalProcessingTimeInc_fnRecorder
}

// MoqMetrics_Finalize_params holds the params of the Metrics type
type MoqMetrics_Finalize_params struct{}

// MoqMetrics_Finalize_paramsKey holds the map key params of the Metrics type
type MoqMetrics_Finalize_paramsKey struct {
	Params struct{}
	Hashes struct{}
}

// MoqMetrics_Finalize_resultsByParams contains the results for a given set of
// parameters for the Metrics type
type MoqMetrics_Finalize_resultsByParams struct {
	AnyCount  int
	AnyParams uint64
	Results   map[MoqMetrics_Finalize_paramsKey]*MoqMetrics_Finalize_results
}

// MoqMetrics_Finalize_doFn defines the type of function needed when calling
// AndDo for the Metrics type
type MoqMetrics_Finalize_doFn func()

// MoqMetrics_Finalize_doReturnFn defines the type of function needed when
// calling DoReturnResults for the Metrics type
type MoqMetrics_Finalize_doReturnFn func()

// MoqMetrics_Finalize_results holds the results of the Metrics type
type MoqMetrics_Finalize_results struct {
	Params  MoqMetrics_Finalize_params
	Results []struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqMetrics_Finalize_doFn
		DoReturnFn MoqMetrics_Finalize_doReturnFn
	}
	Index  uint32
	Repeat *moq.RepeatVal
}

// MoqMetrics_Finalize_fnRecorder routes recorded function calls to the
// MoqMetrics moq
type MoqMetrics_Finalize_fnRecorder struct {
	Params    MoqMetrics_Finalize_params
	AnyParams uint64
	Sequence  bool
	Results   *MoqMetrics_Finalize_results
	Moq       *MoqMetrics
}

// MoqMetrics_Finalize_anyParams isolates the any params functions of the
// Metrics type
type MoqMetrics_Finalize_anyParams struct {
	Recorder *MoqMetrics_Finalize_fnRecorder
}

// NewMoqMetrics creates a new moq of the Metrics type
func NewMoqMetrics(scene *moq.Scene, config *moq.Config) *MoqMetrics {
	if config == nil {
		config = &moq.Config{}
	}
	m := &MoqMetrics{
		Scene:  scene,
		Config: *config,
		Moq:    &MoqMetrics_mock{},

		Runtime: struct {
			ParameterIndexing struct {
				ASTPkgCacheHitsInc    struct{}
				ASTPkgCacheMissesInc  struct{}
				ASTTypeCacheHitsInc   struct{}
				ASTTypeCacheMissesInc struct{}
				ASTTotalLoadTimeInc   struct {
					D moq.ParamIndexing
				}
				ASTTotalDecorationTimeInc struct {
					D moq.ParamIndexing
				}
				TotalProcessingTimeInc struct {
					D moq.ParamIndexing
				}
				Finalize struct{}
			}
		}{ParameterIndexing: struct {
			ASTPkgCacheHitsInc    struct{}
			ASTPkgCacheMissesInc  struct{}
			ASTTypeCacheHitsInc   struct{}
			ASTTypeCacheMissesInc struct{}
			ASTTotalLoadTimeInc   struct {
				D moq.ParamIndexing
			}
			ASTTotalDecorationTimeInc struct {
				D moq.ParamIndexing
			}
			TotalProcessingTimeInc struct {
				D moq.ParamIndexing
			}
			Finalize struct{}
		}{
			ASTPkgCacheHitsInc:    struct{}{},
			ASTPkgCacheMissesInc:  struct{}{},
			ASTTypeCacheHitsInc:   struct{}{},
			ASTTypeCacheMissesInc: struct{}{},
			ASTTotalLoadTimeInc: struct {
				D moq.ParamIndexing
			}{
				D: moq.ParamIndexByValue,
			},
			ASTTotalDecorationTimeInc: struct {
				D moq.ParamIndexing
			}{
				D: moq.ParamIndexByValue,
			},
			TotalProcessingTimeInc: struct {
				D moq.ParamIndexing
			}{
				D: moq.ParamIndexByValue,
			},
			Finalize: struct{}{},
		}},
	}
	m.Moq.Moq = m

	scene.AddMoq(m)
	return m
}

// Mock returns the mock implementation of the Metrics type
func (m *MoqMetrics) Mock() *MoqMetrics_mock { return m.Moq }

func (m *MoqMetrics_mock) ASTPkgCacheHitsInc() {
	m.Moq.Scene.T.Helper()
	params := MoqMetrics_ASTPkgCacheHitsInc_params{}
	var results *MoqMetrics_ASTPkgCacheHitsInc_results
	for _, resultsByParams := range m.Moq.ResultsByParams_ASTPkgCacheHitsInc {
		paramsKey := m.Moq.ParamsKey_ASTPkgCacheHitsInc(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_ASTPkgCacheHitsInc(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_ASTPkgCacheHitsInc(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_ASTPkgCacheHitsInc(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn()
	}
	return
}

func (m *MoqMetrics_mock) ASTPkgCacheMissesInc() {
	m.Moq.Scene.T.Helper()
	params := MoqMetrics_ASTPkgCacheMissesInc_params{}
	var results *MoqMetrics_ASTPkgCacheMissesInc_results
	for _, resultsByParams := range m.Moq.ResultsByParams_ASTPkgCacheMissesInc {
		paramsKey := m.Moq.ParamsKey_ASTPkgCacheMissesInc(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_ASTPkgCacheMissesInc(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_ASTPkgCacheMissesInc(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_ASTPkgCacheMissesInc(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn()
	}
	return
}

func (m *MoqMetrics_mock) ASTTypeCacheHitsInc() {
	m.Moq.Scene.T.Helper()
	params := MoqMetrics_ASTTypeCacheHitsInc_params{}
	var results *MoqMetrics_ASTTypeCacheHitsInc_results
	for _, resultsByParams := range m.Moq.ResultsByParams_ASTTypeCacheHitsInc {
		paramsKey := m.Moq.ParamsKey_ASTTypeCacheHitsInc(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_ASTTypeCacheHitsInc(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_ASTTypeCacheHitsInc(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_ASTTypeCacheHitsInc(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn()
	}
	return
}

func (m *MoqMetrics_mock) ASTTypeCacheMissesInc() {
	m.Moq.Scene.T.Helper()
	params := MoqMetrics_ASTTypeCacheMissesInc_params{}
	var results *MoqMetrics_ASTTypeCacheMissesInc_results
	for _, resultsByParams := range m.Moq.ResultsByParams_ASTTypeCacheMissesInc {
		paramsKey := m.Moq.ParamsKey_ASTTypeCacheMissesInc(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_ASTTypeCacheMissesInc(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_ASTTypeCacheMissesInc(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_ASTTypeCacheMissesInc(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn()
	}
	return
}

func (m *MoqMetrics_mock) ASTTotalLoadTimeInc(d time.Duration) {
	m.Moq.Scene.T.Helper()
	params := MoqMetrics_ASTTotalLoadTimeInc_params{
		D: d,
	}
	var results *MoqMetrics_ASTTotalLoadTimeInc_results
	for _, resultsByParams := range m.Moq.ResultsByParams_ASTTotalLoadTimeInc {
		paramsKey := m.Moq.ParamsKey_ASTTotalLoadTimeInc(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_ASTTotalLoadTimeInc(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_ASTTotalLoadTimeInc(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_ASTTotalLoadTimeInc(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(d)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(d)
	}
	return
}

func (m *MoqMetrics_mock) ASTTotalDecorationTimeInc(d time.Duration) {
	m.Moq.Scene.T.Helper()
	params := MoqMetrics_ASTTotalDecorationTimeInc_params{
		D: d,
	}
	var results *MoqMetrics_ASTTotalDecorationTimeInc_results
	for _, resultsByParams := range m.Moq.ResultsByParams_ASTTotalDecorationTimeInc {
		paramsKey := m.Moq.ParamsKey_ASTTotalDecorationTimeInc(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_ASTTotalDecorationTimeInc(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_ASTTotalDecorationTimeInc(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_ASTTotalDecorationTimeInc(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(d)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(d)
	}
	return
}

func (m *MoqMetrics_mock) TotalProcessingTimeInc(d time.Duration) {
	m.Moq.Scene.T.Helper()
	params := MoqMetrics_TotalProcessingTimeInc_params{
		D: d,
	}
	var results *MoqMetrics_TotalProcessingTimeInc_results
	for _, resultsByParams := range m.Moq.ResultsByParams_TotalProcessingTimeInc {
		paramsKey := m.Moq.ParamsKey_TotalProcessingTimeInc(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_TotalProcessingTimeInc(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_TotalProcessingTimeInc(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_TotalProcessingTimeInc(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn(d)
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn(d)
	}
	return
}

func (m *MoqMetrics_mock) Finalize() {
	m.Moq.Scene.T.Helper()
	params := MoqMetrics_Finalize_params{}
	var results *MoqMetrics_Finalize_results
	for _, resultsByParams := range m.Moq.ResultsByParams_Finalize {
		paramsKey := m.Moq.ParamsKey_Finalize(params, resultsByParams.AnyParams)
		var ok bool
		results, ok = resultsByParams.Results[paramsKey]
		if ok {
			break
		}
	}
	if results == nil {
		if m.Moq.Config.Expectation == moq.Strict {
			m.Moq.Scene.T.Fatalf("Unexpected call to %s", m.Moq.PrettyParams_Finalize(params))
		}
		return
	}

	i := int(atomic.AddUint32(&results.Index, 1)) - 1
	if i >= results.Repeat.ResultCount {
		if !results.Repeat.AnyTimes {
			if m.Moq.Config.Expectation == moq.Strict {
				m.Moq.Scene.T.Fatalf("Too many calls to %s", m.Moq.PrettyParams_Finalize(params))
			}
			return
		}
		i = results.Repeat.ResultCount - 1
	}

	result := results.Results[i]
	if result.Sequence != 0 {
		sequence := m.Moq.Scene.NextMockSequence()
		if (!results.Repeat.AnyTimes && result.Sequence != sequence) || result.Sequence > sequence {
			m.Moq.Scene.T.Fatalf("Call sequence does not match call to %s", m.Moq.PrettyParams_Finalize(params))
		}
	}

	if result.DoFn != nil {
		result.DoFn()
	}

	if result.DoReturnFn != nil {
		result.DoReturnFn()
	}
	return
}

// OnCall returns the recorder implementation of the Metrics type
func (m *MoqMetrics) OnCall() *MoqMetrics_recorder {
	return &MoqMetrics_recorder{
		Moq: m,
	}
}

func (m *MoqMetrics_recorder) ASTPkgCacheHitsInc() *MoqMetrics_ASTPkgCacheHitsInc_fnRecorder {
	return &MoqMetrics_ASTPkgCacheHitsInc_fnRecorder{
		Params:   MoqMetrics_ASTPkgCacheHitsInc_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqMetrics_ASTPkgCacheHitsInc_fnRecorder) Any() *MoqMetrics_ASTPkgCacheHitsInc_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ASTPkgCacheHitsInc(r.Params))
		return nil
	}
	return &MoqMetrics_ASTPkgCacheHitsInc_anyParams{Recorder: r}
}

func (r *MoqMetrics_ASTPkgCacheHitsInc_fnRecorder) Seq() *MoqMetrics_ASTPkgCacheHitsInc_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ASTPkgCacheHitsInc(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqMetrics_ASTPkgCacheHitsInc_fnRecorder) NoSeq() *MoqMetrics_ASTPkgCacheHitsInc_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ASTPkgCacheHitsInc(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqMetrics_ASTPkgCacheHitsInc_fnRecorder) ReturnResults() *MoqMetrics_ASTPkgCacheHitsInc_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqMetrics_ASTPkgCacheHitsInc_doFn
		DoReturnFn MoqMetrics_ASTPkgCacheHitsInc_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqMetrics_ASTPkgCacheHitsInc_fnRecorder) AndDo(fn MoqMetrics_ASTPkgCacheHitsInc_doFn) *MoqMetrics_ASTPkgCacheHitsInc_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqMetrics_ASTPkgCacheHitsInc_fnRecorder) DoReturnResults(fn MoqMetrics_ASTPkgCacheHitsInc_doReturnFn) *MoqMetrics_ASTPkgCacheHitsInc_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqMetrics_ASTPkgCacheHitsInc_doFn
		DoReturnFn MoqMetrics_ASTPkgCacheHitsInc_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqMetrics_ASTPkgCacheHitsInc_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqMetrics_ASTPkgCacheHitsInc_resultsByParams
	for n, res := range r.Moq.ResultsByParams_ASTPkgCacheHitsInc {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqMetrics_ASTPkgCacheHitsInc_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqMetrics_ASTPkgCacheHitsInc_paramsKey]*MoqMetrics_ASTPkgCacheHitsInc_results{},
		}
		r.Moq.ResultsByParams_ASTPkgCacheHitsInc = append(r.Moq.ResultsByParams_ASTPkgCacheHitsInc, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_ASTPkgCacheHitsInc) {
			copy(r.Moq.ResultsByParams_ASTPkgCacheHitsInc[insertAt+1:], r.Moq.ResultsByParams_ASTPkgCacheHitsInc[insertAt:0])
			r.Moq.ResultsByParams_ASTPkgCacheHitsInc[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_ASTPkgCacheHitsInc(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqMetrics_ASTPkgCacheHitsInc_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqMetrics_ASTPkgCacheHitsInc_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqMetrics_ASTPkgCacheHitsInc_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqMetrics_ASTPkgCacheHitsInc_doFn
				DoReturnFn MoqMetrics_ASTPkgCacheHitsInc_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqMetrics) PrettyParams_ASTPkgCacheHitsInc(params MoqMetrics_ASTPkgCacheHitsInc_params) string {
	return fmt.Sprintf("ASTPkgCacheHitsInc()")
}

func (m *MoqMetrics) ParamsKey_ASTPkgCacheHitsInc(params MoqMetrics_ASTPkgCacheHitsInc_params, anyParams uint64) MoqMetrics_ASTPkgCacheHitsInc_paramsKey {
	m.Scene.T.Helper()
	return MoqMetrics_ASTPkgCacheHitsInc_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqMetrics_recorder) ASTPkgCacheMissesInc() *MoqMetrics_ASTPkgCacheMissesInc_fnRecorder {
	return &MoqMetrics_ASTPkgCacheMissesInc_fnRecorder{
		Params:   MoqMetrics_ASTPkgCacheMissesInc_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqMetrics_ASTPkgCacheMissesInc_fnRecorder) Any() *MoqMetrics_ASTPkgCacheMissesInc_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ASTPkgCacheMissesInc(r.Params))
		return nil
	}
	return &MoqMetrics_ASTPkgCacheMissesInc_anyParams{Recorder: r}
}

func (r *MoqMetrics_ASTPkgCacheMissesInc_fnRecorder) Seq() *MoqMetrics_ASTPkgCacheMissesInc_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ASTPkgCacheMissesInc(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqMetrics_ASTPkgCacheMissesInc_fnRecorder) NoSeq() *MoqMetrics_ASTPkgCacheMissesInc_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ASTPkgCacheMissesInc(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqMetrics_ASTPkgCacheMissesInc_fnRecorder) ReturnResults() *MoqMetrics_ASTPkgCacheMissesInc_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqMetrics_ASTPkgCacheMissesInc_doFn
		DoReturnFn MoqMetrics_ASTPkgCacheMissesInc_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqMetrics_ASTPkgCacheMissesInc_fnRecorder) AndDo(fn MoqMetrics_ASTPkgCacheMissesInc_doFn) *MoqMetrics_ASTPkgCacheMissesInc_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqMetrics_ASTPkgCacheMissesInc_fnRecorder) DoReturnResults(fn MoqMetrics_ASTPkgCacheMissesInc_doReturnFn) *MoqMetrics_ASTPkgCacheMissesInc_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqMetrics_ASTPkgCacheMissesInc_doFn
		DoReturnFn MoqMetrics_ASTPkgCacheMissesInc_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqMetrics_ASTPkgCacheMissesInc_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqMetrics_ASTPkgCacheMissesInc_resultsByParams
	for n, res := range r.Moq.ResultsByParams_ASTPkgCacheMissesInc {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqMetrics_ASTPkgCacheMissesInc_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqMetrics_ASTPkgCacheMissesInc_paramsKey]*MoqMetrics_ASTPkgCacheMissesInc_results{},
		}
		r.Moq.ResultsByParams_ASTPkgCacheMissesInc = append(r.Moq.ResultsByParams_ASTPkgCacheMissesInc, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_ASTPkgCacheMissesInc) {
			copy(r.Moq.ResultsByParams_ASTPkgCacheMissesInc[insertAt+1:], r.Moq.ResultsByParams_ASTPkgCacheMissesInc[insertAt:0])
			r.Moq.ResultsByParams_ASTPkgCacheMissesInc[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_ASTPkgCacheMissesInc(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqMetrics_ASTPkgCacheMissesInc_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqMetrics_ASTPkgCacheMissesInc_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqMetrics_ASTPkgCacheMissesInc_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqMetrics_ASTPkgCacheMissesInc_doFn
				DoReturnFn MoqMetrics_ASTPkgCacheMissesInc_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqMetrics) PrettyParams_ASTPkgCacheMissesInc(params MoqMetrics_ASTPkgCacheMissesInc_params) string {
	return fmt.Sprintf("ASTPkgCacheMissesInc()")
}

func (m *MoqMetrics) ParamsKey_ASTPkgCacheMissesInc(params MoqMetrics_ASTPkgCacheMissesInc_params, anyParams uint64) MoqMetrics_ASTPkgCacheMissesInc_paramsKey {
	m.Scene.T.Helper()
	return MoqMetrics_ASTPkgCacheMissesInc_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqMetrics_recorder) ASTTypeCacheHitsInc() *MoqMetrics_ASTTypeCacheHitsInc_fnRecorder {
	return &MoqMetrics_ASTTypeCacheHitsInc_fnRecorder{
		Params:   MoqMetrics_ASTTypeCacheHitsInc_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqMetrics_ASTTypeCacheHitsInc_fnRecorder) Any() *MoqMetrics_ASTTypeCacheHitsInc_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ASTTypeCacheHitsInc(r.Params))
		return nil
	}
	return &MoqMetrics_ASTTypeCacheHitsInc_anyParams{Recorder: r}
}

func (r *MoqMetrics_ASTTypeCacheHitsInc_fnRecorder) Seq() *MoqMetrics_ASTTypeCacheHitsInc_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ASTTypeCacheHitsInc(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqMetrics_ASTTypeCacheHitsInc_fnRecorder) NoSeq() *MoqMetrics_ASTTypeCacheHitsInc_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ASTTypeCacheHitsInc(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqMetrics_ASTTypeCacheHitsInc_fnRecorder) ReturnResults() *MoqMetrics_ASTTypeCacheHitsInc_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqMetrics_ASTTypeCacheHitsInc_doFn
		DoReturnFn MoqMetrics_ASTTypeCacheHitsInc_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqMetrics_ASTTypeCacheHitsInc_fnRecorder) AndDo(fn MoqMetrics_ASTTypeCacheHitsInc_doFn) *MoqMetrics_ASTTypeCacheHitsInc_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqMetrics_ASTTypeCacheHitsInc_fnRecorder) DoReturnResults(fn MoqMetrics_ASTTypeCacheHitsInc_doReturnFn) *MoqMetrics_ASTTypeCacheHitsInc_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqMetrics_ASTTypeCacheHitsInc_doFn
		DoReturnFn MoqMetrics_ASTTypeCacheHitsInc_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqMetrics_ASTTypeCacheHitsInc_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqMetrics_ASTTypeCacheHitsInc_resultsByParams
	for n, res := range r.Moq.ResultsByParams_ASTTypeCacheHitsInc {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqMetrics_ASTTypeCacheHitsInc_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqMetrics_ASTTypeCacheHitsInc_paramsKey]*MoqMetrics_ASTTypeCacheHitsInc_results{},
		}
		r.Moq.ResultsByParams_ASTTypeCacheHitsInc = append(r.Moq.ResultsByParams_ASTTypeCacheHitsInc, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_ASTTypeCacheHitsInc) {
			copy(r.Moq.ResultsByParams_ASTTypeCacheHitsInc[insertAt+1:], r.Moq.ResultsByParams_ASTTypeCacheHitsInc[insertAt:0])
			r.Moq.ResultsByParams_ASTTypeCacheHitsInc[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_ASTTypeCacheHitsInc(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqMetrics_ASTTypeCacheHitsInc_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqMetrics_ASTTypeCacheHitsInc_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqMetrics_ASTTypeCacheHitsInc_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqMetrics_ASTTypeCacheHitsInc_doFn
				DoReturnFn MoqMetrics_ASTTypeCacheHitsInc_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqMetrics) PrettyParams_ASTTypeCacheHitsInc(params MoqMetrics_ASTTypeCacheHitsInc_params) string {
	return fmt.Sprintf("ASTTypeCacheHitsInc()")
}

func (m *MoqMetrics) ParamsKey_ASTTypeCacheHitsInc(params MoqMetrics_ASTTypeCacheHitsInc_params, anyParams uint64) MoqMetrics_ASTTypeCacheHitsInc_paramsKey {
	m.Scene.T.Helper()
	return MoqMetrics_ASTTypeCacheHitsInc_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqMetrics_recorder) ASTTypeCacheMissesInc() *MoqMetrics_ASTTypeCacheMissesInc_fnRecorder {
	return &MoqMetrics_ASTTypeCacheMissesInc_fnRecorder{
		Params:   MoqMetrics_ASTTypeCacheMissesInc_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqMetrics_ASTTypeCacheMissesInc_fnRecorder) Any() *MoqMetrics_ASTTypeCacheMissesInc_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ASTTypeCacheMissesInc(r.Params))
		return nil
	}
	return &MoqMetrics_ASTTypeCacheMissesInc_anyParams{Recorder: r}
}

func (r *MoqMetrics_ASTTypeCacheMissesInc_fnRecorder) Seq() *MoqMetrics_ASTTypeCacheMissesInc_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ASTTypeCacheMissesInc(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqMetrics_ASTTypeCacheMissesInc_fnRecorder) NoSeq() *MoqMetrics_ASTTypeCacheMissesInc_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ASTTypeCacheMissesInc(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqMetrics_ASTTypeCacheMissesInc_fnRecorder) ReturnResults() *MoqMetrics_ASTTypeCacheMissesInc_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqMetrics_ASTTypeCacheMissesInc_doFn
		DoReturnFn MoqMetrics_ASTTypeCacheMissesInc_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqMetrics_ASTTypeCacheMissesInc_fnRecorder) AndDo(fn MoqMetrics_ASTTypeCacheMissesInc_doFn) *MoqMetrics_ASTTypeCacheMissesInc_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqMetrics_ASTTypeCacheMissesInc_fnRecorder) DoReturnResults(fn MoqMetrics_ASTTypeCacheMissesInc_doReturnFn) *MoqMetrics_ASTTypeCacheMissesInc_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqMetrics_ASTTypeCacheMissesInc_doFn
		DoReturnFn MoqMetrics_ASTTypeCacheMissesInc_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqMetrics_ASTTypeCacheMissesInc_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqMetrics_ASTTypeCacheMissesInc_resultsByParams
	for n, res := range r.Moq.ResultsByParams_ASTTypeCacheMissesInc {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqMetrics_ASTTypeCacheMissesInc_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqMetrics_ASTTypeCacheMissesInc_paramsKey]*MoqMetrics_ASTTypeCacheMissesInc_results{},
		}
		r.Moq.ResultsByParams_ASTTypeCacheMissesInc = append(r.Moq.ResultsByParams_ASTTypeCacheMissesInc, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_ASTTypeCacheMissesInc) {
			copy(r.Moq.ResultsByParams_ASTTypeCacheMissesInc[insertAt+1:], r.Moq.ResultsByParams_ASTTypeCacheMissesInc[insertAt:0])
			r.Moq.ResultsByParams_ASTTypeCacheMissesInc[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_ASTTypeCacheMissesInc(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqMetrics_ASTTypeCacheMissesInc_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqMetrics_ASTTypeCacheMissesInc_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqMetrics_ASTTypeCacheMissesInc_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqMetrics_ASTTypeCacheMissesInc_doFn
				DoReturnFn MoqMetrics_ASTTypeCacheMissesInc_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqMetrics) PrettyParams_ASTTypeCacheMissesInc(params MoqMetrics_ASTTypeCacheMissesInc_params) string {
	return fmt.Sprintf("ASTTypeCacheMissesInc()")
}

func (m *MoqMetrics) ParamsKey_ASTTypeCacheMissesInc(params MoqMetrics_ASTTypeCacheMissesInc_params, anyParams uint64) MoqMetrics_ASTTypeCacheMissesInc_paramsKey {
	m.Scene.T.Helper()
	return MoqMetrics_ASTTypeCacheMissesInc_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

func (m *MoqMetrics_recorder) ASTTotalLoadTimeInc(d time.Duration) *MoqMetrics_ASTTotalLoadTimeInc_fnRecorder {
	return &MoqMetrics_ASTTotalLoadTimeInc_fnRecorder{
		Params: MoqMetrics_ASTTotalLoadTimeInc_params{
			D: d,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqMetrics_ASTTotalLoadTimeInc_fnRecorder) Any() *MoqMetrics_ASTTotalLoadTimeInc_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ASTTotalLoadTimeInc(r.Params))
		return nil
	}
	return &MoqMetrics_ASTTotalLoadTimeInc_anyParams{Recorder: r}
}

func (a *MoqMetrics_ASTTotalLoadTimeInc_anyParams) D() *MoqMetrics_ASTTotalLoadTimeInc_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqMetrics_ASTTotalLoadTimeInc_fnRecorder) Seq() *MoqMetrics_ASTTotalLoadTimeInc_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ASTTotalLoadTimeInc(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqMetrics_ASTTotalLoadTimeInc_fnRecorder) NoSeq() *MoqMetrics_ASTTotalLoadTimeInc_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ASTTotalLoadTimeInc(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqMetrics_ASTTotalLoadTimeInc_fnRecorder) ReturnResults() *MoqMetrics_ASTTotalLoadTimeInc_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqMetrics_ASTTotalLoadTimeInc_doFn
		DoReturnFn MoqMetrics_ASTTotalLoadTimeInc_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqMetrics_ASTTotalLoadTimeInc_fnRecorder) AndDo(fn MoqMetrics_ASTTotalLoadTimeInc_doFn) *MoqMetrics_ASTTotalLoadTimeInc_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqMetrics_ASTTotalLoadTimeInc_fnRecorder) DoReturnResults(fn MoqMetrics_ASTTotalLoadTimeInc_doReturnFn) *MoqMetrics_ASTTotalLoadTimeInc_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqMetrics_ASTTotalLoadTimeInc_doFn
		DoReturnFn MoqMetrics_ASTTotalLoadTimeInc_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqMetrics_ASTTotalLoadTimeInc_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqMetrics_ASTTotalLoadTimeInc_resultsByParams
	for n, res := range r.Moq.ResultsByParams_ASTTotalLoadTimeInc {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqMetrics_ASTTotalLoadTimeInc_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqMetrics_ASTTotalLoadTimeInc_paramsKey]*MoqMetrics_ASTTotalLoadTimeInc_results{},
		}
		r.Moq.ResultsByParams_ASTTotalLoadTimeInc = append(r.Moq.ResultsByParams_ASTTotalLoadTimeInc, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_ASTTotalLoadTimeInc) {
			copy(r.Moq.ResultsByParams_ASTTotalLoadTimeInc[insertAt+1:], r.Moq.ResultsByParams_ASTTotalLoadTimeInc[insertAt:0])
			r.Moq.ResultsByParams_ASTTotalLoadTimeInc[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_ASTTotalLoadTimeInc(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqMetrics_ASTTotalLoadTimeInc_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqMetrics_ASTTotalLoadTimeInc_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqMetrics_ASTTotalLoadTimeInc_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqMetrics_ASTTotalLoadTimeInc_doFn
				DoReturnFn MoqMetrics_ASTTotalLoadTimeInc_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqMetrics) PrettyParams_ASTTotalLoadTimeInc(params MoqMetrics_ASTTotalLoadTimeInc_params) string {
	return fmt.Sprintf("ASTTotalLoadTimeInc(%#v)", params.D)
}

func (m *MoqMetrics) ParamsKey_ASTTotalLoadTimeInc(params MoqMetrics_ASTTotalLoadTimeInc_params, anyParams uint64) MoqMetrics_ASTTotalLoadTimeInc_paramsKey {
	m.Scene.T.Helper()
	var dUsed time.Duration
	var dUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.ASTTotalLoadTimeInc.D == moq.ParamIndexByValue {
			dUsed = params.D
		} else {
			dUsedHash = hash.DeepHash(params.D)
		}
	}
	return MoqMetrics_ASTTotalLoadTimeInc_paramsKey{
		Params: struct{ D time.Duration }{
			D: dUsed,
		},
		Hashes: struct{ D hash.Hash }{
			D: dUsedHash,
		},
	}
}

func (m *MoqMetrics_recorder) ASTTotalDecorationTimeInc(d time.Duration) *MoqMetrics_ASTTotalDecorationTimeInc_fnRecorder {
	return &MoqMetrics_ASTTotalDecorationTimeInc_fnRecorder{
		Params: MoqMetrics_ASTTotalDecorationTimeInc_params{
			D: d,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqMetrics_ASTTotalDecorationTimeInc_fnRecorder) Any() *MoqMetrics_ASTTotalDecorationTimeInc_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ASTTotalDecorationTimeInc(r.Params))
		return nil
	}
	return &MoqMetrics_ASTTotalDecorationTimeInc_anyParams{Recorder: r}
}

func (a *MoqMetrics_ASTTotalDecorationTimeInc_anyParams) D() *MoqMetrics_ASTTotalDecorationTimeInc_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqMetrics_ASTTotalDecorationTimeInc_fnRecorder) Seq() *MoqMetrics_ASTTotalDecorationTimeInc_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ASTTotalDecorationTimeInc(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqMetrics_ASTTotalDecorationTimeInc_fnRecorder) NoSeq() *MoqMetrics_ASTTotalDecorationTimeInc_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_ASTTotalDecorationTimeInc(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqMetrics_ASTTotalDecorationTimeInc_fnRecorder) ReturnResults() *MoqMetrics_ASTTotalDecorationTimeInc_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqMetrics_ASTTotalDecorationTimeInc_doFn
		DoReturnFn MoqMetrics_ASTTotalDecorationTimeInc_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqMetrics_ASTTotalDecorationTimeInc_fnRecorder) AndDo(fn MoqMetrics_ASTTotalDecorationTimeInc_doFn) *MoqMetrics_ASTTotalDecorationTimeInc_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqMetrics_ASTTotalDecorationTimeInc_fnRecorder) DoReturnResults(fn MoqMetrics_ASTTotalDecorationTimeInc_doReturnFn) *MoqMetrics_ASTTotalDecorationTimeInc_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqMetrics_ASTTotalDecorationTimeInc_doFn
		DoReturnFn MoqMetrics_ASTTotalDecorationTimeInc_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqMetrics_ASTTotalDecorationTimeInc_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqMetrics_ASTTotalDecorationTimeInc_resultsByParams
	for n, res := range r.Moq.ResultsByParams_ASTTotalDecorationTimeInc {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqMetrics_ASTTotalDecorationTimeInc_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqMetrics_ASTTotalDecorationTimeInc_paramsKey]*MoqMetrics_ASTTotalDecorationTimeInc_results{},
		}
		r.Moq.ResultsByParams_ASTTotalDecorationTimeInc = append(r.Moq.ResultsByParams_ASTTotalDecorationTimeInc, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_ASTTotalDecorationTimeInc) {
			copy(r.Moq.ResultsByParams_ASTTotalDecorationTimeInc[insertAt+1:], r.Moq.ResultsByParams_ASTTotalDecorationTimeInc[insertAt:0])
			r.Moq.ResultsByParams_ASTTotalDecorationTimeInc[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_ASTTotalDecorationTimeInc(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqMetrics_ASTTotalDecorationTimeInc_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqMetrics_ASTTotalDecorationTimeInc_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqMetrics_ASTTotalDecorationTimeInc_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqMetrics_ASTTotalDecorationTimeInc_doFn
				DoReturnFn MoqMetrics_ASTTotalDecorationTimeInc_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqMetrics) PrettyParams_ASTTotalDecorationTimeInc(params MoqMetrics_ASTTotalDecorationTimeInc_params) string {
	return fmt.Sprintf("ASTTotalDecorationTimeInc(%#v)", params.D)
}

func (m *MoqMetrics) ParamsKey_ASTTotalDecorationTimeInc(params MoqMetrics_ASTTotalDecorationTimeInc_params, anyParams uint64) MoqMetrics_ASTTotalDecorationTimeInc_paramsKey {
	m.Scene.T.Helper()
	var dUsed time.Duration
	var dUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.ASTTotalDecorationTimeInc.D == moq.ParamIndexByValue {
			dUsed = params.D
		} else {
			dUsedHash = hash.DeepHash(params.D)
		}
	}
	return MoqMetrics_ASTTotalDecorationTimeInc_paramsKey{
		Params: struct{ D time.Duration }{
			D: dUsed,
		},
		Hashes: struct{ D hash.Hash }{
			D: dUsedHash,
		},
	}
}

func (m *MoqMetrics_recorder) TotalProcessingTimeInc(d time.Duration) *MoqMetrics_TotalProcessingTimeInc_fnRecorder {
	return &MoqMetrics_TotalProcessingTimeInc_fnRecorder{
		Params: MoqMetrics_TotalProcessingTimeInc_params{
			D: d,
		},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqMetrics_TotalProcessingTimeInc_fnRecorder) Any() *MoqMetrics_TotalProcessingTimeInc_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_TotalProcessingTimeInc(r.Params))
		return nil
	}
	return &MoqMetrics_TotalProcessingTimeInc_anyParams{Recorder: r}
}

func (a *MoqMetrics_TotalProcessingTimeInc_anyParams) D() *MoqMetrics_TotalProcessingTimeInc_fnRecorder {
	a.Recorder.AnyParams |= 1 << 0
	return a.Recorder
}

func (r *MoqMetrics_TotalProcessingTimeInc_fnRecorder) Seq() *MoqMetrics_TotalProcessingTimeInc_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_TotalProcessingTimeInc(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqMetrics_TotalProcessingTimeInc_fnRecorder) NoSeq() *MoqMetrics_TotalProcessingTimeInc_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_TotalProcessingTimeInc(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqMetrics_TotalProcessingTimeInc_fnRecorder) ReturnResults() *MoqMetrics_TotalProcessingTimeInc_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqMetrics_TotalProcessingTimeInc_doFn
		DoReturnFn MoqMetrics_TotalProcessingTimeInc_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqMetrics_TotalProcessingTimeInc_fnRecorder) AndDo(fn MoqMetrics_TotalProcessingTimeInc_doFn) *MoqMetrics_TotalProcessingTimeInc_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqMetrics_TotalProcessingTimeInc_fnRecorder) DoReturnResults(fn MoqMetrics_TotalProcessingTimeInc_doReturnFn) *MoqMetrics_TotalProcessingTimeInc_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqMetrics_TotalProcessingTimeInc_doFn
		DoReturnFn MoqMetrics_TotalProcessingTimeInc_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqMetrics_TotalProcessingTimeInc_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqMetrics_TotalProcessingTimeInc_resultsByParams
	for n, res := range r.Moq.ResultsByParams_TotalProcessingTimeInc {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqMetrics_TotalProcessingTimeInc_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqMetrics_TotalProcessingTimeInc_paramsKey]*MoqMetrics_TotalProcessingTimeInc_results{},
		}
		r.Moq.ResultsByParams_TotalProcessingTimeInc = append(r.Moq.ResultsByParams_TotalProcessingTimeInc, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_TotalProcessingTimeInc) {
			copy(r.Moq.ResultsByParams_TotalProcessingTimeInc[insertAt+1:], r.Moq.ResultsByParams_TotalProcessingTimeInc[insertAt:0])
			r.Moq.ResultsByParams_TotalProcessingTimeInc[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_TotalProcessingTimeInc(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqMetrics_TotalProcessingTimeInc_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqMetrics_TotalProcessingTimeInc_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqMetrics_TotalProcessingTimeInc_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqMetrics_TotalProcessingTimeInc_doFn
				DoReturnFn MoqMetrics_TotalProcessingTimeInc_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqMetrics) PrettyParams_TotalProcessingTimeInc(params MoqMetrics_TotalProcessingTimeInc_params) string {
	return fmt.Sprintf("TotalProcessingTimeInc(%#v)", params.D)
}

func (m *MoqMetrics) ParamsKey_TotalProcessingTimeInc(params MoqMetrics_TotalProcessingTimeInc_params, anyParams uint64) MoqMetrics_TotalProcessingTimeInc_paramsKey {
	m.Scene.T.Helper()
	var dUsed time.Duration
	var dUsedHash hash.Hash
	if anyParams&(1<<0) == 0 {
		if m.Runtime.ParameterIndexing.TotalProcessingTimeInc.D == moq.ParamIndexByValue {
			dUsed = params.D
		} else {
			dUsedHash = hash.DeepHash(params.D)
		}
	}
	return MoqMetrics_TotalProcessingTimeInc_paramsKey{
		Params: struct{ D time.Duration }{
			D: dUsed,
		},
		Hashes: struct{ D hash.Hash }{
			D: dUsedHash,
		},
	}
}

func (m *MoqMetrics_recorder) Finalize() *MoqMetrics_Finalize_fnRecorder {
	return &MoqMetrics_Finalize_fnRecorder{
		Params:   MoqMetrics_Finalize_params{},
		Sequence: m.Moq.Config.Sequence == moq.SeqDefaultOn,
		Moq:      m.Moq,
	}
}

func (r *MoqMetrics_Finalize_fnRecorder) Any() *MoqMetrics_Finalize_anyParams {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Any functions must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Finalize(r.Params))
		return nil
	}
	return &MoqMetrics_Finalize_anyParams{Recorder: r}
}

func (r *MoqMetrics_Finalize_fnRecorder) Seq() *MoqMetrics_Finalize_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("Seq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Finalize(r.Params))
		return nil
	}
	r.Sequence = true
	return r
}

func (r *MoqMetrics_Finalize_fnRecorder) NoSeq() *MoqMetrics_Finalize_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Moq.Scene.T.Fatalf("NoSeq must be called before ReturnResults or DoReturnResults calls, recording %s", r.Moq.PrettyParams_Finalize(r.Params))
		return nil
	}
	r.Sequence = false
	return r
}

func (r *MoqMetrics_Finalize_fnRecorder) ReturnResults() *MoqMetrics_Finalize_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqMetrics_Finalize_doFn
		DoReturnFn MoqMetrics_Finalize_doReturnFn
	}{
		Values:   &struct{}{},
		Sequence: sequence,
	})
	return r
}

func (r *MoqMetrics_Finalize_fnRecorder) AndDo(fn MoqMetrics_Finalize_doFn) *MoqMetrics_Finalize_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults must be called before calling AndDo")
		return nil
	}
	last := &r.Results.Results[len(r.Results.Results)-1]
	last.DoFn = fn
	return r
}

func (r *MoqMetrics_Finalize_fnRecorder) DoReturnResults(fn MoqMetrics_Finalize_doReturnFn) *MoqMetrics_Finalize_fnRecorder {
	r.Moq.Scene.T.Helper()
	r.FindResults()

	var sequence uint32
	if r.Sequence {
		sequence = r.Moq.Scene.NextRecorderSequence()
	}

	r.Results.Results = append(r.Results.Results, struct {
		Values     *struct{}
		Sequence   uint32
		DoFn       MoqMetrics_Finalize_doFn
		DoReturnFn MoqMetrics_Finalize_doReturnFn
	}{Sequence: sequence, DoReturnFn: fn})
	return r
}

func (r *MoqMetrics_Finalize_fnRecorder) FindResults() {
	r.Moq.Scene.T.Helper()
	if r.Results != nil {
		r.Results.Repeat.Increment(r.Moq.Scene.T)
		return
	}

	anyCount := bits.OnesCount64(r.AnyParams)
	insertAt := -1
	var results *MoqMetrics_Finalize_resultsByParams
	for n, res := range r.Moq.ResultsByParams_Finalize {
		if res.AnyParams == r.AnyParams {
			results = &res
			break
		}
		if res.AnyCount > anyCount {
			insertAt = n
		}
	}
	if results == nil {
		results = &MoqMetrics_Finalize_resultsByParams{
			AnyCount:  anyCount,
			AnyParams: r.AnyParams,
			Results:   map[MoqMetrics_Finalize_paramsKey]*MoqMetrics_Finalize_results{},
		}
		r.Moq.ResultsByParams_Finalize = append(r.Moq.ResultsByParams_Finalize, *results)
		if insertAt != -1 && insertAt+1 < len(r.Moq.ResultsByParams_Finalize) {
			copy(r.Moq.ResultsByParams_Finalize[insertAt+1:], r.Moq.ResultsByParams_Finalize[insertAt:0])
			r.Moq.ResultsByParams_Finalize[insertAt] = *results
		}
	}

	paramsKey := r.Moq.ParamsKey_Finalize(r.Params, r.AnyParams)

	var ok bool
	r.Results, ok = results.Results[paramsKey]
	if !ok {
		r.Results = &MoqMetrics_Finalize_results{
			Params:  r.Params,
			Results: nil,
			Index:   0,
			Repeat:  &moq.RepeatVal{},
		}
		results.Results[paramsKey] = r.Results
	}

	r.Results.Repeat.Increment(r.Moq.Scene.T)
}

func (r *MoqMetrics_Finalize_fnRecorder) Repeat(repeaters ...moq.Repeater) *MoqMetrics_Finalize_fnRecorder {
	r.Moq.Scene.T.Helper()
	if r.Results == nil {
		r.Moq.Scene.T.Fatalf("ReturnResults or DoReturnResults must be called before calling Repeat")
		return nil
	}
	r.Results.Repeat.Repeat(r.Moq.Scene.T, repeaters)
	last := r.Results.Results[len(r.Results.Results)-1]
	for n := 0; n < r.Results.Repeat.ResultCount-1; n++ {
		if r.Sequence {
			last = struct {
				Values     *struct{}
				Sequence   uint32
				DoFn       MoqMetrics_Finalize_doFn
				DoReturnFn MoqMetrics_Finalize_doReturnFn
			}{
				Values:   last.Values,
				Sequence: r.Moq.Scene.NextRecorderSequence(),
			}
		}
		r.Results.Results = append(r.Results.Results, last)
	}
	return r
}

func (m *MoqMetrics) PrettyParams_Finalize(params MoqMetrics_Finalize_params) string {
	return fmt.Sprintf("Finalize()")
}

func (m *MoqMetrics) ParamsKey_Finalize(params MoqMetrics_Finalize_params, anyParams uint64) MoqMetrics_Finalize_paramsKey {
	m.Scene.T.Helper()
	return MoqMetrics_Finalize_paramsKey{
		Params: struct{}{},
		Hashes: struct{}{},
	}
}

// Reset resets the state of the moq
func (m *MoqMetrics) Reset() {
	m.ResultsByParams_ASTPkgCacheHitsInc = nil
	m.ResultsByParams_ASTPkgCacheMissesInc = nil
	m.ResultsByParams_ASTTypeCacheHitsInc = nil
	m.ResultsByParams_ASTTypeCacheMissesInc = nil
	m.ResultsByParams_ASTTotalLoadTimeInc = nil
	m.ResultsByParams_ASTTotalDecorationTimeInc = nil
	m.ResultsByParams_TotalProcessingTimeInc = nil
	m.ResultsByParams_Finalize = nil
}

// AssertExpectationsMet asserts that all expectations have been met
func (m *MoqMetrics) AssertExpectationsMet() {
	m.Scene.T.Helper()
	for _, res := range m.ResultsByParams_ASTPkgCacheHitsInc {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_ASTPkgCacheHitsInc(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_ASTPkgCacheMissesInc {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_ASTPkgCacheMissesInc(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_ASTTypeCacheHitsInc {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_ASTTypeCacheHitsInc(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_ASTTypeCacheMissesInc {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_ASTTypeCacheMissesInc(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_ASTTotalLoadTimeInc {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_ASTTotalLoadTimeInc(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_ASTTotalDecorationTimeInc {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_ASTTotalDecorationTimeInc(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_TotalProcessingTimeInc {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_TotalProcessingTimeInc(results.Params))
			}
		}
	}
	for _, res := range m.ResultsByParams_Finalize {
		for _, results := range res.Results {
			missing := results.Repeat.MinTimes - int(atomic.LoadUint32(&results.Index))
			if missing > 0 {
				m.Scene.T.Errorf("Expected %d additional call(s) to %s", missing, m.PrettyParams_Finalize(results.Params))
			}
		}
	}
}
